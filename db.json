{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/ayer/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/ayer/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/ayer/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.js","path":"dist/main.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.png","path":"images/ayer.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer-side.svg","path":"images/ayer-side.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/ayer.svg","path":"images/ayer.svg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover7.jpg","path":"images/cover7.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/forkme.png","path":"images/forkme.png","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","path":"js/busuanzi-2.3.pure.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/clickLove.js","path":"js/clickLove.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/pace.min.js","path":"js/pace.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/dist/main.css","path":"dist/main.css","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/404.jpg","path":"images/404.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover2.jpg","path":"images/cover2.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/sponsor.jpg","path":"images/sponsor.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover6.jpg","path":"images/cover6.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover1.jpg","path":"images/cover1.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover3.jpg","path":"images/cover3.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover4.jpg","path":"images/cover4.jpg","modified":0,"renderable":1},{"_id":"themes/ayer/source/images/cover5.jpg","path":"images/cover5.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/ayer/.gitignore","hash":"b253f9829edcd1cf2a1fff279de3091e987dce6e","modified":1585993430175},{"_id":"themes/ayer/.postcssrc","hash":"c171a60205840e3dcd3825d5bbb6b2d19d48ee76","modified":1585993430175},{"_id":"themes/ayer/.stylintrc","hash":"eec4e824067be1a223745ca426aa367c8d482673","modified":1585993430176},{"_id":"themes/ayer/.travis.yml","hash":"5acc6f203681ce88bc2dbb0f86e0b3dd32a243a0","modified":1585993430176},{"_id":"themes/ayer/LICENSE","hash":"115a72f86fc1c3f3211398517cd7593a40703334","modified":1585993430177},{"_id":"themes/ayer/README.md","hash":"f0d694bb0bcfbf482b26d5b9fe36fc8803518d18","modified":1585993430177},{"_id":"themes/ayer/_config.yml","hash":"eab0d4926efb15ff58df63faa193e16c19e6718e","modified":1588683317993},{"_id":"themes/ayer/logo.png","hash":"94ede98236a9506e41b39493f72ef2f457858e41","modified":1585993430198},{"_id":"themes/ayer/package.json","hash":"e51d4488c65e268320b5348c243bae99c19285ed","modified":1585993430198},{"_id":"source/_posts/ES6语法学习.md","hash":"6fe219f72e91c4c76755b6e9fdbe40164099db76","modified":1560673882961},{"_id":"source/_posts/CSSOM视图模式.md","hash":"64a4a5474e36970a966c6f9e60d37f42016a04d2","modified":1554649013530},{"_id":"source/_posts/ajax学习.md","hash":"0936771651ea218c72789bb668af489f65ed8f49","modified":1560673859389},{"_id":"source/_posts/css布局思路.md","hash":"a355c0c02abb9d0de5754e076b6eb2eac1323b88","modified":1554649013538},{"_id":"source/_posts/javascript循环语句.md","hash":"8ceceb8d69af58eb472383eb845bbbc7405711f0","modified":1554649013540},{"_id":"source/_posts/js函数理解.md","hash":"21ca579cca32f3686dcee087bfbba8b1b34fe247","modified":1560673895795},{"_id":"source/_posts/js对象理解.md","hash":"7143e5a614ab0f2ddc4243ba8d211a237736bf68","modified":1554649015706},{"_id":"source/_posts/js数组方法.md","hash":"82a74f1e8666673ba5500deb46b505844be37e7a","modified":1554649015707},{"_id":"source/_posts/js面向对象（原型链）.md","hash":"47138cef5ad4fe59160a119a97a35c770260d6fd","modified":1560673906401},{"_id":"source/_posts/module替代scopet.md","hash":"4be74eb8509e9a01d759c7d88da6c8036fc702ae","modified":1560673923684},{"_id":"source/_posts/node+mongoodb学习(一).md","hash":"7fa48faaecc13ede5718d58e080aa189659b1dd4","modified":1560673940105},{"_id":"source/_posts/sass使用之mixin.md","hash":"519d9227eaba6fac51a4a397efa96e8a3198a4eb","modified":1560673946053},{"_id":"source/_posts/test.md","hash":"a15b27be32069ce575d92e9d5118a4fac343979a","modified":1586889617909},{"_id":"source/_posts/vue动画与animations动画库.md","hash":"f8d35cd21b3be7f0a3144e1aea70699aa6361620","modified":1554649015728},{"_id":"source/_posts/vue生命周期和计算属性.md","hash":"81ea3199b1a50054875a1d4d437d56565b27d1ba","modified":1560673955106},{"_id":"source/_posts/vue的实例属性和方法.md","hash":"2608d20feb513ce55bc840c8429211a7c230e851","modified":1560673969288},{"_id":"source/_posts/vue自定义指定.md","hash":"de829d66aa706c8ceb039162b5d9c1ef5e83c9d1","modified":1560673977309},{"_id":"source/_posts/【HEXO】hexo部署到阿里云.md","hash":"ec35b7edcbac9252cf3db82e37def34b78bdf09b","modified":1588688782144},{"_id":"source/_posts/【HTML】参考博客.md","hash":"88939041c9191f87f06b2dc87e70d6430504d52c","modified":1588686758838},{"_id":"source/_posts/【HTTPS】阿里云配置https.md","hash":"ecb563a7bfe538ea374c023ec8a35de1e14493f0","modified":1588688400878},{"_id":"source/_posts/函数内部的特殊对象.md","hash":"30f98d8807c59510c8fc0c60b7f42b40447b3a0b","modified":1554649015749},{"_id":"source/_posts/基本包装类型.md","hash":"4f2bc7193e297b512c49f964da1a6248b5bd4607","modified":1560674012456},{"_id":"source/_posts/深入浅出js对象排序.md","hash":"22a264eba012925eb926bce92eceed8f6de0ab68","modified":1560674019303},{"_id":"source/_posts/组件component.md","hash":"4a4c7ee30bfe37afd6392776ac488bdb8ae8dcdf","modified":1554649015760},{"_id":"source/_posts/练习：vue自定义指令.md","hash":"288cdee0c11fc372c4c95b5ee4eecc5e1e8ab1d1","modified":1554649015757},{"_id":"source/_posts/组件间数据传递.md","hash":"9697404de6682f511a59611de75d8ec37573611a","modified":1560674027917},{"_id":"source/categories/index.md","hash":"b6ce6d039033df4497e096d4582059586fe0b026","modified":1586006979088},{"_id":"source/tags/index.md","hash":"d7b41b1bd5cfc4255b6d2ee7db8fe5d5f0b6aca3","modified":1586007016954},{"_id":"themes/ayer/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1585993430149},{"_id":"themes/ayer/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1585993372260},{"_id":"themes/ayer/.git/config","hash":"c9baf79691be34cbe282882aaf8c16ce702abace","modified":1585993430158},{"_id":"themes/ayer/.git/index","hash":"94b25d7bde3d32f27903dcfb1b1ee00d0dbd3e22","modified":1585993430253},{"_id":"themes/ayer/.git/packed-refs","hash":"f7a8759e368194a440c3c3a7a2dc739831a3f470","modified":1585993430140},{"_id":"themes/ayer/.github/FUNDING.yml","hash":"49e772bb69fec01a4a7bf9d440a28069f3df7970","modified":1585993430175},{"_id":"themes/ayer/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1585993430178},{"_id":"themes/ayer/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1585993430179},{"_id":"themes/ayer/languages/en.yml","hash":"128a100062ebd077aa0a1108d42ea79e6e5a3f8e","modified":1585993430179},{"_id":"themes/ayer/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1585993430179},{"_id":"themes/ayer/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1585993430180},{"_id":"themes/ayer/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1585993430180},{"_id":"themes/ayer/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1585993430180},{"_id":"themes/ayer/languages/nl.yml","hash":"975dec487054bd6fcfa382d84e2165d56f2c4edf","modified":1585993430181},{"_id":"themes/ayer/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1585993430181},{"_id":"themes/ayer/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1585993430181},{"_id":"themes/ayer/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1585993430182},{"_id":"themes/ayer/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1585993430182},{"_id":"themes/ayer/languages/zh-CN.yml","hash":"adce26808252acd1a31898b81e2dd17b4cbfcdab","modified":1585993430182},{"_id":"themes/ayer/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1585993430195},{"_id":"themes/ayer/layout/index.ejs","hash":"c40a98c0a6f55c27959e44c9e8e4f2619fc2ad3f","modified":1585993430196},{"_id":"themes/ayer/layout/categories.ejs","hash":"4039d782c0b1c935ad4898a0bf29afc58c95fbde","modified":1585993430195},{"_id":"themes/ayer/layout/layout.ejs","hash":"63f080aefd0618e359a5fb53027a300c0210aaa5","modified":1585993430196},{"_id":"themes/ayer/layout/page.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":1585993430196},{"_id":"themes/ayer/layout/post.ejs","hash":"75879224e47b3329d7accfc2403580a2412dce25","modified":1585993430197},{"_id":"themes/ayer/layout/tags.ejs","hash":"e7c9f93c6f7041a7d2aa95e85cc131b22aa426b7","modified":1585993430197},{"_id":"themes/ayer/scripts/default_config.js","hash":"617c2614d8bd8ffda2f2f84ab54fb18866e39b33","modified":1585993430201},{"_id":"themes/ayer/source/404.html","hash":"4fc0231bbc93e5de66dc02e8d38e24e1ed0d9df6","modified":1585993430219},{"_id":"themes/ayer/source/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1585993430222},{"_id":"themes/ayer/source-src/main.js","hash":"e42992bf24b2864e33ea5fdfab122b5d41851066","modified":1585993430218},{"_id":"themes/ayer/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1585993372263},{"_id":"themes/ayer/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1585993372264},{"_id":"themes/ayer/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1585993372262},{"_id":"themes/ayer/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1585993372265},{"_id":"themes/ayer/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1585993372267},{"_id":"themes/ayer/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1585993372270},{"_id":"themes/ayer/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1585993372273},{"_id":"themes/ayer/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1585993372275},{"_id":"themes/ayer/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1585993372277},{"_id":"themes/ayer/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1585993372279},{"_id":"themes/ayer/.git/logs/HEAD","hash":"ee034aa26a8e2a8376d9f915fa25fdea359f692c","modified":1585993430153},{"_id":"themes/ayer/layout/_partial/after-footer.ejs","hash":"20e5e79cf89549afc03888c52eeda48e4bad258e","modified":1585993430183},{"_id":"themes/ayer/layout/_partial/archive-post.ejs","hash":"6b3e77cdbf8271c2a22b839608cccaa651f84e93","modified":1585993430183},{"_id":"themes/ayer/layout/_partial/archive.ejs","hash":"12e04e14a663fb4d30f4a22e92b0c3c2de36aaab","modified":1585993430184},{"_id":"themes/ayer/layout/_partial/article.ejs","hash":"d4468c108886f19eaef938efd45a30f0e988c1a4","modified":1585993430184},{"_id":"themes/ayer/layout/_partial/ayer.ejs","hash":"b743debe5c9129fbf806f643c6eff14e25fe5098","modified":1585993430184},{"_id":"themes/ayer/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1585993430185},{"_id":"themes/ayer/layout/_partial/footer.ejs","hash":"e89ebf1aa2542a722927fb2e8fd674ff0132aa44","modified":1585993430185},{"_id":"themes/ayer/layout/_partial/google-analytics.ejs","hash":"3a23d6ae48305c9f1b5c400da780288c2425254b","modified":1585993430186},{"_id":"themes/ayer/layout/_partial/head.ejs","hash":"3233311c721bed6fbb8447c104da3d0a10187b4f","modified":1585993430186},{"_id":"themes/ayer/layout/_partial/katex.ejs","hash":"02cb9da065cd315a06d62d13872dc687c62e9a1f","modified":1585993430186},{"_id":"themes/ayer/layout/_partial/mathjax.ejs","hash":"bcc264b6d6b58b3b692139c4d8b1381da4820da8","modified":1585993430187},{"_id":"themes/ayer/layout/_partial/modal.ejs","hash":"b9caece8b5fb47e250c67f6f80f101f08d04eba9","modified":1585993430188},{"_id":"themes/ayer/layout/_partial/music.ejs","hash":"4a67b36cadf2661a5579a454b7d6e0be34e7a0d4","modified":1585993430188},{"_id":"themes/ayer/layout/_partial/sidebar.ejs","hash":"b7efb7f2b300de23d12ef310d710d809d979f4fd","modified":1585993430194},{"_id":"themes/ayer/layout/_partial/totop.ejs","hash":"b2fc5726168f012bc61845f33a46404ff4065947","modified":1585993430194},{"_id":"themes/ayer/layout/_partial/viewer.ejs","hash":"219f0a0ec2eb35e8ba27a849639a5f634273fb6f","modified":1585993430195},{"_id":"themes/ayer/scripts/filters/index.js","hash":"e0c3b821ecd1cb614569282fb4f6e6f555545f8b","modified":1585993430201},{"_id":"themes/ayer/scripts/filters/meta_generator.js","hash":"86d0b5a475f59324b277824b2de15775505080c6","modified":1585993430202},{"_id":"themes/ayer/scripts/helpers/wordcount.js","hash":"2014b5c5053ad737887b61014a045cc1b08799cd","modified":1585993430203},{"_id":"themes/ayer/scripts/lib/core.js","hash":"00509e97554914e5b0a20e0843dc90bcf53461aa","modified":1585993430203},{"_id":"themes/ayer/scripts/helpers/ayer-plus-vendors.js","hash":"611f3bcd8220312f92c11fa6a5dad02f011068d2","modified":1585993430202},{"_id":"themes/ayer/source/css/custom.styl","hash":"d3dc76192935e696c2c153b014b5c28fbb4c88a7","modified":1585993430219},{"_id":"themes/ayer/source/dist/main.js","hash":"db0c241ade4b1c8069789afee8e4f882462ec366","modified":1585993430221},{"_id":"themes/ayer/source/images/ayer.png","hash":"94ede98236a9506e41b39493f72ef2f457858e41","modified":1585993430225},{"_id":"themes/ayer/source/images/ayer-side.svg","hash":"bf0fc3e052e60c2a10d9dffa7b746358c4c33d6a","modified":1585993430225},{"_id":"themes/ayer/source/images/ayer.svg","hash":"1c87519aec678f95895c8480ddf44b371479f2f5","modified":1585993430225},{"_id":"themes/ayer/source/images/cover7.jpg","hash":"27e67d0ac848efa0f0195352a4b14a2f108565bf","modified":1585993430246},{"_id":"themes/ayer/source/images/forkme.png","hash":"b43e6e18b84edc40636204aa0eb9f266ef54a4e7","modified":1585993430246},{"_id":"themes/ayer/source/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1585993430249},{"_id":"themes/ayer/source/js/clickLove.js","hash":"a35dfb7ff19796c005ee30b55fd95e39d6d59a89","modified":1585993430249},{"_id":"themes/ayer/source/js/lazyload.min.js","hash":"d9bc50752cd7e331dbd0a833386838397c9a079f","modified":1585993430251},{"_id":"themes/ayer/source/js/pace.min.js","hash":"64759f14e0f92d62df57eb752f1745a16aba93ce","modified":1585993430251},{"_id":"themes/ayer/source/js/search.js","hash":"6d5c093d12e922ad204dab1723b786c35847bf1b","modified":1585993430252},{"_id":"themes/ayer/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1585993430252},{"_id":"themes/ayer/source-src/css/_extend.styl","hash":"974b9483061fe83f585cc496791ba07e87c78689","modified":1585993430205},{"_id":"themes/ayer/source-src/css/_mixins.styl","hash":"e4804d78ded3714495f8ac9cebdbd2871ed97549","modified":1585993430206},{"_id":"themes/ayer/source-src/css/_normalize.styl","hash":"df9ca719f651c45a88ab4d6afa6d29edf51aeba9","modified":1585993430206},{"_id":"themes/ayer/source-src/css/_variables.styl","hash":"2fdb4425b6213fed28921f53179e825aee0500cf","modified":1585993430216},{"_id":"themes/ayer/source-src/css/style.styl","hash":"246cf149620cd6d07350aae78e5d53703abb3a60","modified":1585993430217},{"_id":"themes/ayer/source-src/js/ayer.js","hash":"e6846036ef2b44d6bef4f5bb60f3bf6b732953eb","modified":1585993430218},{"_id":"themes/ayer/source-src/js/share.js","hash":"e8fd85622f774be877438421c182cd37eb15196e","modified":1585993430218},{"_id":"themes/ayer/screenshots/hexo-theme-ayer.png","hash":"265e0aaad0962caf7a7cae5ce98f1390c6716592","modified":1585993430200},{"_id":"themes/ayer/source/dist/main.css","hash":"08ec92d9c7cf4f50ef48988a04f7f06b6f784af4","modified":1585993430221},{"_id":"themes/ayer/source/images/404.jpg","hash":"f2c69a093e3c56a8c033fc60967cab04469bc5ec","modified":1585993430223},{"_id":"themes/ayer/source/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1585993430229},{"_id":"themes/ayer/source/images/sponsor.jpg","hash":"d19df6ddd7ca4ce5fe23db4ec2865265efa7ea54","modified":1585993430247},{"_id":"themes/ayer/source/js/jquery-2.0.3.min.js","hash":"e68550a39c95a6400287b3abd77f40c44f322e50","modified":1585993430250},{"_id":"themes/ayer/source-src/css/_remixicon.styl","hash":"01e513e1fc0780e5c685eb3fb94fd6fec3a8594f","modified":1585993430216},{"_id":"themes/ayer/.git/objects/pack/pack-a6eeefe810de37d54b10867f9b911e0f66b7b5ae.idx","hash":"ce4ec37b29e3f82c2785c13b4f27e1d71f7a9be5","modified":1585993429994},{"_id":"themes/ayer/.git/refs/heads/master","hash":"c2442636f8e56bfc84da73a57eae5bb419529141","modified":1585993430151},{"_id":"themes/ayer/layout/_partial/post/albums.ejs","hash":"f4cfbabca9f59a9e5aa457a6f2a9cf6f56cd22b3","modified":1585993430189},{"_id":"themes/ayer/layout/_partial/post/busuanzi.ejs","hash":"4e30e1b940eb06264a5ab5e39f5a9ae286ab6d93","modified":1585993430189},{"_id":"themes/ayer/layout/_partial/post/category.ejs","hash":"89cb32e8d98bad81d3ef33377212e9b253699d3d","modified":1585993430189},{"_id":"themes/ayer/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1585993430189},{"_id":"themes/ayer/layout/_partial/post/gallery.ejs","hash":"6f78a49edc91f230b0a838c77630e9671d8d6089","modified":1585993430190},{"_id":"themes/ayer/layout/_partial/post/gitalk.ejs","hash":"38bb3f504a878d163a430ce6253dae3142a8fae5","modified":1585993430190},{"_id":"themes/ayer/layout/_partial/post/justifiedGallery.ejs","hash":"a313df6a014a0f2ba6b869dabc56bacb8ff6324d","modified":1585993430191},{"_id":"themes/ayer/layout/_partial/post/nav.ejs","hash":"a73010cbbc463089a1376889850fb0890143c988","modified":1585993430191},{"_id":"themes/ayer/layout/_partial/post/search.ejs","hash":"47c818c236b063d6ce0c41e0824f9f10a3521414","modified":1585993430191},{"_id":"themes/ayer/layout/_partial/post/share.ejs","hash":"9a978d55358878c97186ed010e536e1b314adb35","modified":1585993430192},{"_id":"themes/ayer/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1585993430192},{"_id":"themes/ayer/layout/_partial/post/title.ejs","hash":"e55c57b8cb8c8acf0ed998ea31c2fbc1d6256027","modified":1585993430192},{"_id":"themes/ayer/layout/_partial/post/topping.ejs","hash":"de2c50fb5b7a816287c6d048a2a22ae9c29abcdd","modified":1585993430193},{"_id":"themes/ayer/layout/_partial/post/tocbot.ejs","hash":"17ac504f2a6d561765046a0ba19dcce504104517","modified":1585993430193},{"_id":"themes/ayer/layout/_partial/post/valine.ejs","hash":"070662f5e0ccfcdecbae3607c224b2ccf7cdefe9","modified":1585993430193},{"_id":"themes/ayer/layout/_partial/post/word.ejs","hash":"5b785368a0a6f3b5538aa1b9e7574daa8dfb0df6","modified":1585993430194},{"_id":"themes/ayer/source/images/cover6.jpg","hash":"46942a4d90cac9ef8f33ae3e83ccf9aa7190bed6","modified":1585993430245},{"_id":"themes/ayer/source-src/css/_partial/apple.styl","hash":"333f9e59dc6625c4dee126a1c1a9c25ce9292655","modified":1585993430207},{"_id":"themes/ayer/source-src/css/_partial/archive.styl","hash":"c20ad235d8aab4bc77a2372a053d86fe0069f7fe","modified":1585993430207},{"_id":"themes/ayer/source-src/css/_partial/article.styl","hash":"61c9b30c01c6ecd3e90ae3f568df690e70754c7f","modified":1585993430208},{"_id":"themes/ayer/source-src/css/_partial/articles.styl","hash":"ddbe833939180afdc832659c5cdad08f77ef4f46","modified":1585993430208},{"_id":"themes/ayer/source-src/css/_partial/ayer.styl","hash":"cfcae3839170f2d04ea504a3cd3d62a9cde6647d","modified":1585993430208},{"_id":"themes/ayer/source-src/css/_partial/categories.styl","hash":"b86d2385a095c60ef012641874e222febf017cd3","modified":1585993430209},{"_id":"themes/ayer/source-src/css/_partial/float.styl","hash":"b1abfdfd05e74745484f7e6d043ef2842b3f6b41","modified":1585993430209},{"_id":"themes/ayer/source-src/css/_partial/footer.styl","hash":"a5d81197c6b69e4e31a3f13021deedf7fe72bc76","modified":1585993430210},{"_id":"themes/ayer/source-src/css/_partial/gallery.styl","hash":"f5eae1b0030cfd97f1646844c9d3f692dbb38946","modified":1585993430210},{"_id":"themes/ayer/source-src/css/_partial/gitalk.styl","hash":"0678e8b330daea56fa30d14e97de73289a7d6f22","modified":1585993430211},{"_id":"themes/ayer/source-src/css/_partial/justifiedGallery.styl","hash":"9828c78fb59c3ea3de7cce2569313d12c4b1a6ff","modified":1585993430211},{"_id":"themes/ayer/source-src/css/_partial/highlight.styl","hash":"1210f704aae34ef653e3a458cccb700b05353ea1","modified":1585993430211},{"_id":"themes/ayer/source-src/css/_partial/layout.styl","hash":"11cb01af7fc318f371e4df414a7f3301b80e8cb6","modified":1585993430212},{"_id":"themes/ayer/source-src/css/_partial/lists.styl","hash":"dc45f8b1a5942d4d979fb0859bc47a86f73fe0a9","modified":1585993430212},{"_id":"themes/ayer/source-src/css/_partial/navbar.styl","hash":"30d7e1de22185c4b4da33eef66b5eb96f9e5ae98","modified":1585993430213},{"_id":"themes/ayer/source-src/css/_partial/mobile.styl","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1585993430212},{"_id":"themes/ayer/source-src/css/_partial/pace.styl","hash":"bbda18c692fc66ae99e45347ff52c14e44a08e3b","modified":1585993430213},{"_id":"themes/ayer/source-src/css/_partial/reward.styl","hash":"a032e43e5842f752fd612ddbbd7943ecece7c35b","modified":1585993430213},{"_id":"themes/ayer/source-src/css/_partial/search.styl","hash":"3f2c7bd1371f6f25aec7c581dbae7b52f95ec4c6","modified":1585993430213},{"_id":"themes/ayer/source-src/css/_partial/share.styl","hash":"4a6e6ac9156553dd5cee1eeee8fdc6f1f8a5d117","modified":1585993430214},{"_id":"themes/ayer/source-src/css/_partial/sidebar.styl","hash":"cdc7bea47a768b18991decde0d38c554399621ee","modified":1585993430214},{"_id":"themes/ayer/source-src/css/_partial/tag.styl","hash":"6072aa6bd16e0a1e75f0258d7b20587cab56fff8","modified":1585993430214},{"_id":"themes/ayer/source-src/css/_partial/totop.styl","hash":"b6010788be1d99a345abcf0cf9cdf0a564b90d3c","modified":1585993430215},{"_id":"themes/ayer/source-src/css/_partial/tocbot.styl","hash":"5ba644d46e3eae1f42d238a0999b4b4ddbf9016f","modified":1585993430215},{"_id":"themes/ayer/source-src/css/_partial/albums.styl","hash":"5802253789028a4d9dac474168fc7132045e72ff","modified":1585993430207},{"_id":"themes/ayer/.git/logs/refs/heads/master","hash":"ee034aa26a8e2a8376d9f915fa25fdea359f692c","modified":1585993430152},{"_id":"themes/ayer/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1585993430146},{"_id":"themes/ayer/source/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1585993430228},{"_id":"themes/ayer/source/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1585993430232},{"_id":"themes/ayer/.git/logs/refs/remotes/origin/HEAD","hash":"ee034aa26a8e2a8376d9f915fa25fdea359f692c","modified":1585993430146},{"_id":"themes/ayer/source/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1585993430236},{"_id":"themes/ayer/source/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1585993430244},{"_id":"themes/ayer/.git/objects/pack/pack-a6eeefe810de37d54b10867f9b911e0f66b7b5ae.pack","hash":"5191d70c1afd7641aa7ce0f05d0ca1b9e8678abe","modified":1585993429993},{"_id":"public/atom.xml","hash":"48c7181a0453e0ab09ce3894d17a99d40895f892","modified":1588688938749},{"_id":"public/search.xml","hash":"b5ceec1775158a8074f00dcecb3e78c3cc1ba324","modified":1588688938749},{"_id":"public/tags/index.html","hash":"fd863c5ff879adc94ffeaed0f9d91f6289a131b4","modified":1588688938987},{"_id":"public/2020/04/15/test/index.html","hash":"372ee1e502084837696d5b32445e6a4f0101b41e","modified":1588688938988},{"_id":"public/categories/index.html","hash":"6a9ee70928853d052f1fe8689be2e8f45753a09d","modified":1588688939013},{"_id":"public/2018/04/29/函数内部的特殊对象/index.html","hash":"72c504dbcf783c309bbf421b819a192638538585","modified":1588688939014},{"_id":"public/2018/04/02/css布局思路/index.html","hash":"2f27e76a4504a673f69bd0cacf501a25d6ca8152","modified":1588688939015},{"_id":"public/archives/index.html","hash":"37c8d349138749088f4ae32bb7c17d800edfecfa","modified":1588688939015},{"_id":"public/archives/page/2/index.html","hash":"aa18ee8b4ac93e6b2507f5065595cf3e1dc43ef7","modified":1588688939015},{"_id":"public/archives/page/3/index.html","hash":"a218e6db54905c2f72ca5395f0c7e6b0807ae7c6","modified":1588688939015},{"_id":"public/archives/2018/index.html","hash":"e16c07069ee96d9479ada40ad9a27efe37956949","modified":1588688939015},{"_id":"public/archives/2018/page/2/index.html","hash":"aa86cf11893ed4072e09504eca74c0bb70284495","modified":1588688939015},{"_id":"public/archives/2018/page/3/index.html","hash":"0b0a54cf0901e275b9f0cf37252f7bdef447585e","modified":1588688939015},{"_id":"public/archives/2018/04/index.html","hash":"110a144166028ffc8b40e85ed053d1b8cd02a0f6","modified":1588688939015},{"_id":"public/archives/2018/04/page/2/index.html","hash":"729dfa0ff08e4a33eb25f58a2ef4b5347013249a","modified":1588688939015},{"_id":"public/archives/2018/05/index.html","hash":"4638bbe6b29c7d35f87132ce5a99eb58a53aee13","modified":1588688939015},{"_id":"public/archives/2019/index.html","hash":"5585b84cd9aa4654c05db6d8d9532d6c7dcfca78","modified":1588688939016},{"_id":"public/archives/2019/04/index.html","hash":"fa390a63a7c19e828a58153a070bb6100e8fc4a6","modified":1588688939016},{"_id":"public/archives/2020/index.html","hash":"25a218e9ef120b362c7cc7a6355414ec5bdf4b81","modified":1588688939016},{"_id":"public/archives/2020/04/index.html","hash":"404c07b5080bd28582fc4d259c3273f3594db706","modified":1588688939016},{"_id":"public/categories/JS学习笔记/index.html","hash":"18638b73a47f36a845e7c740061af7a98ee87f29","modified":1588688939016},{"_id":"public/categories/css学习笔记/index.html","hash":"ef8c8d73544ede79ba4e803df579b1880482192e","modified":1588688939016},{"_id":"public/categories/JS学习笔记-vue学习/index.html","hash":"5271cbdd580da9b4564206de6797340cef0bbccd","modified":1588688939016},{"_id":"public/categories/前端/index.html","hash":"e4517f9f6d5275f840d7b36c9463f540fbb36137","modified":1588688939016},{"_id":"public/categories/vue/index.html","hash":"4027e6e252d520296b36dc055f0743fcc416911c","modified":1588688939016},{"_id":"public/categories/前端-vue/index.html","hash":"37870a765e2d0511884113e008e574ae3facb466","modified":1588688939016},{"_id":"public/tags/ES6/index.html","hash":"e268b44bb6ee71ba4d484ab6847481af9388523e","modified":1588688939017},{"_id":"public/tags/浏览器视图属性/index.html","hash":"cb5a12fa2915ce8c646ae647ba6090d17b6ec60e","modified":1588688939017},{"_id":"public/tags/页面内元素移动和滚动/index.html","hash":"6ac3b514d6a017eb20a6ca3b61ccc6a8346b0948","modified":1588688939017},{"_id":"public/tags/CSS/index.html","hash":"1d3c4ab63e0e09b25c1ea228d267fc0efd8d59b8","modified":1588688939017},{"_id":"public/tags/ajax-网络请求-js/index.html","hash":"c1b711083d8c2e7c6d850c5c8e6c66f251552bcc","modified":1588688939017},{"_id":"public/tags/循环语句-js/index.html","hash":"8fef6b54e40c7ece45536ed24edb93fbde16622e","modified":1588688939017},{"_id":"public/tags/函数-js/index.html","hash":"a6f2ebcb9eab767228cc928f15aeeecd95842197","modified":1588688939017},{"_id":"public/tags/对象-js/index.html","hash":"58fd6b0b2acd4a903106076d85986a269e23ff0f","modified":1588688939017},{"_id":"public/categories/test/index.html","hash":"c5beadaea356402bfc5567bfc7512605d87489ae","modified":1588688939017},{"_id":"public/tags/数组-js/index.html","hash":"9ea666d80f3b7242fee86bc210ff9fb59695ce1c","modified":1588688939017},{"_id":"public/tags/面向对象-原型链-js/index.html","hash":"bd93680d1d2ddecb88c24f09786011f03e06d54c","modified":1588688939017},{"_id":"public/tags/css/index.html","hash":"fcdc51d0a0caba7aaff8c6a388d326d5da21d547","modified":1588688939018},{"_id":"public/tags/css模块化/index.html","hash":"750bc42cf2fab17ea4033f7f8b69ef111cf86c27","modified":1588688939018},{"_id":"public/tags/node/index.html","hash":"94321c3799ec878c7fba40d94186550368202b16","modified":1588688939018},{"_id":"public/tags/mongoodb/index.html","hash":"56dbbc76516f575e141e0f6aa573ad743020499f","modified":1588688939018},{"_id":"public/tags/实战笔记/index.html","hash":"0a519538ff64bfbde0334ec7128f6118a6260815","modified":1588688939018},{"_id":"public/tags/SASS/index.html","hash":"9d74e9b898381a49c6a38cc2482c680f3343f1b9","modified":1588688939018},{"_id":"public/tags/vue/index.html","hash":"9263c97271c02859cc08eb22430ac56d398fb337","modified":1588688939018},{"_id":"public/tags/生命周期-计算属性/index.html","hash":"163ec70d8a6475676eaf0e9a10e88635c94e1be0","modified":1588688939018},{"_id":"public/tags/vue实例属性-计算属性/index.html","hash":"87ef15f2043482f63059763fbbd85958861357b0","modified":1588688939018},{"_id":"public/tags/基本包装类型-js/index.html","hash":"ee3ed0e70d7362d2817264423df967b05926c860","modified":1588688939018},{"_id":"public/tags/排序-js/index.html","hash":"c03bb86f62c0c946eb999c4c09b8744cf9db2fa3","modified":1588688939018},{"_id":"public/tags/vue组件/index.html","hash":"9386dda8c9a465933d0374dc0c8bf637d616031e","modified":1588688939018},{"_id":"public/tags/数据传递/index.html","hash":"ea35bace9cc0cefe7dd4e67cdc0aee8601b56717","modified":1588688939019},{"_id":"public/2019/04/07/node+mongoodb学习(一)/index.html","hash":"0fc12aa143aebb05071e344b1bab0283d912452f","modified":1588688939019},{"_id":"public/2018/05/03/组件间数据传递/index.html","hash":"77d82489320b66ee8601af21080853fac5122d9d","modified":1588688939019},{"_id":"public/2018/05/03/组件component/index.html","hash":"159196a7865f5ea6a20c9d1bfd51733a76cf3345","modified":1588688939019},{"_id":"public/2018/05/02/练习：vue自定义指令/index.html","hash":"548cfb88ff2b775ee81070fee8f5a287ad99dfb7","modified":1588688939019},{"_id":"public/2018/05/02/CSSOM视图模式/index.html","hash":"300c41fa828d89a7a3621b70388e067911267719","modified":1588688939019},{"_id":"public/2018/05/01/vue动画与animations动画库/index.html","hash":"1031bcf0f63b2e4f572299f73483fbbb475d7cc6","modified":1588688939019},{"_id":"public/2018/05/01/vue自定义指定/index.html","hash":"ae6e6c1178f2aa92b0eb3966f19966c4ad533d98","modified":1588688939019},{"_id":"public/2018/05/01/vue的实例属性和方法/index.html","hash":"9ebd37a262792755a09413fc2f0f82ba46923b2e","modified":1588688939019},{"_id":"public/2018/05/01/vue生命周期和计算属性/index.html","hash":"c1896987711e0a1ea9dcde04f2d54e0d900ca704","modified":1588688939020},{"_id":"public/2018/05/01/ajax学习/index.html","hash":"0e401124fa4d2408bcbee6659be4ec56d470a8b8","modified":1588688939020},{"_id":"public/2018/05/01/js面向对象（原型链）/index.html","hash":"1b8b2d4c563708d546c8534f64c37c0a6ea007f5","modified":1588688939020},{"_id":"public/2018/04/30/基本包装类型/index.html","hash":"fe1e0beb62c84b409d5c10dd275df3822a687c62","modified":1588688939020},{"_id":"public/2018/04/30/js函数理解/index.html","hash":"58933c24b7372a7231eb0077e1e9a2a3d414277e","modified":1588688939020},{"_id":"public/2018/04/29/js数组方法/index.html","hash":"1207932f5a011ac2569a77924ea13e1baa5a4572","modified":1588688939020},{"_id":"public/2018/04/29/js对象理解/index.html","hash":"edf5d2246468e9147039b9a61346b630b3c03420","modified":1588688939020},{"_id":"public/2018/04/28/深入浅出js对象排序/index.html","hash":"fa26dc7d4ee7c54a454332fb42023e73d65fc611","modified":1588688939020},{"_id":"public/2018/04/28/javascript循环语句/index.html","hash":"11d44abd4355c1451acf7df5790335f80080c9fb","modified":1588688939020},{"_id":"public/2018/04/13/ES6语法学习/index.html","hash":"9feb01b099818e4378e0a8d872ccaf44fc348bb1","modified":1588688939021},{"_id":"public/2018/04/08/module替代scopet/index.html","hash":"0bbb01362e7b294c23eb279868c4c8fc87f37e68","modified":1588688939021},{"_id":"public/2018/04/08/sass使用之mixin/index.html","hash":"a0536f4365552d676e5eb36b2bcc92f48c2e41f9","modified":1588688939021},{"_id":"public/index.html","hash":"e0e9fbc6cc4cc99998f2f36dcfea4e289fc032e8","modified":1588688939021},{"_id":"public/page/2/index.html","hash":"6a23c4ea48d07082eb239177ea23cecd7b3414da","modified":1588688939021},{"_id":"public/page/3/index.html","hash":"b78273b66694faf17bfd9632b540498ef582eeba","modified":1588688939021},{"_id":"public/2020/05/05/【HEXO】hexo部署到阿里云/index.html","hash":"daba98403693cc279a1ae7152677dfe7d85bc2c8","modified":1588688939041},{"_id":"public/archives/2020/05/index.html","hash":"cc70c54d0a90701e991acdc181a3f7cf76f456e7","modified":1588688939041},{"_id":"public/categories/云服务器/index.html","hash":"cd1827a60d242c8f7ea07de6c7039ea12c02bc57","modified":1588688939041},{"_id":"public/tags/html/index.html","hash":"e43a152d4b5402d3ebb7f3a60241f4d5d71c6a8c","modified":1588688939041},{"_id":"public/tags/网页排版/index.html","hash":"f19ef2a6f6f4068dc99b8818175fec7947307dd1","modified":1588688939041},{"_id":"public/tags/他人博客/index.html","hash":"53289ee938deb3ec440faede3181aba4aa5f7b4a","modified":1588688939041},{"_id":"public/tags/https/index.html","hash":"0cb7eebd95921074958bcb19654274c1e4474320","modified":1588688939042},{"_id":"public/tags/nginx/index.html","hash":"8a4fe52c37b0de84158bdfbac2116307a3be8cef","modified":1588688939042},{"_id":"public/2020/05/05/【HTML】参考博客/index.html","hash":"ff4ebe013eec5f274ed7a99da42cd596ed6c684e","modified":1588688939042},{"_id":"public/2020/05/05/【HTTPS】阿里云配置https/index.html","hash":"d30da5c658d32d685185b55abc884390bc0370ad","modified":1588688939042},{"_id":"public/favicon.ico","hash":"473ba682e828a7e34f24fae320e77b6bed4260c7","modified":1588688939049},{"_id":"public/images/ayer.png","hash":"94ede98236a9506e41b39493f72ef2f457858e41","modified":1588688939049},{"_id":"public/images/ayer-side.svg","hash":"bf0fc3e052e60c2a10d9dffa7b746358c4c33d6a","modified":1588688939049},{"_id":"public/images/ayer.svg","hash":"1c87519aec678f95895c8480ddf44b371479f2f5","modified":1588688939049},{"_id":"public/images/cover7.jpg","hash":"27e67d0ac848efa0f0195352a4b14a2f108565bf","modified":1588688939049},{"_id":"public/images/forkme.png","hash":"b43e6e18b84edc40636204aa0eb9f266ef54a4e7","modified":1588688939049},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1588688939050},{"_id":"public/images/404.jpg","hash":"f2c69a093e3c56a8c033fc60967cab04469bc5ec","modified":1588688939520},{"_id":"public/images/cover2.jpg","hash":"f61dd08c95327468c5f6bc5175eff68d00f05b46","modified":1588688939521},{"_id":"public/images/sponsor.jpg","hash":"d19df6ddd7ca4ce5fe23db4ec2865265efa7ea54","modified":1588688939521},{"_id":"public/css/custom.css","hash":"946d13f85cc860747ccf19635a833387a77c957f","modified":1588688939556},{"_id":"public/dist/main.js","hash":"2c886c8382df92c7af2bd7e446f3e3aa499c829e","modified":1588688939556},{"_id":"public/js/clickLove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1588688939556},{"_id":"public/js/busuanzi-2.3.pure.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1588688939556},{"_id":"public/js/lazyload.min.js","hash":"b801b3946fb9b72e03512c0663458e140e1fa77b","modified":1588688939556},{"_id":"public/js/search.js","hash":"118be0e0918532ac1225f62e1a0a6f0673e0b173","modified":1588688939557},{"_id":"public/js/pace.min.js","hash":"d32ab818e0f97d3b0c80f5631fc23d8a0cb52795","modified":1588688939557},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1588688939557},{"_id":"public/404.html","hash":"cca435efc401bf0932ccddbd63558a89bc4e4190","modified":1588688939557},{"_id":"public/dist/main.css","hash":"08ec92d9c7cf4f50ef48988a04f7f06b6f784af4","modified":1588688939557},{"_id":"public/js/jquery-2.0.3.min.js","hash":"800edb7787c30f4982bf38f2cb8f4f6fb61340e9","modified":1588688939557},{"_id":"public/images/cover6.jpg","hash":"46942a4d90cac9ef8f33ae3e83ccf9aa7190bed6","modified":1588688939557},{"_id":"public/images/cover1.jpg","hash":"e019fbed6158ae3e4ec3d255b41bddc1afcbfa90","modified":1588688939611},{"_id":"public/images/cover3.jpg","hash":"7b4e7c9ce19ce5d5c1588b2567e88ecbb04370af","modified":1588688939611},{"_id":"public/images/cover4.jpg","hash":"77040e609d2f1c60e00a8e47cb95b25bf7ff5b9c","modified":1588688939630},{"_id":"public/images/cover5.jpg","hash":"1a2d6182d94b015a45fe4bf8e8a239dfcc0ef776","modified":1588688939636}],"Category":[{"name":"JS学习笔记","_id":"ck9u0dhej00049kudzdjjvbm8"},{"name":"css学习笔记","_id":"ck9u0dhf0000e9kudvz8ism6p"},{"name":"JS学习笔记 vue学习","_id":"ck9u0dhf8000l9kud03okiija"},{"name":"前端","_id":"ck9u0dhfe000t9kudwxpdeh5k"},{"name":"test","_id":"ck9u0dhfy001e9kud8qvqkomf"},{"name":"vue","_id":"ck9u0dhg4001l9kudvkpqvpzu"},{"name":"前端 vue","_id":"ck9u0dhg9001r9kudbjxa2wpx"},{"name":"云服务器","_id":"ck9u0dhgo00289kudkta6oeok"}],"Data":[],"Page":[{"title":"categories","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\nlayout: \"categories\"\n---\n","date":"2020-04-04T13:29:39.088Z","updated":"2020-04-04T13:29:39.088Z","path":"categories/index.html","comments":1,"_id":"ck9u0dhec00019kud22pp5aox","content":"<script src=\"/assets/js/APlayer.min.js\"> </script>","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: \"tags\"\nlayout: \"tags\"\n---","date":"2020-04-04T13:30:16.954Z","updated":"2020-04-04T13:30:16.954Z","path":"tags/index.html","comments":1,"_id":"ck9u0dheh00039kudh2rkqh6q","content":"<script src=\"/assets/js/APlayer.min.js\"> </script>","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES6语法学习","date":"2018-04-13T07:39:19.000Z","_content":"\n# ES6\n\n在代码中，如果使用了ES6语法，那么强制开启严格模式\n\n## let和const\n\n- let:使用let定义的变量，拥有块级作用域.\n\n注意：使用let定义变量，在同一块级作用域内，不能重复定义同一个名字。\n\n<!-- more -->\n\n- const:使用const定义的是常量，不可更改，且也拥有块级作用域。\n\n注意：const只能在定义赋值，因为它定义的是常量，不可更改。除非在定义时赋值的常量，是一个Object。因为Object是引用类型，赋值Object等于给const赋值了一个指针，指针不会变，Object改变不影响指向它的指针。\n\n### 涉及的JS基础知识\n\n基本类型（私人空间）：每定义一个变量，就会在栈内存中开辟一个存放这个变量的空间。\n\n引用类型（公共空间）：如果有两个不同的变量指向同一个对象，则这个对象是唯一存在堆内存的。当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。\n\n## 解构赋值\n\n示例：\n数组解构赋值\n\n    {\n        let a,b;\n        [a,b]=[1,2];\n        console.log(a,b); // 1 2\n    }\n\n赋值展开平铺语法：...变量\n\n    {\n        let a,b,rest;\n        [a,b,...rest]=[1,2,3,4,5,6];\n        console.log(a,b,rest); // 1 2 [3,4,5,6]\n    }\n\n对象解构赋值：\n\n    {\n        let a,b;\n        ({a,b}={a:1,b:2})\n        console.log(a,b); // 1 2\n    }\n\n如果解构赋值没有在结构上成功配对，则赋值对象为未定义,否则设定默认值\n\n    {\n        let a,b,c,rest;\n        [a,b,c=3]=[1,2]\n        console.log(a,b,c) //1 2 3\n    }\n\n解构赋值的常用使用场景：\n1.数值交换\n\n    {\n        let a=1;\n        let b=2;\n        [a,b]=[b,a];\n        console.log(a,b); // 2 1\n    }\n\n2.函数返回\n\n    {\n        function f(){\n            return [1,2]\n        }\n        let a,b;\n        [a,b]=f();\n        console.log(a,b); // 1 2\n    }\n\n3.函数选择返回\n\n    {\n        function f(){\n            return [1,2,3,4,5,]\n        }\n        let a,b,c;\n        [a,,,b]=f();\n        console.log(a,b); // 1 4\n    }\n\n4.函数平铺返回\n\n    {\n        function f(){\n            return [1,2,3,4,5,]\n        }\n        let a,b,c;\n        [a,...b]=f();\n        console.log(a,b); // 1 [2,3,4,5]\n    }\n\n5.对象解构赋值\n\n    {\n        let o={p:42,q:true};\n        let {p,q}=o;\n        console.log(p,q); // 42 true\n    }\n\n6,对象设置默认值\n\n    {\n        let {a=10,b=5}={a:3}\n        console.log(a,b); // 3 5\n    }\n\n### 解构赋值：模拟后台json数据\n\n    {\n        let metaData={\n            title:'abc',\n            test:[{\n                title:'test',\n                desc:'description'\n            }]\n        }\n        let {title:esTitle,test:[{title:cnTitle}]}=metaData;\n        console.log(esTitle,cnTitle);\n    }\n\n## Module模块化\n\n导出：\nexport xxx()\nexport default {\n    xxx,\n    zzz\n    yyy\n}\n\n引入：\nimport xxx from './路径'\n","source":"_posts/ES6语法学习.md","raw":"---\ntitle: ES6语法学习\ndate: 2018-04-13 15:39:19\ncategories:\n  - JS学习笔记\ntags:\n  - ES6\n---\n\n# ES6\n\n在代码中，如果使用了ES6语法，那么强制开启严格模式\n\n## let和const\n\n- let:使用let定义的变量，拥有块级作用域.\n\n注意：使用let定义变量，在同一块级作用域内，不能重复定义同一个名字。\n\n<!-- more -->\n\n- const:使用const定义的是常量，不可更改，且也拥有块级作用域。\n\n注意：const只能在定义赋值，因为它定义的是常量，不可更改。除非在定义时赋值的常量，是一个Object。因为Object是引用类型，赋值Object等于给const赋值了一个指针，指针不会变，Object改变不影响指向它的指针。\n\n### 涉及的JS基础知识\n\n基本类型（私人空间）：每定义一个变量，就会在栈内存中开辟一个存放这个变量的空间。\n\n引用类型（公共空间）：如果有两个不同的变量指向同一个对象，则这个对象是唯一存在堆内存的。当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。\n\n## 解构赋值\n\n示例：\n数组解构赋值\n\n    {\n        let a,b;\n        [a,b]=[1,2];\n        console.log(a,b); // 1 2\n    }\n\n赋值展开平铺语法：...变量\n\n    {\n        let a,b,rest;\n        [a,b,...rest]=[1,2,3,4,5,6];\n        console.log(a,b,rest); // 1 2 [3,4,5,6]\n    }\n\n对象解构赋值：\n\n    {\n        let a,b;\n        ({a,b}={a:1,b:2})\n        console.log(a,b); // 1 2\n    }\n\n如果解构赋值没有在结构上成功配对，则赋值对象为未定义,否则设定默认值\n\n    {\n        let a,b,c,rest;\n        [a,b,c=3]=[1,2]\n        console.log(a,b,c) //1 2 3\n    }\n\n解构赋值的常用使用场景：\n1.数值交换\n\n    {\n        let a=1;\n        let b=2;\n        [a,b]=[b,a];\n        console.log(a,b); // 2 1\n    }\n\n2.函数返回\n\n    {\n        function f(){\n            return [1,2]\n        }\n        let a,b;\n        [a,b]=f();\n        console.log(a,b); // 1 2\n    }\n\n3.函数选择返回\n\n    {\n        function f(){\n            return [1,2,3,4,5,]\n        }\n        let a,b,c;\n        [a,,,b]=f();\n        console.log(a,b); // 1 4\n    }\n\n4.函数平铺返回\n\n    {\n        function f(){\n            return [1,2,3,4,5,]\n        }\n        let a,b,c;\n        [a,...b]=f();\n        console.log(a,b); // 1 [2,3,4,5]\n    }\n\n5.对象解构赋值\n\n    {\n        let o={p:42,q:true};\n        let {p,q}=o;\n        console.log(p,q); // 42 true\n    }\n\n6,对象设置默认值\n\n    {\n        let {a=10,b=5}={a:3}\n        console.log(a,b); // 3 5\n    }\n\n### 解构赋值：模拟后台json数据\n\n    {\n        let metaData={\n            title:'abc',\n            test:[{\n                title:'test',\n                desc:'description'\n            }]\n        }\n        let {title:esTitle,test:[{title:cnTitle}]}=metaData;\n        console.log(esTitle,cnTitle);\n    }\n\n## Module模块化\n\n导出：\nexport xxx()\nexport default {\n    xxx,\n    zzz\n    yyy\n}\n\n引入：\nimport xxx from './路径'\n","slug":"ES6语法学习","published":1,"updated":"2019-06-16T08:31:22.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhe700009kud1cp6c2i6","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p>在代码中，如果使用了ES6语法，那么强制开启严格模式</p>\n<h2 id=\"let和const\"><a href=\"#let和const\" class=\"headerlink\" title=\"let和const\"></a>let和const</h2><ul>\n<li>let:使用let定义的变量，拥有块级作用域.</li>\n</ul>\n<p>注意：使用let定义变量，在同一块级作用域内，不能重复定义同一个名字。</p>\n<a id=\"more\"></a>\n<ul>\n<li>const:使用const定义的是常量，不可更改，且也拥有块级作用域。</li>\n</ul>\n<p>注意：const只能在定义赋值，因为它定义的是常量，不可更改。除非在定义时赋值的常量，是一个Object。因为Object是引用类型，赋值Object等于给const赋值了一个指针，指针不会变，Object改变不影响指向它的指针。</p>\n<h3 id=\"涉及的JS基础知识\"><a href=\"#涉及的JS基础知识\" class=\"headerlink\" title=\"涉及的JS基础知识\"></a>涉及的JS基础知识</h3><p>基本类型（私人空间）：每定义一个变量，就会在栈内存中开辟一个存放这个变量的空间。</p>\n<p>引用类型（公共空间）：如果有两个不同的变量指向同一个对象，则这个对象是唯一存在堆内存的。当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。</p>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p>示例：<br>数组解构赋值</p>\n<pre><code>{\n    let a,b;\n    [a,b]=[1,2];\n    console.log(a,b); // 1 2\n}\n</code></pre><p>赋值展开平铺语法：…变量</p>\n<pre><code>{\n    let a,b,rest;\n    [a,b,...rest]=[1,2,3,4,5,6];\n    console.log(a,b,rest); // 1 2 [3,4,5,6]\n}\n</code></pre><p>对象解构赋值：</p>\n<pre><code>{\n    let a,b;\n    ({a,b}={a:1,b:2})\n    console.log(a,b); // 1 2\n}\n</code></pre><p>如果解构赋值没有在结构上成功配对，则赋值对象为未定义,否则设定默认值</p>\n<pre><code>{\n    let a,b,c,rest;\n    [a,b,c=3]=[1,2]\n    console.log(a,b,c) //1 2 3\n}\n</code></pre><p>解构赋值的常用使用场景：<br>1.数值交换</p>\n<pre><code>{\n    let a=1;\n    let b=2;\n    [a,b]=[b,a];\n    console.log(a,b); // 2 1\n}\n</code></pre><p>2.函数返回</p>\n<pre><code>{\n    function f(){\n        return [1,2]\n    }\n    let a,b;\n    [a,b]=f();\n    console.log(a,b); // 1 2\n}\n</code></pre><p>3.函数选择返回</p>\n<pre><code>{\n    function f(){\n        return [1,2,3,4,5,]\n    }\n    let a,b,c;\n    [a,,,b]=f();\n    console.log(a,b); // 1 4\n}\n</code></pre><p>4.函数平铺返回</p>\n<pre><code>{\n    function f(){\n        return [1,2,3,4,5,]\n    }\n    let a,b,c;\n    [a,...b]=f();\n    console.log(a,b); // 1 [2,3,4,5]\n}\n</code></pre><p>5.对象解构赋值</p>\n<pre><code>{\n    let o={p:42,q:true};\n    let {p,q}=o;\n    console.log(p,q); // 42 true\n}\n</code></pre><p>6,对象设置默认值</p>\n<pre><code>{\n    let {a=10,b=5}={a:3}\n    console.log(a,b); // 3 5\n}\n</code></pre><h3 id=\"解构赋值：模拟后台json数据\"><a href=\"#解构赋值：模拟后台json数据\" class=\"headerlink\" title=\"解构赋值：模拟后台json数据\"></a>解构赋值：模拟后台json数据</h3><pre><code>{\n    let metaData={\n        title:&apos;abc&apos;,\n        test:[{\n            title:&apos;test&apos;,\n            desc:&apos;description&apos;\n        }]\n    }\n    let {title:esTitle,test:[{title:cnTitle}]}=metaData;\n    console.log(esTitle,cnTitle);\n}\n</code></pre><h2 id=\"Module模块化\"><a href=\"#Module模块化\" class=\"headerlink\" title=\"Module模块化\"></a>Module模块化</h2><p>导出：<br>export xxx()<br>export default {<br>    xxx,<br>    zzz<br>    yyy<br>}</p>\n<p>引入：<br>import xxx from ‘./路径’</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h1><p>在代码中，如果使用了ES6语法，那么强制开启严格模式</p>\n<h2 id=\"let和const\"><a href=\"#let和const\" class=\"headerlink\" title=\"let和const\"></a>let和const</h2><ul>\n<li>let:使用let定义的变量，拥有块级作用域.</li>\n</ul>\n<p>注意：使用let定义变量，在同一块级作用域内，不能重复定义同一个名字。</p>","more":"<ul>\n<li>const:使用const定义的是常量，不可更改，且也拥有块级作用域。</li>\n</ul>\n<p>注意：const只能在定义赋值，因为它定义的是常量，不可更改。除非在定义时赋值的常量，是一个Object。因为Object是引用类型，赋值Object等于给const赋值了一个指针，指针不会变，Object改变不影响指向它的指针。</p>\n<h3 id=\"涉及的JS基础知识\"><a href=\"#涉及的JS基础知识\" class=\"headerlink\" title=\"涉及的JS基础知识\"></a>涉及的JS基础知识</h3><p>基本类型（私人空间）：每定义一个变量，就会在栈内存中开辟一个存放这个变量的空间。</p>\n<p>引用类型（公共空间）：如果有两个不同的变量指向同一个对象，则这个对象是唯一存在堆内存的。当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。</p>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p>示例：<br>数组解构赋值</p>\n<pre><code>{\n    let a,b;\n    [a,b]=[1,2];\n    console.log(a,b); // 1 2\n}\n</code></pre><p>赋值展开平铺语法：…变量</p>\n<pre><code>{\n    let a,b,rest;\n    [a,b,...rest]=[1,2,3,4,5,6];\n    console.log(a,b,rest); // 1 2 [3,4,5,6]\n}\n</code></pre><p>对象解构赋值：</p>\n<pre><code>{\n    let a,b;\n    ({a,b}={a:1,b:2})\n    console.log(a,b); // 1 2\n}\n</code></pre><p>如果解构赋值没有在结构上成功配对，则赋值对象为未定义,否则设定默认值</p>\n<pre><code>{\n    let a,b,c,rest;\n    [a,b,c=3]=[1,2]\n    console.log(a,b,c) //1 2 3\n}\n</code></pre><p>解构赋值的常用使用场景：<br>1.数值交换</p>\n<pre><code>{\n    let a=1;\n    let b=2;\n    [a,b]=[b,a];\n    console.log(a,b); // 2 1\n}\n</code></pre><p>2.函数返回</p>\n<pre><code>{\n    function f(){\n        return [1,2]\n    }\n    let a,b;\n    [a,b]=f();\n    console.log(a,b); // 1 2\n}\n</code></pre><p>3.函数选择返回</p>\n<pre><code>{\n    function f(){\n        return [1,2,3,4,5,]\n    }\n    let a,b,c;\n    [a,,,b]=f();\n    console.log(a,b); // 1 4\n}\n</code></pre><p>4.函数平铺返回</p>\n<pre><code>{\n    function f(){\n        return [1,2,3,4,5,]\n    }\n    let a,b,c;\n    [a,...b]=f();\n    console.log(a,b); // 1 [2,3,4,5]\n}\n</code></pre><p>5.对象解构赋值</p>\n<pre><code>{\n    let o={p:42,q:true};\n    let {p,q}=o;\n    console.log(p,q); // 42 true\n}\n</code></pre><p>6,对象设置默认值</p>\n<pre><code>{\n    let {a=10,b=5}={a:3}\n    console.log(a,b); // 3 5\n}\n</code></pre><h3 id=\"解构赋值：模拟后台json数据\"><a href=\"#解构赋值：模拟后台json数据\" class=\"headerlink\" title=\"解构赋值：模拟后台json数据\"></a>解构赋值：模拟后台json数据</h3><pre><code>{\n    let metaData={\n        title:&apos;abc&apos;,\n        test:[{\n            title:&apos;test&apos;,\n            desc:&apos;description&apos;\n        }]\n    }\n    let {title:esTitle,test:[{title:cnTitle}]}=metaData;\n    console.log(esTitle,cnTitle);\n}\n</code></pre><h2 id=\"Module模块化\"><a href=\"#Module模块化\" class=\"headerlink\" title=\"Module模块化\"></a>Module模块化</h2><p>导出：<br>export xxx()<br>export default {<br>    xxx,<br>    zzz<br>    yyy<br>}</p>\n<p>引入：<br>import xxx from ‘./路径’</p>"},{"title":"CSSOM视图模式","date":"2018-05-02T05:26:18.000Z","_content":"\n# CSSOM视图模块(CSSOM View Module)\n\n它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性\n\n包括布局框定位、视区宽度和元素滚动。\n\n以下就是一些API属性的相关内容，包括兼容性，使用，测试等。\n\n<!--more-->\n\n## window视图属性（几乎没用）\n\n这些属性可以hold住整个浏览器窗体大小。微软则将这些API称为“Screenview 接口”。\n\n>语法：window.xxxxx\n\n它们一般没什么用，仅作了解：\n- innerWidth 属性和 innerHeight 属性\n    - 表示获取window窗体的内部宽高，不包括用户界面元素，比如窗框。\n- pageXOffset 属性和 pageYOffset 属性\n    - 表示整个浏览器窗体的大小，包括任务栏等。\n- screenX 属性和 screenY 属性\n    - 表示整个页面滚动的像素值（水平方向的和垂直方向的）\n- outerWidth 属性和 outerHeight 属性\n    - 浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。\n\n## Screen视图属性（几乎没用）\n\n>语法：screen.xxxxx\n\n- availWidth和availHeight\n    - 显示器可用宽高，不包括任务栏之类的东东。\n- width和height\n    - 表示显示器屏幕的宽高。\n\n## 元素视图属性 (重点)\n\n使用方法，自己获取页面元素，然后对元素应用方法。\n\n- clientLeft和clientTop（事件内容的位置）\n    - 表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。\n\n\n- clientWidth和clientHeight（事件内容的大小）\n    - 表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。\n\n- offsetLeft和offsetTop（检测位置）\n    - 表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。\n\n\n- offsetWidth和offsetHeight（检测大小）\n    - 整个元素的尺寸（包括边框）。\n\n- scrollLeft和scrollTop（用于滚动）\n    - 表示元素滚动的像素大小。可读可写。\n\n- scrollWidth和scrollHeight（整个内容的宽高-包括滚动）\n    - 表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。\n\n\n## 鼠标位置 （重要）\n\n>语法：event.clientX\n\n- clientX,clientY\n    - 相对于window，为鼠标相对于window的偏移。\n\n>用于点击移动\n\n- offsetX, offsetY\n    - 表示鼠标相对于当前被点击元素padding box的左上偏移值，各个浏览器的兼容性五花八门.\n\n>获取鼠标在元素内的位置\n\n- pageX, pageY（兼容性不好）\n    - 为鼠标相对于document的坐标。\n\n- screenX, screenY\n    - 鼠标相对于显示器屏幕的偏移坐标。\n\n#### clientXY+offsetXY组合用法\n\n>clienX-offsetX = 元素不超出页面\n\n因为window宽度就是浏览器宽度。\n","source":"_posts/CSSOM视图模式.md","raw":"---\ntitle: CSSOM视图模式\ndate: 2018-05-02 13:26:18\ncategories:\n  - JS学习笔记\ntags:\n  - 浏览器视图属性\n  - 页面内元素移动和滚动\n---\n\n# CSSOM视图模块(CSSOM View Module)\n\n它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性\n\n包括布局框定位、视区宽度和元素滚动。\n\n以下就是一些API属性的相关内容，包括兼容性，使用，测试等。\n\n<!--more-->\n\n## window视图属性（几乎没用）\n\n这些属性可以hold住整个浏览器窗体大小。微软则将这些API称为“Screenview 接口”。\n\n>语法：window.xxxxx\n\n它们一般没什么用，仅作了解：\n- innerWidth 属性和 innerHeight 属性\n    - 表示获取window窗体的内部宽高，不包括用户界面元素，比如窗框。\n- pageXOffset 属性和 pageYOffset 属性\n    - 表示整个浏览器窗体的大小，包括任务栏等。\n- screenX 属性和 screenY 属性\n    - 表示整个页面滚动的像素值（水平方向的和垂直方向的）\n- outerWidth 属性和 outerHeight 属性\n    - 浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。\n\n## Screen视图属性（几乎没用）\n\n>语法：screen.xxxxx\n\n- availWidth和availHeight\n    - 显示器可用宽高，不包括任务栏之类的东东。\n- width和height\n    - 表示显示器屏幕的宽高。\n\n## 元素视图属性 (重点)\n\n使用方法，自己获取页面元素，然后对元素应用方法。\n\n- clientLeft和clientTop（事件内容的位置）\n    - 表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。\n\n\n- clientWidth和clientHeight（事件内容的大小）\n    - 表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。\n\n- offsetLeft和offsetTop（检测位置）\n    - 表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。\n\n\n- offsetWidth和offsetHeight（检测大小）\n    - 整个元素的尺寸（包括边框）。\n\n- scrollLeft和scrollTop（用于滚动）\n    - 表示元素滚动的像素大小。可读可写。\n\n- scrollWidth和scrollHeight（整个内容的宽高-包括滚动）\n    - 表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。\n\n\n## 鼠标位置 （重要）\n\n>语法：event.clientX\n\n- clientX,clientY\n    - 相对于window，为鼠标相对于window的偏移。\n\n>用于点击移动\n\n- offsetX, offsetY\n    - 表示鼠标相对于当前被点击元素padding box的左上偏移值，各个浏览器的兼容性五花八门.\n\n>获取鼠标在元素内的位置\n\n- pageX, pageY（兼容性不好）\n    - 为鼠标相对于document的坐标。\n\n- screenX, screenY\n    - 鼠标相对于显示器屏幕的偏移坐标。\n\n#### clientXY+offsetXY组合用法\n\n>clienX-offsetX = 元素不超出页面\n\n因为window宽度就是浏览器宽度。\n","slug":"CSSOM视图模式","published":1,"updated":"2019-04-07T14:56:53.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhef00029kud66ckbwtj","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"CSSOM视图模块-CSSOM-View-Module\"><a href=\"#CSSOM视图模块-CSSOM-View-Module\" class=\"headerlink\" title=\"CSSOM视图模块(CSSOM View Module)\"></a>CSSOM视图模块(CSSOM View Module)</h1><p>它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性</p>\n<p>包括布局框定位、视区宽度和元素滚动。</p>\n<p>以下就是一些API属性的相关内容，包括兼容性，使用，测试等。</p>\n<a id=\"more\"></a>\n<h2 id=\"window视图属性（几乎没用）\"><a href=\"#window视图属性（几乎没用）\" class=\"headerlink\" title=\"window视图属性（几乎没用）\"></a>window视图属性（几乎没用）</h2><p>这些属性可以hold住整个浏览器窗体大小。微软则将这些API称为“Screenview 接口”。</p>\n<blockquote>\n<p>语法：window.xxxxx</p>\n</blockquote>\n<p>它们一般没什么用，仅作了解：</p>\n<ul>\n<li>innerWidth 属性和 innerHeight 属性<ul>\n<li>表示获取window窗体的内部宽高，不包括用户界面元素，比如窗框。</li>\n</ul>\n</li>\n<li>pageXOffset 属性和 pageYOffset 属性<ul>\n<li>表示整个浏览器窗体的大小，包括任务栏等。</li>\n</ul>\n</li>\n<li>screenX 属性和 screenY 属性<ul>\n<li>表示整个页面滚动的像素值（水平方向的和垂直方向的）</li>\n</ul>\n</li>\n<li>outerWidth 属性和 outerHeight 属性<ul>\n<li>浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Screen视图属性（几乎没用）\"><a href=\"#Screen视图属性（几乎没用）\" class=\"headerlink\" title=\"Screen视图属性（几乎没用）\"></a>Screen视图属性（几乎没用）</h2><blockquote>\n<p>语法：screen.xxxxx</p>\n</blockquote>\n<ul>\n<li>availWidth和availHeight<ul>\n<li>显示器可用宽高，不包括任务栏之类的东东。</li>\n</ul>\n</li>\n<li>width和height<ul>\n<li>表示显示器屏幕的宽高。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"元素视图属性-重点\"><a href=\"#元素视图属性-重点\" class=\"headerlink\" title=\"元素视图属性 (重点)\"></a>元素视图属性 (重点)</h2><p>使用方法，自己获取页面元素，然后对元素应用方法。</p>\n<ul>\n<li>clientLeft和clientTop（事件内容的位置）<ul>\n<li>表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>clientWidth和clientHeight（事件内容的大小）</p>\n<ul>\n<li>表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。</li>\n</ul>\n</li>\n<li><p>offsetLeft和offsetTop（检测位置）</p>\n<ul>\n<li>表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>offsetWidth和offsetHeight（检测大小）</p>\n<ul>\n<li>整个元素的尺寸（包括边框）。</li>\n</ul>\n</li>\n<li><p>scrollLeft和scrollTop（用于滚动）</p>\n<ul>\n<li>表示元素滚动的像素大小。可读可写。</li>\n</ul>\n</li>\n<li><p>scrollWidth和scrollHeight（整个内容的宽高-包括滚动）</p>\n<ul>\n<li>表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"鼠标位置-（重要）\"><a href=\"#鼠标位置-（重要）\" class=\"headerlink\" title=\"鼠标位置 （重要）\"></a>鼠标位置 （重要）</h2><blockquote>\n<p>语法：event.clientX</p>\n</blockquote>\n<ul>\n<li>clientX,clientY<ul>\n<li>相对于window，为鼠标相对于window的偏移。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>用于点击移动</p>\n</blockquote>\n<ul>\n<li>offsetX, offsetY<ul>\n<li>表示鼠标相对于当前被点击元素padding box的左上偏移值，各个浏览器的兼容性五花八门.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>获取鼠标在元素内的位置</p>\n</blockquote>\n<ul>\n<li><p>pageX, pageY（兼容性不好）</p>\n<ul>\n<li>为鼠标相对于document的坐标。</li>\n</ul>\n</li>\n<li><p>screenX, screenY</p>\n<ul>\n<li>鼠标相对于显示器屏幕的偏移坐标。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"clientXY-offsetXY组合用法\"><a href=\"#clientXY-offsetXY组合用法\" class=\"headerlink\" title=\"clientXY+offsetXY组合用法\"></a>clientXY+offsetXY组合用法</h4><blockquote>\n<p>clienX-offsetX = 元素不超出页面</p>\n</blockquote>\n<p>因为window宽度就是浏览器宽度。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"CSSOM视图模块-CSSOM-View-Module\"><a href=\"#CSSOM视图模块-CSSOM-View-Module\" class=\"headerlink\" title=\"CSSOM视图模块(CSSOM View Module)\"></a>CSSOM视图模块(CSSOM View Module)</h1><p>它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性</p>\n<p>包括布局框定位、视区宽度和元素滚动。</p>\n<p>以下就是一些API属性的相关内容，包括兼容性，使用，测试等。</p>","more":"<h2 id=\"window视图属性（几乎没用）\"><a href=\"#window视图属性（几乎没用）\" class=\"headerlink\" title=\"window视图属性（几乎没用）\"></a>window视图属性（几乎没用）</h2><p>这些属性可以hold住整个浏览器窗体大小。微软则将这些API称为“Screenview 接口”。</p>\n<blockquote>\n<p>语法：window.xxxxx</p>\n</blockquote>\n<p>它们一般没什么用，仅作了解：</p>\n<ul>\n<li>innerWidth 属性和 innerHeight 属性<ul>\n<li>表示获取window窗体的内部宽高，不包括用户界面元素，比如窗框。</li>\n</ul>\n</li>\n<li>pageXOffset 属性和 pageYOffset 属性<ul>\n<li>表示整个浏览器窗体的大小，包括任务栏等。</li>\n</ul>\n</li>\n<li>screenX 属性和 screenY 属性<ul>\n<li>表示整个页面滚动的像素值（水平方向的和垂直方向的）</li>\n</ul>\n</li>\n<li>outerWidth 属性和 outerHeight 属性<ul>\n<li>浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Screen视图属性（几乎没用）\"><a href=\"#Screen视图属性（几乎没用）\" class=\"headerlink\" title=\"Screen视图属性（几乎没用）\"></a>Screen视图属性（几乎没用）</h2><blockquote>\n<p>语法：screen.xxxxx</p>\n</blockquote>\n<ul>\n<li>availWidth和availHeight<ul>\n<li>显示器可用宽高，不包括任务栏之类的东东。</li>\n</ul>\n</li>\n<li>width和height<ul>\n<li>表示显示器屏幕的宽高。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"元素视图属性-重点\"><a href=\"#元素视图属性-重点\" class=\"headerlink\" title=\"元素视图属性 (重点)\"></a>元素视图属性 (重点)</h2><p>使用方法，自己获取页面元素，然后对元素应用方法。</p>\n<ul>\n<li>clientLeft和clientTop（事件内容的位置）<ul>\n<li>表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>clientWidth和clientHeight（事件内容的大小）</p>\n<ul>\n<li>表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。</li>\n</ul>\n</li>\n<li><p>offsetLeft和offsetTop（检测位置）</p>\n<ul>\n<li>表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>offsetWidth和offsetHeight（检测大小）</p>\n<ul>\n<li>整个元素的尺寸（包括边框）。</li>\n</ul>\n</li>\n<li><p>scrollLeft和scrollTop（用于滚动）</p>\n<ul>\n<li>表示元素滚动的像素大小。可读可写。</li>\n</ul>\n</li>\n<li><p>scrollWidth和scrollHeight（整个内容的宽高-包括滚动）</p>\n<ul>\n<li>表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"鼠标位置-（重要）\"><a href=\"#鼠标位置-（重要）\" class=\"headerlink\" title=\"鼠标位置 （重要）\"></a>鼠标位置 （重要）</h2><blockquote>\n<p>语法：event.clientX</p>\n</blockquote>\n<ul>\n<li>clientX,clientY<ul>\n<li>相对于window，为鼠标相对于window的偏移。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>用于点击移动</p>\n</blockquote>\n<ul>\n<li>offsetX, offsetY<ul>\n<li>表示鼠标相对于当前被点击元素padding box的左上偏移值，各个浏览器的兼容性五花八门.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>获取鼠标在元素内的位置</p>\n</blockquote>\n<ul>\n<li><p>pageX, pageY（兼容性不好）</p>\n<ul>\n<li>为鼠标相对于document的坐标。</li>\n</ul>\n</li>\n<li><p>screenX, screenY</p>\n<ul>\n<li>鼠标相对于显示器屏幕的偏移坐标。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"clientXY-offsetXY组合用法\"><a href=\"#clientXY-offsetXY组合用法\" class=\"headerlink\" title=\"clientXY+offsetXY组合用法\"></a>clientXY+offsetXY组合用法</h4><blockquote>\n<p>clienX-offsetX = 元素不超出页面</p>\n</blockquote>\n<p>因为window宽度就是浏览器宽度。</p>"},{"title":"css布局思路","date":"2018-04-02T15:39:58.000Z","_content":"\n使用三段论推理：三段论包括大前提、小前提、结论三个部分。\n所谓CSS布局：布局是大前提，html是小前提。\n良好的布局思路，决定了代码的优雅。\n\n<!-- more -->\n\n①我要用什么布局\n②DOM结构用什么标签\n③结构的主体是什么\n\n看似简单，是逻辑推理中的基础【三点式推理】。\n但是一定要想清楚！\n严格遵循这个顺序！\n\n\n只有一开始便理清思路，并且不断累积这样的判断经验，才能提高开发效率与正确的直觉！\n","source":"_posts/css布局思路.md","raw":"---\ntitle: css布局思路\ndate: 2018-04-2 23:39:58\ncategories: css学习笔记\ntags:\n  - CSS\n---\n\n使用三段论推理：三段论包括大前提、小前提、结论三个部分。\n所谓CSS布局：布局是大前提，html是小前提。\n良好的布局思路，决定了代码的优雅。\n\n<!-- more -->\n\n①我要用什么布局\n②DOM结构用什么标签\n③结构的主体是什么\n\n看似简单，是逻辑推理中的基础【三点式推理】。\n但是一定要想清楚！\n严格遵循这个顺序！\n\n\n只有一开始便理清思路，并且不断累积这样的判断经验，才能提高开发效率与正确的直觉！\n","slug":"css布局思路","published":1,"updated":"2019-04-07T14:56:53.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhem00069kudu9ek8c55","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>使用三段论推理：三段论包括大前提、小前提、结论三个部分。<br>所谓CSS布局：布局是大前提，html是小前提。<br>良好的布局思路，决定了代码的优雅。</p>\n<a id=\"more\"></a>\n<p>①我要用什么布局<br>②DOM结构用什么标签<br>③结构的主体是什么</p>\n<p>看似简单，是逻辑推理中的基础【三点式推理】。<br>但是一定要想清楚！<br>严格遵循这个顺序！</p>\n<p>只有一开始便理清思路，并且不断累积这样的判断经验，才能提高开发效率与正确的直觉！</p>\n","site":{"data":{}},"excerpt":"<p>使用三段论推理：三段论包括大前提、小前提、结论三个部分。<br>所谓CSS布局：布局是大前提，html是小前提。<br>良好的布局思路，决定了代码的优雅。</p>","more":"<p>①我要用什么布局<br>②DOM结构用什么标签<br>③结构的主体是什么</p>\n<p>看似简单，是逻辑推理中的基础【三点式推理】。<br>但是一定要想清楚！<br>严格遵循这个顺序！</p>\n<p>只有一开始便理清思路，并且不断累积这样的判断经验，才能提高开发效率与正确的直觉！</p>"},{"title":"ajax学习","date":"2018-05-01T06:46:04.000Z","_content":"\n[toc]\n\n# ajax\n \n\n## XMLHttpRequest 是 AJAX 的基础。\n\n- XMLHttpRequest 对象\n\nXMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。\n它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。\n这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。\n\n>通过它，你可以很容易的取回一个 URL 上的资源数据。\n\n尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。\n而且除了 HTTP ，它还支持 file 和 ftp 协议。\n<!-- more -->\n\n## 构造函数 XMLHttpRequest()\n\n构造函数初始化一个 XMLHttpRequest 对象。必须在所有其他方法被调用前调用构造函数。\n\n语法：\n>var myRequest = new XMLHttpRequest();\n\n此时 myRequest 已经成为一个XMLHttpRequest 对象，可以使用XMLHttpRequest的方法。\n\n\n## 向服务器发送请求\n如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：\n```\nxmlhttp.open(\"GET\",url,true);\nxmlhttp.send(null);\n```\n\n- open(method,url,async) // \t\n规定请求的类型、URL 以及是否异步处理请求。\n    - method：请求的类型；GET 或 POST\n    - url：文件在服务器上的位置\n    - async：true（异步）或 false（同步）\n\n- send(string) // 将请求发送到服务器。\n    - string：仅用于 POST 请求（如果不需要发送请求，则必须传入Null）\n\n## GET请求\n\n如果您希望通过 GET 方法发送信息，请向 URL 添加信息（在地址后面加问号，然后再添加）：\n```\nxmlhttp.open(\"GET\",\"/try/ajax/demo_get2.php?fname=Henry&lname=Ford\",true);\nxmlhttp.send();\n```\n\n## POST请求\n\n如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。\n然后在 send() 方法中规定您希望发送的数据：\n```\nxmlhttp.open(\"POST\",\"/try/ajax/demo_post2.php\",true);\nxmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\nxmlhttp.send(\"fname=Henry&lname=Ford\");\n```\n方法:\n>setRequestHeader(header,value)\n\n- 向请求添加 HTTP 头。\n    - header: 规定头的名称\n    - value: 规定头的值\n\n## 我们使用 GET 还是 POST？\n\nGET 更简单也更快，并且在大部分情况下都能用。\n然而，在以下情况中，请使用 POST 请求：\n- 无法使用缓存文件（更新服务器上的文件或数据库）\n- 向服务器发送大量数据（POST 没有数据量限制）\n- 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n\n## 异步如何设置 - True 或 False？\n\nAJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。\nXMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true。\n\n通过 AJAX，JavaScript 无需等待服务器的响应，而是：\n- 在等待服务器响应时执行其他脚本\n- 当响应就绪后对响应进行处理\n\n## 接收响应\n\n一个完整的http响应是由状态码，响应头集合，和响应主题组成。\n在收到响应的消息后，这些都是可以通过xhr对象的属性和方法所使用。\n它们主要有以下4个属性\n\n```\nresponseText;作为相应主题返回的文本，（文本形式）\nresponseXML;如果响应的内容是‘text/xml’或者是哦application/xml;属性中将会保存，响应数据的xml形式。DOM文档形式。\n\nstatus: http的状态码（数字形式）\nstatusText;http状态说明，（文本形式）\n```\n\n## ajax原生\n\n```\n//**********第一步, 获得一个xhr对象*************\n\n       var xmlHttpReq = null;// 声明一个空对象用来装入XMLHttpRequest\n\n       if (window.XMLHttpRequest){// ie7 以上的浏览器XMLHttpRequest是window的子对象\n\n              xmlHttpReq = new XMLHttpRequest();// 实例化一个XMLHttpRequest\n\n       }else (window.ActiveXObject){// IE5 IE6是以ActiveXObject的方式引入XMLHttpRequest的\n\n              xmlHttpReq = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\n       }\n\n       if(xhr != null){  // 如果对象实例化成功\n              //设置回调函数\n              xhr.onreadystatechange = function(){\n\n                  if(xhr.readyState == 4){  // 确定响应已经成功返回\n                       // 200可作为成功标志, 304表示请求资源没有修改, 可直接使用浏览器缓存\n                       if ((xhr.status>=200 && xhr.status < 300 ) || xhr.status == 304){\n                             alert(xhr.responseText); // 请求成功，服务器返回的数据\n                        } else {\n                             alert( \"请求失败: \" + xhr.status);\n                        }\n                    }\n              }\n\n//************第二步: 启动请求.******************\n              // open方法接收三个参数: 要发送的请求类型(get,post等), 请求的url和是否异步发送请求的布尔值\n              xhr.open(\"get\",\"test.php\",true);\n              // 调用open()方法并采用异步方式. 如果第三个参数是false, 同步执行, 则js代码会等到服务器响应之后再继续执行\n\n//*************第三步: 发送数据*******************\n              // send方法接收一个参数,即要作为请求主体发送的数据. 如果不需要通过请求主体发送数据, 则必须传入null. 因为这个参数对有些浏览器是必须的\n              xhr.send(null);\n              // 因为使用get方式提交，所以可以使用null参调用\n\n// 如果要设置请求头部信息,必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()\n```\n- readyStatus的五个阶段\n    - 0：未初始化。尚未调用open()方法\n    - 1：启动。已经调用open()方法，尚未调用send()方法\n    - 2：发送。已经调用send()方法，尚未接收到响应\n    - 3：接收。已经接收部分响应数据。\n    - 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。【一般只需检查这个阶段】\n- 获得的数据在responseText或responseXML属性中, 后者需要XML解析\n\n## ajax跨域\n\n三种跨域方法：\n一、一般使用封装好的jsonp\n\njsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。\n普通方法: 给html标签添加脚本属性\n```\nfunction addScriptTag(src) {\n  // 创建script元素标签，设置其属性\n  var script = document.createElement('script');\n  script.setAttribute(\"type\",\"text/javascript\");\n  // 给script标签，设置标签属性\n  script.src = src;\n  // 把script标签添加成为body的子标签\n  document.body.appendChild(script);\n}\n// 提供jsonp服务的url地址，并调用foo函数\nwindow.onload = function () {\n  addScriptTag('http://example.com/ip?callback=foo');\n}\n\nfunction foo(data) {\n  console.log('Your public IP address is: ' + data.ip);\n};\n```\n\njqurey方法：\n```\n $.ajax({\n    url: \"url\",\n    type: \"GET\",\n    dataType: \"jsonp\",  //指定服务器返回的数据类型\n    jsonp: \"cb\",   //指定参数名称\n    jsonpCallback: \"showData\",  //指定回调函数名称\n    success: function (data) {\n        console.log(\"调用success\");\n    }\n});\n```\n\n二、CORS是跨源资源分享（在后端设置头部支持，允许跨域）\n- Access-Control-Allow-Origin:*\n\n三、设置代理请求（不会）\n\n# vue使用Ajax\n\n本身不支持发送AJAX请求，需要使用vue-resource、axios等插件实现\n\n## axios使用Ajax\n\n注意：axios不支持跨域\n\n参考github上的官方文档，[options]是可以使用的方法\n```\naxios([options])  \naxios.get(url[,options]);\n    传参方式：\n        1.通过url传参\n        2.通过params选项传参\naxios.post(url,data,[options]);\n    axios默认发送数据时，数据格式是Request Payload，并非我们常用的Form Data格式，\n    所以参数必须要以键值对形式传递，不能以json形式传参\n    传参方式：\n        1.自己拼接为键值对\n        2.使用transformRequest，在请求发送前将请求数据进行转换\n        3.如果使用模块化开发，可以使用qs模块进行转换\n\naxios本身并不支持发送跨域的请求，没有提供相应的API，作者也暂没计划在axios添加支持发送跨域请求，所以只能使用第三方库\n```\nget请求示例\n```\n写法一（只能用这个，参考上面的传参方式）\naxios.get('/user?ID=12345')\n  .then(function (response) {// 成功\n    console.log(response);\n  })\n  .catch(function (error) {// 失败\n    console.log(error);\n  });\n\n写法二\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n\n## 使用vue-resource发送跨域请求\n\n基本用法\n```\n使用this.$http发送请求  \n    this.$http.get(url, [options])\n    this.$http.head(url, [options])\n    this.$http.delete(url, [options])\n    this.$http.jsonp(url, [options])\n    this.$http.post(url, [body], [options])\n    this.$http.put(url, [body], [options])\n    this.$http.patch(url, [body], [options])\n```\n\n```\nthis.$http.jsonp('https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',{\n\t\t\t\tparams:{\n\t\t\t\t\twd:this.keyword\n\t\t\t\t},\n\t\t\t\tjsonp:'cb'\n\t\t\t}).then(resp => {\n\t\tthis.myData=resp.data.s;\n\t});\n```","source":"_posts/ajax学习.md","raw":"---\ntitle: ajax学习\ndate: 2018-05-01 14:46:04\ncategories:\n  - JS学习笔记 vue学习\ntags:\n  - ajax 网络请求 js\n---\n\n[toc]\n\n# ajax\n \n\n## XMLHttpRequest 是 AJAX 的基础。\n\n- XMLHttpRequest 对象\n\nXMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。\n它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。\n这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。\n\n>通过它，你可以很容易的取回一个 URL 上的资源数据。\n\n尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。\n而且除了 HTTP ，它还支持 file 和 ftp 协议。\n<!-- more -->\n\n## 构造函数 XMLHttpRequest()\n\n构造函数初始化一个 XMLHttpRequest 对象。必须在所有其他方法被调用前调用构造函数。\n\n语法：\n>var myRequest = new XMLHttpRequest();\n\n此时 myRequest 已经成为一个XMLHttpRequest 对象，可以使用XMLHttpRequest的方法。\n\n\n## 向服务器发送请求\n如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：\n```\nxmlhttp.open(\"GET\",url,true);\nxmlhttp.send(null);\n```\n\n- open(method,url,async) // \t\n规定请求的类型、URL 以及是否异步处理请求。\n    - method：请求的类型；GET 或 POST\n    - url：文件在服务器上的位置\n    - async：true（异步）或 false（同步）\n\n- send(string) // 将请求发送到服务器。\n    - string：仅用于 POST 请求（如果不需要发送请求，则必须传入Null）\n\n## GET请求\n\n如果您希望通过 GET 方法发送信息，请向 URL 添加信息（在地址后面加问号，然后再添加）：\n```\nxmlhttp.open(\"GET\",\"/try/ajax/demo_get2.php?fname=Henry&lname=Ford\",true);\nxmlhttp.send();\n```\n\n## POST请求\n\n如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。\n然后在 send() 方法中规定您希望发送的数据：\n```\nxmlhttp.open(\"POST\",\"/try/ajax/demo_post2.php\",true);\nxmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\nxmlhttp.send(\"fname=Henry&lname=Ford\");\n```\n方法:\n>setRequestHeader(header,value)\n\n- 向请求添加 HTTP 头。\n    - header: 规定头的名称\n    - value: 规定头的值\n\n## 我们使用 GET 还是 POST？\n\nGET 更简单也更快，并且在大部分情况下都能用。\n然而，在以下情况中，请使用 POST 请求：\n- 无法使用缓存文件（更新服务器上的文件或数据库）\n- 向服务器发送大量数据（POST 没有数据量限制）\n- 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠\n\n## 异步如何设置 - True 或 False？\n\nAJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。\nXMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true。\n\n通过 AJAX，JavaScript 无需等待服务器的响应，而是：\n- 在等待服务器响应时执行其他脚本\n- 当响应就绪后对响应进行处理\n\n## 接收响应\n\n一个完整的http响应是由状态码，响应头集合，和响应主题组成。\n在收到响应的消息后，这些都是可以通过xhr对象的属性和方法所使用。\n它们主要有以下4个属性\n\n```\nresponseText;作为相应主题返回的文本，（文本形式）\nresponseXML;如果响应的内容是‘text/xml’或者是哦application/xml;属性中将会保存，响应数据的xml形式。DOM文档形式。\n\nstatus: http的状态码（数字形式）\nstatusText;http状态说明，（文本形式）\n```\n\n## ajax原生\n\n```\n//**********第一步, 获得一个xhr对象*************\n\n       var xmlHttpReq = null;// 声明一个空对象用来装入XMLHttpRequest\n\n       if (window.XMLHttpRequest){// ie7 以上的浏览器XMLHttpRequest是window的子对象\n\n              xmlHttpReq = new XMLHttpRequest();// 实例化一个XMLHttpRequest\n\n       }else (window.ActiveXObject){// IE5 IE6是以ActiveXObject的方式引入XMLHttpRequest的\n\n              xmlHttpReq = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\n       }\n\n       if(xhr != null){  // 如果对象实例化成功\n              //设置回调函数\n              xhr.onreadystatechange = function(){\n\n                  if(xhr.readyState == 4){  // 确定响应已经成功返回\n                       // 200可作为成功标志, 304表示请求资源没有修改, 可直接使用浏览器缓存\n                       if ((xhr.status>=200 && xhr.status < 300 ) || xhr.status == 304){\n                             alert(xhr.responseText); // 请求成功，服务器返回的数据\n                        } else {\n                             alert( \"请求失败: \" + xhr.status);\n                        }\n                    }\n              }\n\n//************第二步: 启动请求.******************\n              // open方法接收三个参数: 要发送的请求类型(get,post等), 请求的url和是否异步发送请求的布尔值\n              xhr.open(\"get\",\"test.php\",true);\n              // 调用open()方法并采用异步方式. 如果第三个参数是false, 同步执行, 则js代码会等到服务器响应之后再继续执行\n\n//*************第三步: 发送数据*******************\n              // send方法接收一个参数,即要作为请求主体发送的数据. 如果不需要通过请求主体发送数据, 则必须传入null. 因为这个参数对有些浏览器是必须的\n              xhr.send(null);\n              // 因为使用get方式提交，所以可以使用null参调用\n\n// 如果要设置请求头部信息,必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()\n```\n- readyStatus的五个阶段\n    - 0：未初始化。尚未调用open()方法\n    - 1：启动。已经调用open()方法，尚未调用send()方法\n    - 2：发送。已经调用send()方法，尚未接收到响应\n    - 3：接收。已经接收部分响应数据。\n    - 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。【一般只需检查这个阶段】\n- 获得的数据在responseText或responseXML属性中, 后者需要XML解析\n\n## ajax跨域\n\n三种跨域方法：\n一、一般使用封装好的jsonp\n\njsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。\n普通方法: 给html标签添加脚本属性\n```\nfunction addScriptTag(src) {\n  // 创建script元素标签，设置其属性\n  var script = document.createElement('script');\n  script.setAttribute(\"type\",\"text/javascript\");\n  // 给script标签，设置标签属性\n  script.src = src;\n  // 把script标签添加成为body的子标签\n  document.body.appendChild(script);\n}\n// 提供jsonp服务的url地址，并调用foo函数\nwindow.onload = function () {\n  addScriptTag('http://example.com/ip?callback=foo');\n}\n\nfunction foo(data) {\n  console.log('Your public IP address is: ' + data.ip);\n};\n```\n\njqurey方法：\n```\n $.ajax({\n    url: \"url\",\n    type: \"GET\",\n    dataType: \"jsonp\",  //指定服务器返回的数据类型\n    jsonp: \"cb\",   //指定参数名称\n    jsonpCallback: \"showData\",  //指定回调函数名称\n    success: function (data) {\n        console.log(\"调用success\");\n    }\n});\n```\n\n二、CORS是跨源资源分享（在后端设置头部支持，允许跨域）\n- Access-Control-Allow-Origin:*\n\n三、设置代理请求（不会）\n\n# vue使用Ajax\n\n本身不支持发送AJAX请求，需要使用vue-resource、axios等插件实现\n\n## axios使用Ajax\n\n注意：axios不支持跨域\n\n参考github上的官方文档，[options]是可以使用的方法\n```\naxios([options])  \naxios.get(url[,options]);\n    传参方式：\n        1.通过url传参\n        2.通过params选项传参\naxios.post(url,data,[options]);\n    axios默认发送数据时，数据格式是Request Payload，并非我们常用的Form Data格式，\n    所以参数必须要以键值对形式传递，不能以json形式传参\n    传参方式：\n        1.自己拼接为键值对\n        2.使用transformRequest，在请求发送前将请求数据进行转换\n        3.如果使用模块化开发，可以使用qs模块进行转换\n\naxios本身并不支持发送跨域的请求，没有提供相应的API，作者也暂没计划在axios添加支持发送跨域请求，所以只能使用第三方库\n```\nget请求示例\n```\n写法一（只能用这个，参考上面的传参方式）\naxios.get('/user?ID=12345')\n  .then(function (response) {// 成功\n    console.log(response);\n  })\n  .catch(function (error) {// 失败\n    console.log(error);\n  });\n\n写法二\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n\n## 使用vue-resource发送跨域请求\n\n基本用法\n```\n使用this.$http发送请求  \n    this.$http.get(url, [options])\n    this.$http.head(url, [options])\n    this.$http.delete(url, [options])\n    this.$http.jsonp(url, [options])\n    this.$http.post(url, [body], [options])\n    this.$http.put(url, [body], [options])\n    this.$http.patch(url, [body], [options])\n```\n\n```\nthis.$http.jsonp('https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',{\n\t\t\t\tparams:{\n\t\t\t\t\twd:this.keyword\n\t\t\t\t},\n\t\t\t\tjsonp:'cb'\n\t\t\t}).then(resp => {\n\t\tthis.myData=resp.data.s;\n\t});\n```","slug":"ajax学习","published":1,"updated":"2019-06-16T08:30:59.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dheo00079kudhnsg2f0o","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h1 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h1><h2 id=\"XMLHttpRequest-是-AJAX-的基础。\"><a href=\"#XMLHttpRequest-是-AJAX-的基础。\" class=\"headerlink\" title=\"XMLHttpRequest 是 AJAX 的基础。\"></a>XMLHttpRequest 是 AJAX 的基础。</h2><ul>\n<li>XMLHttpRequest 对象</li>\n</ul>\n<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。<br>它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。<br>这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>\n<blockquote>\n<p>通过它，你可以很容易的取回一个 URL 上的资源数据。</p>\n</blockquote>\n<p>尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。<br>而且除了 HTTP ，它还支持 file 和 ftp 协议。<br><a id=\"more\"></a></p>\n<h2 id=\"构造函数-XMLHttpRequest\"><a href=\"#构造函数-XMLHttpRequest\" class=\"headerlink\" title=\"构造函数 XMLHttpRequest()\"></a>构造函数 XMLHttpRequest()</h2><p>构造函数初始化一个 XMLHttpRequest 对象。必须在所有其他方法被调用前调用构造函数。</p>\n<p>语法：</p>\n<blockquote>\n<p>var myRequest = new XMLHttpRequest();</p>\n</blockquote>\n<p>此时 myRequest 已经成为一个XMLHttpRequest 对象，可以使用XMLHttpRequest的方法。</p>\n<h2 id=\"向服务器发送请求\"><a href=\"#向服务器发送请求\" class=\"headerlink\" title=\"向服务器发送请求\"></a>向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class=\"line\">xmlhttp.send(null);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>open(method,url,async) //<br>规定请求的类型、URL 以及是否异步处理请求。</p>\n<ul>\n<li>method：请求的类型；GET 或 POST</li>\n<li>url：文件在服务器上的位置</li>\n<li>async：true（异步）或 false（同步）</li>\n</ul>\n</li>\n<li><p>send(string) // 将请求发送到服务器。</p>\n<ul>\n<li>string：仅用于 POST 请求（如果不需要发送请求，则必须传入Null）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h2><p>如果您希望通过 GET 方法发送信息，请向 URL 添加信息（在地址后面加问号，然后再添加）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;,true);</span><br><span class=\"line\">xmlhttp.send();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h2><p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。<br>然后在 send() 方法中规定您希望发送的数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);</span><br><span class=\"line\">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>方法:</p>\n<blockquote>\n<p>setRequestHeader(header,value)</p>\n</blockquote>\n<ul>\n<li>向请求添加 HTTP 头。<ul>\n<li>header: 规定头的名称</li>\n<li>value: 规定头的值</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"我们使用-GET-还是-POST？\"><a href=\"#我们使用-GET-还是-POST？\" class=\"headerlink\" title=\"我们使用 GET 还是 POST？\"></a>我们使用 GET 还是 POST？</h2><p>GET 更简单也更快，并且在大部分情况下都能用。<br>然而，在以下情况中，请使用 POST 请求：</p>\n<ul>\n<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>\n<li>向服务器发送大量数据（POST 没有数据量限制）</li>\n<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n<h2 id=\"异步如何设置-True-或-False？\"><a href=\"#异步如何设置-True-或-False？\" class=\"headerlink\" title=\"异步如何设置 - True 或 False？\"></a>异步如何设置 - True 或 False？</h2><p>AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。<br>XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true。</p>\n<p>通过 AJAX，JavaScript 无需等待服务器的响应，而是：</p>\n<ul>\n<li>在等待服务器响应时执行其他脚本</li>\n<li>当响应就绪后对响应进行处理</li>\n</ul>\n<h2 id=\"接收响应\"><a href=\"#接收响应\" class=\"headerlink\" title=\"接收响应\"></a>接收响应</h2><p>一个完整的http响应是由状态码，响应头集合，和响应主题组成。<br>在收到响应的消息后，这些都是可以通过xhr对象的属性和方法所使用。<br>它们主要有以下4个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">responseText;作为相应主题返回的文本，（文本形式）</span><br><span class=\"line\">responseXML;如果响应的内容是‘text/xml’或者是哦application/xml;属性中将会保存，响应数据的xml形式。DOM文档形式。</span><br><span class=\"line\"></span><br><span class=\"line\">status: http的状态码（数字形式）</span><br><span class=\"line\">statusText;http状态说明，（文本形式）</span><br></pre></td></tr></table></figure>\n<h2 id=\"ajax原生\"><a href=\"#ajax原生\" class=\"headerlink\" title=\"ajax原生\"></a>ajax原生</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//**********第一步, 获得一个xhr对象*************</span><br><span class=\"line\"></span><br><span class=\"line\">       var xmlHttpReq = null;// 声明一个空对象用来装入XMLHttpRequest</span><br><span class=\"line\"></span><br><span class=\"line\">       if (window.XMLHttpRequest)&#123;// ie7 以上的浏览器XMLHttpRequest是window的子对象</span><br><span class=\"line\"></span><br><span class=\"line\">              xmlHttpReq = new XMLHttpRequest();// 实例化一个XMLHttpRequest</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;else (window.ActiveXObject)&#123;// IE5 IE6是以ActiveXObject的方式引入XMLHttpRequest的</span><br><span class=\"line\"></span><br><span class=\"line\">              xmlHttpReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       if(xhr != null)&#123;  // 如果对象实例化成功</span><br><span class=\"line\">              //设置回调函数</span><br><span class=\"line\">              xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  if(xhr.readyState == 4)&#123;  // 确定响应已经成功返回</span><br><span class=\"line\">                       // 200可作为成功标志, 304表示请求资源没有修改, 可直接使用浏览器缓存</span><br><span class=\"line\">                       if ((xhr.status&gt;=200 &amp;&amp; xhr.status &lt; 300 ) || xhr.status == 304)&#123;</span><br><span class=\"line\">                             alert(xhr.responseText); // 请求成功，服务器返回的数据</span><br><span class=\"line\">                        &#125; else &#123;</span><br><span class=\"line\">                             alert( &quot;请求失败: &quot; + xhr.status);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//************第二步: 启动请求.******************</span><br><span class=\"line\">              // open方法接收三个参数: 要发送的请求类型(get,post等), 请求的url和是否异步发送请求的布尔值</span><br><span class=\"line\">              xhr.open(&quot;get&quot;,&quot;test.php&quot;,true);</span><br><span class=\"line\">              // 调用open()方法并采用异步方式. 如果第三个参数是false, 同步执行, 则js代码会等到服务器响应之后再继续执行</span><br><span class=\"line\"></span><br><span class=\"line\">//*************第三步: 发送数据*******************</span><br><span class=\"line\">              // send方法接收一个参数,即要作为请求主体发送的数据. 如果不需要通过请求主体发送数据, 则必须传入null. 因为这个参数对有些浏览器是必须的</span><br><span class=\"line\">              xhr.send(null);</span><br><span class=\"line\">              // 因为使用get方式提交，所以可以使用null参调用</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果要设置请求头部信息,必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>readyStatus的五个阶段<ul>\n<li>0：未初始化。尚未调用open()方法</li>\n<li>1：启动。已经调用open()方法，尚未调用send()方法</li>\n<li>2：发送。已经调用send()方法，尚未接收到响应</li>\n<li>3：接收。已经接收部分响应数据。</li>\n<li>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。【一般只需检查这个阶段】</li>\n</ul>\n</li>\n<li>获得的数据在responseText或responseXML属性中, 后者需要XML解析</li>\n</ul>\n<h2 id=\"ajax跨域\"><a href=\"#ajax跨域\" class=\"headerlink\" title=\"ajax跨域\"></a>ajax跨域</h2><p>三种跨域方法：<br>一、一般使用封装好的jsonp</p>\n<p>jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。<br>普通方法: 给html标签添加脚本属性<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addScriptTag(src) &#123;</span><br><span class=\"line\">  // 创建script元素标签，设置其属性</span><br><span class=\"line\">  var script = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class=\"line\">  // 给script标签，设置标签属性</span><br><span class=\"line\">  script.src = src;</span><br><span class=\"line\">  // 把script标签添加成为body的子标签</span><br><span class=\"line\">  document.body.appendChild(script);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 提供jsonp服务的url地址，并调用foo函数</span><br><span class=\"line\">window.onload = function () &#123;</span><br><span class=\"line\">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(data) &#123;</span><br><span class=\"line\">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>jqurey方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $.ajax(&#123;</span><br><span class=\"line\">    url: &quot;url&quot;,</span><br><span class=\"line\">    type: &quot;GET&quot;,</span><br><span class=\"line\">    dataType: &quot;jsonp&quot;,  //指定服务器返回的数据类型</span><br><span class=\"line\">    jsonp: &quot;cb&quot;,   //指定参数名称</span><br><span class=\"line\">    jsonpCallback: &quot;showData&quot;,  //指定回调函数名称</span><br><span class=\"line\">    success: function (data) &#123;</span><br><span class=\"line\">        console.log(&quot;调用success&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>二、CORS是跨源资源分享（在后端设置头部支持，允许跨域）</p>\n<ul>\n<li>Access-Control-Allow-Origin:*</li>\n</ul>\n<p>三、设置代理请求（不会）</p>\n<h1 id=\"vue使用Ajax\"><a href=\"#vue使用Ajax\" class=\"headerlink\" title=\"vue使用Ajax\"></a>vue使用Ajax</h1><p>本身不支持发送AJAX请求，需要使用vue-resource、axios等插件实现</p>\n<h2 id=\"axios使用Ajax\"><a href=\"#axios使用Ajax\" class=\"headerlink\" title=\"axios使用Ajax\"></a>axios使用Ajax</h2><p>注意：axios不支持跨域</p>\n<p>参考github上的官方文档，[options]是可以使用的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios([options])  </span><br><span class=\"line\">axios.get(url[,options]);</span><br><span class=\"line\">    传参方式：</span><br><span class=\"line\">        1.通过url传参</span><br><span class=\"line\">        2.通过params选项传参</span><br><span class=\"line\">axios.post(url,data,[options]);</span><br><span class=\"line\">    axios默认发送数据时，数据格式是Request Payload，并非我们常用的Form Data格式，</span><br><span class=\"line\">    所以参数必须要以键值对形式传递，不能以json形式传参</span><br><span class=\"line\">    传参方式：</span><br><span class=\"line\">        1.自己拼接为键值对</span><br><span class=\"line\">        2.使用transformRequest，在请求发送前将请求数据进行转换</span><br><span class=\"line\">        3.如果使用模块化开发，可以使用qs模块进行转换</span><br><span class=\"line\"></span><br><span class=\"line\">axios本身并不支持发送跨域的请求，没有提供相应的API，作者也暂没计划在axios添加支持发送跨域请求，所以只能使用第三方库</span><br></pre></td></tr></table></figure></p>\n<p>get请求示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写法一（只能用这个，参考上面的传参方式）</span><br><span class=\"line\">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class=\"line\">  .then(function (response) &#123;// 成功</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;// 失败</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">写法二</span><br><span class=\"line\">axios.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用vue-resource发送跨域请求\"><a href=\"#使用vue-resource发送跨域请求\" class=\"headerlink\" title=\"使用vue-resource发送跨域请求\"></a>使用vue-resource发送跨域请求</h2><p>基本用法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用this.$http发送请求  </span><br><span class=\"line\">    this.$http.get(url, [options])</span><br><span class=\"line\">    this.$http.head(url, [options])</span><br><span class=\"line\">    this.$http.delete(url, [options])</span><br><span class=\"line\">    this.$http.jsonp(url, [options])</span><br><span class=\"line\">    this.$http.post(url, [body], [options])</span><br><span class=\"line\">    this.$http.put(url, [body], [options])</span><br><span class=\"line\">    this.$http.patch(url, [body], [options])</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$http.jsonp(&apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&apos;,&#123;</span><br><span class=\"line\">\t\t\t\tparams:&#123;</span><br><span class=\"line\">\t\t\t\t\twd:this.keyword</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tjsonp:&apos;cb&apos;</span><br><span class=\"line\">\t\t\t&#125;).then(resp =&gt; &#123;</span><br><span class=\"line\">\t\tthis.myData=resp.data.s;</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h1 id=\"ajax\"><a href=\"#ajax\" class=\"headerlink\" title=\"ajax\"></a>ajax</h1><h2 id=\"XMLHttpRequest-是-AJAX-的基础。\"><a href=\"#XMLHttpRequest-是-AJAX-的基础。\" class=\"headerlink\" title=\"XMLHttpRequest 是 AJAX 的基础。\"></a>XMLHttpRequest 是 AJAX 的基础。</h2><ul>\n<li>XMLHttpRequest 对象</li>\n</ul>\n<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。<br>它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。<br>这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>\n<blockquote>\n<p>通过它，你可以很容易的取回一个 URL 上的资源数据。</p>\n</blockquote>\n<p>尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。<br>而且除了 HTTP ，它还支持 file 和 ftp 协议。<br>","more":"</p>\n<h2 id=\"构造函数-XMLHttpRequest\"><a href=\"#构造函数-XMLHttpRequest\" class=\"headerlink\" title=\"构造函数 XMLHttpRequest()\"></a>构造函数 XMLHttpRequest()</h2><p>构造函数初始化一个 XMLHttpRequest 对象。必须在所有其他方法被调用前调用构造函数。</p>\n<p>语法：</p>\n<blockquote>\n<p>var myRequest = new XMLHttpRequest();</p>\n</blockquote>\n<p>此时 myRequest 已经成为一个XMLHttpRequest 对象，可以使用XMLHttpRequest的方法。</p>\n<h2 id=\"向服务器发送请求\"><a href=\"#向服务器发送请求\" class=\"headerlink\" title=\"向服务器发送请求\"></a>向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class=\"line\">xmlhttp.send(null);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>open(method,url,async) //<br>规定请求的类型、URL 以及是否异步处理请求。</p>\n<ul>\n<li>method：请求的类型；GET 或 POST</li>\n<li>url：文件在服务器上的位置</li>\n<li>async：true（异步）或 false（同步）</li>\n</ul>\n</li>\n<li><p>send(string) // 将请求发送到服务器。</p>\n<ul>\n<li>string：仅用于 POST 请求（如果不需要发送请求，则必须传入Null）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"GET请求\"><a href=\"#GET请求\" class=\"headerlink\" title=\"GET请求\"></a>GET请求</h2><p>如果您希望通过 GET 方法发送信息，请向 URL 添加信息（在地址后面加问号，然后再添加）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;,true);</span><br><span class=\"line\">xmlhttp.send();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h2><p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。<br>然后在 send() 方法中规定您希望发送的数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);</span><br><span class=\"line\">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>方法:</p>\n<blockquote>\n<p>setRequestHeader(header,value)</p>\n</blockquote>\n<ul>\n<li>向请求添加 HTTP 头。<ul>\n<li>header: 规定头的名称</li>\n<li>value: 规定头的值</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"我们使用-GET-还是-POST？\"><a href=\"#我们使用-GET-还是-POST？\" class=\"headerlink\" title=\"我们使用 GET 还是 POST？\"></a>我们使用 GET 还是 POST？</h2><p>GET 更简单也更快，并且在大部分情况下都能用。<br>然而，在以下情况中，请使用 POST 请求：</p>\n<ul>\n<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>\n<li>向服务器发送大量数据（POST 没有数据量限制）</li>\n<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>\n</ul>\n<h2 id=\"异步如何设置-True-或-False？\"><a href=\"#异步如何设置-True-或-False？\" class=\"headerlink\" title=\"异步如何设置 - True 或 False？\"></a>异步如何设置 - True 或 False？</h2><p>AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。<br>XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true。</p>\n<p>通过 AJAX，JavaScript 无需等待服务器的响应，而是：</p>\n<ul>\n<li>在等待服务器响应时执行其他脚本</li>\n<li>当响应就绪后对响应进行处理</li>\n</ul>\n<h2 id=\"接收响应\"><a href=\"#接收响应\" class=\"headerlink\" title=\"接收响应\"></a>接收响应</h2><p>一个完整的http响应是由状态码，响应头集合，和响应主题组成。<br>在收到响应的消息后，这些都是可以通过xhr对象的属性和方法所使用。<br>它们主要有以下4个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">responseText;作为相应主题返回的文本，（文本形式）</span><br><span class=\"line\">responseXML;如果响应的内容是‘text/xml’或者是哦application/xml;属性中将会保存，响应数据的xml形式。DOM文档形式。</span><br><span class=\"line\"></span><br><span class=\"line\">status: http的状态码（数字形式）</span><br><span class=\"line\">statusText;http状态说明，（文本形式）</span><br></pre></td></tr></table></figure>\n<h2 id=\"ajax原生\"><a href=\"#ajax原生\" class=\"headerlink\" title=\"ajax原生\"></a>ajax原生</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//**********第一步, 获得一个xhr对象*************</span><br><span class=\"line\"></span><br><span class=\"line\">       var xmlHttpReq = null;// 声明一个空对象用来装入XMLHttpRequest</span><br><span class=\"line\"></span><br><span class=\"line\">       if (window.XMLHttpRequest)&#123;// ie7 以上的浏览器XMLHttpRequest是window的子对象</span><br><span class=\"line\"></span><br><span class=\"line\">              xmlHttpReq = new XMLHttpRequest();// 实例化一个XMLHttpRequest</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;else (window.ActiveXObject)&#123;// IE5 IE6是以ActiveXObject的方式引入XMLHttpRequest的</span><br><span class=\"line\"></span><br><span class=\"line\">              xmlHttpReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       if(xhr != null)&#123;  // 如果对象实例化成功</span><br><span class=\"line\">              //设置回调函数</span><br><span class=\"line\">              xhr.onreadystatechange = function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                  if(xhr.readyState == 4)&#123;  // 确定响应已经成功返回</span><br><span class=\"line\">                       // 200可作为成功标志, 304表示请求资源没有修改, 可直接使用浏览器缓存</span><br><span class=\"line\">                       if ((xhr.status&gt;=200 &amp;&amp; xhr.status &lt; 300 ) || xhr.status == 304)&#123;</span><br><span class=\"line\">                             alert(xhr.responseText); // 请求成功，服务器返回的数据</span><br><span class=\"line\">                        &#125; else &#123;</span><br><span class=\"line\">                             alert( &quot;请求失败: &quot; + xhr.status);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//************第二步: 启动请求.******************</span><br><span class=\"line\">              // open方法接收三个参数: 要发送的请求类型(get,post等), 请求的url和是否异步发送请求的布尔值</span><br><span class=\"line\">              xhr.open(&quot;get&quot;,&quot;test.php&quot;,true);</span><br><span class=\"line\">              // 调用open()方法并采用异步方式. 如果第三个参数是false, 同步执行, 则js代码会等到服务器响应之后再继续执行</span><br><span class=\"line\"></span><br><span class=\"line\">//*************第三步: 发送数据*******************</span><br><span class=\"line\">              // send方法接收一个参数,即要作为请求主体发送的数据. 如果不需要通过请求主体发送数据, 则必须传入null. 因为这个参数对有些浏览器是必须的</span><br><span class=\"line\">              xhr.send(null);</span><br><span class=\"line\">              // 因为使用get方式提交，所以可以使用null参调用</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果要设置请求头部信息,必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>readyStatus的五个阶段<ul>\n<li>0：未初始化。尚未调用open()方法</li>\n<li>1：启动。已经调用open()方法，尚未调用send()方法</li>\n<li>2：发送。已经调用send()方法，尚未接收到响应</li>\n<li>3：接收。已经接收部分响应数据。</li>\n<li>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。【一般只需检查这个阶段】</li>\n</ul>\n</li>\n<li>获得的数据在responseText或responseXML属性中, 后者需要XML解析</li>\n</ul>\n<h2 id=\"ajax跨域\"><a href=\"#ajax跨域\" class=\"headerlink\" title=\"ajax跨域\"></a>ajax跨域</h2><p>三种跨域方法：<br>一、一般使用封装好的jsonp</p>\n<p>jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。<br>普通方法: 给html标签添加脚本属性<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addScriptTag(src) &#123;</span><br><span class=\"line\">  // 创建script元素标签，设置其属性</span><br><span class=\"line\">  var script = document.createElement(&apos;script&apos;);</span><br><span class=\"line\">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class=\"line\">  // 给script标签，设置标签属性</span><br><span class=\"line\">  script.src = src;</span><br><span class=\"line\">  // 把script标签添加成为body的子标签</span><br><span class=\"line\">  document.body.appendChild(script);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 提供jsonp服务的url地址，并调用foo函数</span><br><span class=\"line\">window.onload = function () &#123;</span><br><span class=\"line\">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo(data) &#123;</span><br><span class=\"line\">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>jqurey方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $.ajax(&#123;</span><br><span class=\"line\">    url: &quot;url&quot;,</span><br><span class=\"line\">    type: &quot;GET&quot;,</span><br><span class=\"line\">    dataType: &quot;jsonp&quot;,  //指定服务器返回的数据类型</span><br><span class=\"line\">    jsonp: &quot;cb&quot;,   //指定参数名称</span><br><span class=\"line\">    jsonpCallback: &quot;showData&quot;,  //指定回调函数名称</span><br><span class=\"line\">    success: function (data) &#123;</span><br><span class=\"line\">        console.log(&quot;调用success&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>二、CORS是跨源资源分享（在后端设置头部支持，允许跨域）</p>\n<ul>\n<li>Access-Control-Allow-Origin:*</li>\n</ul>\n<p>三、设置代理请求（不会）</p>\n<h1 id=\"vue使用Ajax\"><a href=\"#vue使用Ajax\" class=\"headerlink\" title=\"vue使用Ajax\"></a>vue使用Ajax</h1><p>本身不支持发送AJAX请求，需要使用vue-resource、axios等插件实现</p>\n<h2 id=\"axios使用Ajax\"><a href=\"#axios使用Ajax\" class=\"headerlink\" title=\"axios使用Ajax\"></a>axios使用Ajax</h2><p>注意：axios不支持跨域</p>\n<p>参考github上的官方文档，[options]是可以使用的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios([options])  </span><br><span class=\"line\">axios.get(url[,options]);</span><br><span class=\"line\">    传参方式：</span><br><span class=\"line\">        1.通过url传参</span><br><span class=\"line\">        2.通过params选项传参</span><br><span class=\"line\">axios.post(url,data,[options]);</span><br><span class=\"line\">    axios默认发送数据时，数据格式是Request Payload，并非我们常用的Form Data格式，</span><br><span class=\"line\">    所以参数必须要以键值对形式传递，不能以json形式传参</span><br><span class=\"line\">    传参方式：</span><br><span class=\"line\">        1.自己拼接为键值对</span><br><span class=\"line\">        2.使用transformRequest，在请求发送前将请求数据进行转换</span><br><span class=\"line\">        3.如果使用模块化开发，可以使用qs模块进行转换</span><br><span class=\"line\"></span><br><span class=\"line\">axios本身并不支持发送跨域的请求，没有提供相应的API，作者也暂没计划在axios添加支持发送跨域请求，所以只能使用第三方库</span><br></pre></td></tr></table></figure></p>\n<p>get请求示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写法一（只能用这个，参考上面的传参方式）</span><br><span class=\"line\">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class=\"line\">  .then(function (response) &#123;// 成功</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;// 失败</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">写法二</span><br><span class=\"line\">axios.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用vue-resource发送跨域请求\"><a href=\"#使用vue-resource发送跨域请求\" class=\"headerlink\" title=\"使用vue-resource发送跨域请求\"></a>使用vue-resource发送跨域请求</h2><p>基本用法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用this.$http发送请求  </span><br><span class=\"line\">    this.$http.get(url, [options])</span><br><span class=\"line\">    this.$http.head(url, [options])</span><br><span class=\"line\">    this.$http.delete(url, [options])</span><br><span class=\"line\">    this.$http.jsonp(url, [options])</span><br><span class=\"line\">    this.$http.post(url, [body], [options])</span><br><span class=\"line\">    this.$http.put(url, [body], [options])</span><br><span class=\"line\">    this.$http.patch(url, [body], [options])</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$http.jsonp(&apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&apos;,&#123;</span><br><span class=\"line\">\t\t\t\tparams:&#123;</span><br><span class=\"line\">\t\t\t\t\twd:this.keyword</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tjsonp:&apos;cb&apos;</span><br><span class=\"line\">\t\t\t&#125;).then(resp =&gt; &#123;</span><br><span class=\"line\">\t\tthis.myData=resp.data.s;</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"javascript循环语句","date":"2018-04-27T16:07:03.000Z","_content":"[TOC]\n\n学习和记录循环语句需要注意的重要细节，深入理解js的循环语句\n\n## for（条件循环）\n\n一般for循环的语法为：\n```\nfor(语句1;语句2;语句3){\n    被执行的代码块；\n}\n```\n\n语句 1 在循环（代码块）开始前执行 \n语句 2 定义运行循环（代码块）的条件 \n语句 3 在循环（代码块）已被执行之后执行\n\n <!-- more -->\n\n干巴巴的说明有点无聊，不方便记忆，我们来做一道经典题型\n\n以面试题级别的题型为例：\n\n```\n// 挑战一\nvar k;\nfor(i=0, j=0; i<10, j<6; i++, j++){\n    k = i + j;\n}\nconsole.log(k);  // ？？？\n```\n偶不！它一次定义了很多条语句！这不是for循环！\n等等……仔细一看，它只有三个分号。冷静，这是我们刚才学习的for循环！\n\n毕竟也没有谁规定一个语句之中，只能写一个判断，这样做是可以的。\n那么，答案会是多少呢？\n\n一开始，i和j都等于零。\n条件判断后，i和j都自加一。\n\n但条件判断是以谁为基准？分别循环？不可能！\n\n所幸，我们不是真的在面试，直接用浏览器运行便能一窥究竟。\n答案是10\n\n而如果把i<10 和 j<6 的位置对调\n则会输出18\n\n>由此可见，for循环的条件判断`停止条件`，由最接近第二个分号的条件为准。\n\n- 顺便一提，当循环遍历一个数组，并且数组的长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率\n\n例：\n>const arr = [1, 2, 3];\nfor(let i = 0, len = arr.length; i < len; i++)\n\n----\n\n## for-in (遍历所有可枚举的属性)\n\nfor-in语句用于对数组或者对象的`属性`进行循环操作。\n\nfor-in 循环中的代码每执行一次，就会对`数组的元素`或者`对象的属性`进行一次操作。\n\nTip:\n>for-in循环应该用在`非数组对象`的遍历上，使用for-in进行循环也被称为“枚举”。因为它真正遍历的是对象`“可枚举的属性”`\n\n注意：\n>for-in 遍历属性的顺序并不确定。\n即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。\n\n### Array 的真相\n\nArray 在 Javascript 中是一个对象， Array 的索引是属性名。\n\n事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。\n\n实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。\n\n有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？\n\n那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。\n\n\n现在我们来看看用 for-in 来循环数组的特殊例子\n\n```\nconst arr = [1, 2, 3];\narr.name = \"Hello world\";\nlet index;\nfor(index in arr) {\n    console.log(\"arr[\" + index + \"] = \" + arr[index]);\n}\n//运行结果\n//arr[0] = 1\n//arr[1] = 2\n//arr[2] = 3\n//arr[name] = Hello world\n```\n我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。\n\n同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。\n\n那是不是说，只要我们不在 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。\n\n- 因为 for-in 不仅仅遍历 array 自身的属性，它还遍历 array 原型链上的所有可枚举的属性。\n\n\n下面我们看个例子：\n\n```\nArray.prototype.fatherName = \"Father\";\nconst arr = [1, 2, 3];\narr.name = \"Hello world\";\nlet index;\nfor(index in arr) {\n    console.log(\"arr[\" + index + \"] = \" + arr[index]);\n}\n//arr[0] = 1\n//arr[1] = 2\n//arr[2] = 3\n//arr[name] = Hello world\n//arr[fatherName] = Father\n```\n写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。\n\n- 但是有一种情况例外，那就是稀疏数组。\n\n```\nlet key;\nconst arr = [];\narr[0] = \"a\";\narr[100] = \"b\";\narr[10000] = \"c\";\nfor(key in arr) {\n    if(arr.hasOwnProperty(key) && \n    /^0$|^[1-9]\\d*$/.test(key) && \n    key <= 4294967294 \n    ) {\n     console.log(arr[key]);\n    }\n}\n```\n- for-in 只会遍历存在的实体.\n\n上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，而普通 for 循环则会遍历 10001 次）。\n所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。\n\n\nfor-in 性能\n正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。\n因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。\n\n如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：\n```\nconst obj = {\n \"prop1\": \"value1\",\n \"prop2\": \"value2\"\n};\n  \nconst props = [\"prop1\", \"prop2\"];\nfor(let i = 0; i < props.length; i++) {\n console.log(obj[props[i]]);\n}\n```\n上面代码中，将对象的属性都存入一个数组中，相对于 for-in 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。\n\n#### for-in总结：\n\n最后来一个面试题\n\n```\nvar nums = [12,32,54,56,78,89];\nfor(var n in nums){\n    console.log(n);  // 0,1,2,3,4,5\n}\n```\n因为for-in的真正作用已经解释了很多，所以我们只需要梳理一下知识点，即可轻松解答\n\n\n总结：\n①：Array实际上不存在索引（但存在类似的属性）\n②：for-in只能遍历可枚举属性（几乎所有属性）\n③：for-in并不直接获取数组元素（获取元素方法：数组[索引属性]）\n④：for-in输出顺序不确定（不会自动排列）\n\n由此可得：\n①：console.log(n)不可能输出元素\n②：n是索引属性\n\n- 所以，Array不存在索引，但for-in遍历索引属性（普通的for循环是遍历数组长度）。\n\n补充：（过滤不想要的属性）\n```\nfor(var i in a) {\n    // 跳过继承的属性\n    if (!a.hasOwnProperty(i)) continue; // continue结束本次循环\n\n    // 跳过不是非负整数的 i\n    if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;\n}\n```\n\n----\n\n## forEach (遍历所有元素并回调)\n\n在 ES5 中，引入了新的循环，即 forEach 循环。\n\n```\nconst arr = [1, 2, 3];\narr.forEach((data) => {\n    console.log(data);\n});\n//1\n//2\n//3\n```\nforEach 方法为数组中含有有效值的每一项执行一次 callback 函数。\n那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 \n\ncallback 函数会被依次传入三个参数：\n\nforEach(值,索引,数组对象本身)，默认只遍历值\n\n- 数组当前项的值；\n- 数组当前项的索引；\n- 数组对象本身；\n\n需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。\n调用forEach 后添加到数组中的项不会被 callback 访问到。\n\n如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。\n已删除的项不会被遍历到。\n\n```\nconst arr = [];\narr[0] = \"a\";\narr[3] = \"b\";\narr[10] = \"c\";\narr.name = \"Hello world\";\narr.forEach((data, index, array) => {\n    console.log(data, index, array);\n});\n```\n\n运行结果:\n\n```\na 0 [\"a\", 3: \"b\", 10: \"c\", name: \"Hello world\"]\nb 3 [\"a\", 3: \"b\", 10: \"c\", name: \"Hello world\"]\nc 10 [\"a\", 3: \"b\", 10: \"c\", name: \"Hello world\"]\n```\n\n这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。\n\n所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。\n\n另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：\n- every: 循环在第一次 return false 后返回\n- some: 循环在第一次 return true 后返回\n- filter: 返回一个新的数组，该数组内的元素满足回调函数\n- map: 将原数组中的元素处理后再返回\n- reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。\n\n\nforEach 性能：一般\nforEach 的速度不如 for ，因为forEach会遍历所有元素，并一一进行回调。\n\n","source":"_posts/javascript循环语句.md","raw":"---\ntitle: javascript循环语句\ndate: 2018-04-28 00:07:03\ncategories:\n  - JS学习笔记\ntags:\n  - 循环语句 js\n---\n[TOC]\n\n学习和记录循环语句需要注意的重要细节，深入理解js的循环语句\n\n## for（条件循环）\n\n一般for循环的语法为：\n```\nfor(语句1;语句2;语句3){\n    被执行的代码块；\n}\n```\n\n语句 1 在循环（代码块）开始前执行 \n语句 2 定义运行循环（代码块）的条件 \n语句 3 在循环（代码块）已被执行之后执行\n\n <!-- more -->\n\n干巴巴的说明有点无聊，不方便记忆，我们来做一道经典题型\n\n以面试题级别的题型为例：\n\n```\n// 挑战一\nvar k;\nfor(i=0, j=0; i<10, j<6; i++, j++){\n    k = i + j;\n}\nconsole.log(k);  // ？？？\n```\n偶不！它一次定义了很多条语句！这不是for循环！\n等等……仔细一看，它只有三个分号。冷静，这是我们刚才学习的for循环！\n\n毕竟也没有谁规定一个语句之中，只能写一个判断，这样做是可以的。\n那么，答案会是多少呢？\n\n一开始，i和j都等于零。\n条件判断后，i和j都自加一。\n\n但条件判断是以谁为基准？分别循环？不可能！\n\n所幸，我们不是真的在面试，直接用浏览器运行便能一窥究竟。\n答案是10\n\n而如果把i<10 和 j<6 的位置对调\n则会输出18\n\n>由此可见，for循环的条件判断`停止条件`，由最接近第二个分号的条件为准。\n\n- 顺便一提，当循环遍历一个数组，并且数组的长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率\n\n例：\n>const arr = [1, 2, 3];\nfor(let i = 0, len = arr.length; i < len; i++)\n\n----\n\n## for-in (遍历所有可枚举的属性)\n\nfor-in语句用于对数组或者对象的`属性`进行循环操作。\n\nfor-in 循环中的代码每执行一次，就会对`数组的元素`或者`对象的属性`进行一次操作。\n\nTip:\n>for-in循环应该用在`非数组对象`的遍历上，使用for-in进行循环也被称为“枚举”。因为它真正遍历的是对象`“可枚举的属性”`\n\n注意：\n>for-in 遍历属性的顺序并不确定。\n即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。\n\n### Array 的真相\n\nArray 在 Javascript 中是一个对象， Array 的索引是属性名。\n\n事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。\n\n实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。\n\n有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？\n\n那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。\n\n\n现在我们来看看用 for-in 来循环数组的特殊例子\n\n```\nconst arr = [1, 2, 3];\narr.name = \"Hello world\";\nlet index;\nfor(index in arr) {\n    console.log(\"arr[\" + index + \"] = \" + arr[index]);\n}\n//运行结果\n//arr[0] = 1\n//arr[1] = 2\n//arr[2] = 3\n//arr[name] = Hello world\n```\n我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。\n\n同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。\n\n那是不是说，只要我们不在 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。\n\n- 因为 for-in 不仅仅遍历 array 自身的属性，它还遍历 array 原型链上的所有可枚举的属性。\n\n\n下面我们看个例子：\n\n```\nArray.prototype.fatherName = \"Father\";\nconst arr = [1, 2, 3];\narr.name = \"Hello world\";\nlet index;\nfor(index in arr) {\n    console.log(\"arr[\" + index + \"] = \" + arr[index]);\n}\n//arr[0] = 1\n//arr[1] = 2\n//arr[2] = 3\n//arr[name] = Hello world\n//arr[fatherName] = Father\n```\n写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。\n\n- 但是有一种情况例外，那就是稀疏数组。\n\n```\nlet key;\nconst arr = [];\narr[0] = \"a\";\narr[100] = \"b\";\narr[10000] = \"c\";\nfor(key in arr) {\n    if(arr.hasOwnProperty(key) && \n    /^0$|^[1-9]\\d*$/.test(key) && \n    key <= 4294967294 \n    ) {\n     console.log(arr[key]);\n    }\n}\n```\n- for-in 只会遍历存在的实体.\n\n上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，而普通 for 循环则会遍历 10001 次）。\n所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。\n\n\nfor-in 性能\n正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。\n因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。\n\n如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：\n```\nconst obj = {\n \"prop1\": \"value1\",\n \"prop2\": \"value2\"\n};\n  \nconst props = [\"prop1\", \"prop2\"];\nfor(let i = 0; i < props.length; i++) {\n console.log(obj[props[i]]);\n}\n```\n上面代码中，将对象的属性都存入一个数组中，相对于 for-in 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。\n\n#### for-in总结：\n\n最后来一个面试题\n\n```\nvar nums = [12,32,54,56,78,89];\nfor(var n in nums){\n    console.log(n);  // 0,1,2,3,4,5\n}\n```\n因为for-in的真正作用已经解释了很多，所以我们只需要梳理一下知识点，即可轻松解答\n\n\n总结：\n①：Array实际上不存在索引（但存在类似的属性）\n②：for-in只能遍历可枚举属性（几乎所有属性）\n③：for-in并不直接获取数组元素（获取元素方法：数组[索引属性]）\n④：for-in输出顺序不确定（不会自动排列）\n\n由此可得：\n①：console.log(n)不可能输出元素\n②：n是索引属性\n\n- 所以，Array不存在索引，但for-in遍历索引属性（普通的for循环是遍历数组长度）。\n\n补充：（过滤不想要的属性）\n```\nfor(var i in a) {\n    // 跳过继承的属性\n    if (!a.hasOwnProperty(i)) continue; // continue结束本次循环\n\n    // 跳过不是非负整数的 i\n    if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;\n}\n```\n\n----\n\n## forEach (遍历所有元素并回调)\n\n在 ES5 中，引入了新的循环，即 forEach 循环。\n\n```\nconst arr = [1, 2, 3];\narr.forEach((data) => {\n    console.log(data);\n});\n//1\n//2\n//3\n```\nforEach 方法为数组中含有有效值的每一项执行一次 callback 函数。\n那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 \n\ncallback 函数会被依次传入三个参数：\n\nforEach(值,索引,数组对象本身)，默认只遍历值\n\n- 数组当前项的值；\n- 数组当前项的索引；\n- 数组对象本身；\n\n需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。\n调用forEach 后添加到数组中的项不会被 callback 访问到。\n\n如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。\n已删除的项不会被遍历到。\n\n```\nconst arr = [];\narr[0] = \"a\";\narr[3] = \"b\";\narr[10] = \"c\";\narr.name = \"Hello world\";\narr.forEach((data, index, array) => {\n    console.log(data, index, array);\n});\n```\n\n运行结果:\n\n```\na 0 [\"a\", 3: \"b\", 10: \"c\", name: \"Hello world\"]\nb 3 [\"a\", 3: \"b\", 10: \"c\", name: \"Hello world\"]\nc 10 [\"a\", 3: \"b\", 10: \"c\", name: \"Hello world\"]\n```\n\n这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。\n\n所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。\n\n另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：\n- every: 循环在第一次 return false 后返回\n- some: 循环在第一次 return true 后返回\n- filter: 返回一个新的数组，该数组内的元素满足回调函数\n- map: 将原数组中的元素处理后再返回\n- reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。\n\n\nforEach 性能：一般\nforEach 的速度不如 for ，因为forEach会遍历所有元素，并一一进行回调。\n\n","slug":"javascript循环语句","published":1,"updated":"2019-04-07T14:56:53.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dheq00089kudv8axpbd0","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[TOC]</p>\n<p>学习和记录循环语句需要注意的重要细节，深入理解js的循环语句</p>\n<h2 id=\"for（条件循环）\"><a href=\"#for（条件循环）\" class=\"headerlink\" title=\"for（条件循环）\"></a>for（条件循环）</h2><p>一般for循环的语法为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(语句1;语句2;语句3)&#123;</span><br><span class=\"line\">    被执行的代码块；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>语句 1 在循环（代码块）开始前执行<br>语句 2 定义运行循环（代码块）的条件<br>语句 3 在循环（代码块）已被执行之后执行</p>\n <a id=\"more\"></a>\n<p>干巴巴的说明有点无聊，不方便记忆，我们来做一道经典题型</p>\n<p>以面试题级别的题型为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 挑战一</span><br><span class=\"line\">var k;</span><br><span class=\"line\">for(i=0, j=0; i&lt;10, j&lt;6; i++, j++)&#123;</span><br><span class=\"line\">    k = i + j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(k);  // ？？？</span><br></pre></td></tr></table></figure>\n<p>偶不！它一次定义了很多条语句！这不是for循环！<br>等等……仔细一看，它只有三个分号。冷静，这是我们刚才学习的for循环！</p>\n<p>毕竟也没有谁规定一个语句之中，只能写一个判断，这样做是可以的。<br>那么，答案会是多少呢？</p>\n<p>一开始，i和j都等于零。<br>条件判断后，i和j都自加一。</p>\n<p>但条件判断是以谁为基准？分别循环？不可能！</p>\n<p>所幸，我们不是真的在面试，直接用浏览器运行便能一窥究竟。<br>答案是10</p>\n<p>而如果把i&lt;10 和 j&lt;6 的位置对调<br>则会输出18</p>\n<blockquote>\n<p>由此可见，for循环的条件判断<code>停止条件</code>，由最接近第二个分号的条件为准。</p>\n</blockquote>\n<ul>\n<li>顺便一提，当循环遍历一个数组，并且数组的长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率</li>\n</ul>\n<p>例：</p>\n<blockquote>\n<p>const arr = [1, 2, 3];<br>for(let i = 0, len = arr.length; i &lt; len; i++)</p>\n</blockquote>\n<hr>\n<h2 id=\"for-in-遍历所有可枚举的属性\"><a href=\"#for-in-遍历所有可枚举的属性\" class=\"headerlink\" title=\"for-in (遍历所有可枚举的属性)\"></a>for-in (遍历所有可枚举的属性)</h2><p>for-in语句用于对数组或者对象的<code>属性</code>进行循环操作。</p>\n<p>for-in 循环中的代码每执行一次，就会对<code>数组的元素</code>或者<code>对象的属性</code>进行一次操作。</p>\n<p>Tip:</p>\n<blockquote>\n<p>for-in循环应该用在<code>非数组对象</code>的遍历上，使用for-in进行循环也被称为“枚举”。因为它真正遍历的是对象<code>“可枚举的属性”</code></p>\n</blockquote>\n<p>注意：</p>\n<blockquote>\n<p>for-in 遍历属性的顺序并不确定。<br>即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</p>\n</blockquote>\n<h3 id=\"Array-的真相\"><a href=\"#Array-的真相\" class=\"headerlink\" title=\"Array 的真相\"></a>Array 的真相</h3><p>Array 在 Javascript 中是一个对象， Array 的索引是属性名。</p>\n<p>事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。</p>\n<p>实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。</p>\n<p>有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？</p>\n<p>那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p>\n<p>现在我们来看看用 for-in 来循环数组的特殊例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3];</span><br><span class=\"line\">arr.name = &quot;Hello world&quot;;</span><br><span class=\"line\">let index;</span><br><span class=\"line\">for(index in arr) &#123;</span><br><span class=\"line\">    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//运行结果</span><br><span class=\"line\">//arr[0] = 1</span><br><span class=\"line\">//arr[1] = 2</span><br><span class=\"line\">//arr[2] = 3</span><br><span class=\"line\">//arr[name] = Hello world</span><br></pre></td></tr></table></figure>\n<p>我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。</p>\n<p>同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。</p>\n<p>那是不是说，只要我们不在 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。</p>\n<ul>\n<li>因为 for-in 不仅仅遍历 array 自身的属性，它还遍历 array 原型链上的所有可枚举的属性。</li>\n</ul>\n<p>下面我们看个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.fatherName = &quot;Father&quot;;</span><br><span class=\"line\">const arr = [1, 2, 3];</span><br><span class=\"line\">arr.name = &quot;Hello world&quot;;</span><br><span class=\"line\">let index;</span><br><span class=\"line\">for(index in arr) &#123;</span><br><span class=\"line\">    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//arr[0] = 1</span><br><span class=\"line\">//arr[1] = 2</span><br><span class=\"line\">//arr[2] = 3</span><br><span class=\"line\">//arr[name] = Hello world</span><br><span class=\"line\">//arr[fatherName] = Father</span><br></pre></td></tr></table></figure>\n<p>写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。</p>\n<ul>\n<li>但是有一种情况例外，那就是稀疏数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let key;</span><br><span class=\"line\">const arr = [];</span><br><span class=\"line\">arr[0] = &quot;a&quot;;</span><br><span class=\"line\">arr[100] = &quot;b&quot;;</span><br><span class=\"line\">arr[10000] = &quot;c&quot;;</span><br><span class=\"line\">for(key in arr) &#123;</span><br><span class=\"line\">    if(arr.hasOwnProperty(key) &amp;&amp; </span><br><span class=\"line\">    /^0$|^[1-9]\\d*$/.test(key) &amp;&amp; </span><br><span class=\"line\">    key &lt;= 4294967294 </span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">     console.log(arr[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>for-in 只会遍历存在的实体.</li>\n</ul>\n<p>上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，而普通 for 循环则会遍历 10001 次）。<br>所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。</p>\n<p>for-in 性能<br>正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。<br>因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。</p>\n<p>如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\"> &quot;prop1&quot;: &quot;value1&quot;,</span><br><span class=\"line\"> &quot;prop2&quot;: &quot;value2&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">const props = [&quot;prop1&quot;, &quot;prop2&quot;];</span><br><span class=\"line\">for(let i = 0; i &lt; props.length; i++) &#123;</span><br><span class=\"line\"> console.log(obj[props[i]]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，将对象的属性都存入一个数组中，相对于 for-in 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。</p>\n<h4 id=\"for-in总结：\"><a href=\"#for-in总结：\" class=\"headerlink\" title=\"for-in总结：\"></a>for-in总结：</h4><p>最后来一个面试题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nums = [12,32,54,56,78,89];</span><br><span class=\"line\">for(var n in nums)&#123;</span><br><span class=\"line\">    console.log(n);  // 0,1,2,3,4,5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为for-in的真正作用已经解释了很多，所以我们只需要梳理一下知识点，即可轻松解答</p>\n<p>总结：<br>①：Array实际上不存在索引（但存在类似的属性）<br>②：for-in只能遍历可枚举属性（几乎所有属性）<br>③：for-in并不直接获取数组元素（获取元素方法：数组[索引属性]）<br>④：for-in输出顺序不确定（不会自动排列）</p>\n<p>由此可得：<br>①：console.log(n)不可能输出元素<br>②：n是索引属性</p>\n<ul>\n<li>所以，Array不存在索引，但for-in遍历索引属性（普通的for循环是遍历数组长度）。</li>\n</ul>\n<p>补充：（过滤不想要的属性）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i in a) &#123;</span><br><span class=\"line\">    // 跳过继承的属性</span><br><span class=\"line\">    if (!a.hasOwnProperty(i)) continue; // continue结束本次循环</span><br><span class=\"line\"></span><br><span class=\"line\">    // 跳过不是非负整数的 i</span><br><span class=\"line\">    if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"forEach-遍历所有元素并回调\"><a href=\"#forEach-遍历所有元素并回调\" class=\"headerlink\" title=\"forEach (遍历所有元素并回调)\"></a>forEach (遍历所有元素并回调)</h2><p>在 ES5 中，引入了新的循环，即 forEach 循环。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3];</span><br><span class=\"line\">arr.forEach((data) =&gt; &#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//1</span><br><span class=\"line\">//2</span><br><span class=\"line\">//3</span><br></pre></td></tr></table></figure>\n<p>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数。<br>那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 </p>\n<p>callback 函数会被依次传入三个参数：</p>\n<p>forEach(值,索引,数组对象本身)，默认只遍历值</p>\n<ul>\n<li>数组当前项的值；</li>\n<li>数组当前项的索引；</li>\n<li>数组对象本身；</li>\n</ul>\n<p>需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。<br>调用forEach 后添加到数组中的项不会被 callback 访问到。</p>\n<p>如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。<br>已删除的项不会被遍历到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [];</span><br><span class=\"line\">arr[0] = &quot;a&quot;;</span><br><span class=\"line\">arr[3] = &quot;b&quot;;</span><br><span class=\"line\">arr[10] = &quot;c&quot;;</span><br><span class=\"line\">arr.name = &quot;Hello world&quot;;</span><br><span class=\"line\">arr.forEach((data, index, array) =&gt; &#123;</span><br><span class=\"line\">    console.log(data, index, array);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a 0 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br><span class=\"line\">b 3 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br><span class=\"line\">c 10 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br></pre></td></tr></table></figure>\n<p>这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。</p>\n<p>所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。</p>\n<p>另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：</p>\n<ul>\n<li>every: 循环在第一次 return false 后返回</li>\n<li>some: 循环在第一次 return true 后返回</li>\n<li>filter: 返回一个新的数组，该数组内的元素满足回调函数</li>\n<li>map: 将原数组中的元素处理后再返回</li>\n<li>reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。</li>\n</ul>\n<p>forEach 性能：一般<br>forEach 的速度不如 for ，因为forEach会遍历所有元素，并一一进行回调。</p>\n","site":{"data":{}},"excerpt":"<p>[TOC]</p>\n<p>学习和记录循环语句需要注意的重要细节，深入理解js的循环语句</p>\n<h2 id=\"for（条件循环）\"><a href=\"#for（条件循环）\" class=\"headerlink\" title=\"for（条件循环）\"></a>for（条件循环）</h2><p>一般for循环的语法为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(语句1;语句2;语句3)&#123;</span><br><span class=\"line\">    被执行的代码块；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>语句 1 在循环（代码块）开始前执行<br>语句 2 定义运行循环（代码块）的条件<br>语句 3 在循环（代码块）已被执行之后执行</p>","more":"<p>干巴巴的说明有点无聊，不方便记忆，我们来做一道经典题型</p>\n<p>以面试题级别的题型为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 挑战一</span><br><span class=\"line\">var k;</span><br><span class=\"line\">for(i=0, j=0; i&lt;10, j&lt;6; i++, j++)&#123;</span><br><span class=\"line\">    k = i + j;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(k);  // ？？？</span><br></pre></td></tr></table></figure>\n<p>偶不！它一次定义了很多条语句！这不是for循环！<br>等等……仔细一看，它只有三个分号。冷静，这是我们刚才学习的for循环！</p>\n<p>毕竟也没有谁规定一个语句之中，只能写一个判断，这样做是可以的。<br>那么，答案会是多少呢？</p>\n<p>一开始，i和j都等于零。<br>条件判断后，i和j都自加一。</p>\n<p>但条件判断是以谁为基准？分别循环？不可能！</p>\n<p>所幸，我们不是真的在面试，直接用浏览器运行便能一窥究竟。<br>答案是10</p>\n<p>而如果把i&lt;10 和 j&lt;6 的位置对调<br>则会输出18</p>\n<blockquote>\n<p>由此可见，for循环的条件判断<code>停止条件</code>，由最接近第二个分号的条件为准。</p>\n</blockquote>\n<ul>\n<li>顺便一提，当循环遍历一个数组，并且数组的长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率</li>\n</ul>\n<p>例：</p>\n<blockquote>\n<p>const arr = [1, 2, 3];<br>for(let i = 0, len = arr.length; i &lt; len; i++)</p>\n</blockquote>\n<hr>\n<h2 id=\"for-in-遍历所有可枚举的属性\"><a href=\"#for-in-遍历所有可枚举的属性\" class=\"headerlink\" title=\"for-in (遍历所有可枚举的属性)\"></a>for-in (遍历所有可枚举的属性)</h2><p>for-in语句用于对数组或者对象的<code>属性</code>进行循环操作。</p>\n<p>for-in 循环中的代码每执行一次，就会对<code>数组的元素</code>或者<code>对象的属性</code>进行一次操作。</p>\n<p>Tip:</p>\n<blockquote>\n<p>for-in循环应该用在<code>非数组对象</code>的遍历上，使用for-in进行循环也被称为“枚举”。因为它真正遍历的是对象<code>“可枚举的属性”</code></p>\n</blockquote>\n<p>注意：</p>\n<blockquote>\n<p>for-in 遍历属性的顺序并不确定。<br>即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</p>\n</blockquote>\n<h3 id=\"Array-的真相\"><a href=\"#Array-的真相\" class=\"headerlink\" title=\"Array 的真相\"></a>Array 的真相</h3><p>Array 在 Javascript 中是一个对象， Array 的索引是属性名。</p>\n<p>事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。</p>\n<p>实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。</p>\n<p>有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？</p>\n<p>那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p>\n<p>现在我们来看看用 for-in 来循环数组的特殊例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3];</span><br><span class=\"line\">arr.name = &quot;Hello world&quot;;</span><br><span class=\"line\">let index;</span><br><span class=\"line\">for(index in arr) &#123;</span><br><span class=\"line\">    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//运行结果</span><br><span class=\"line\">//arr[0] = 1</span><br><span class=\"line\">//arr[1] = 2</span><br><span class=\"line\">//arr[2] = 3</span><br><span class=\"line\">//arr[name] = Hello world</span><br></pre></td></tr></table></figure>\n<p>我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。</p>\n<p>同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。</p>\n<p>那是不是说，只要我们不在 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。</p>\n<ul>\n<li>因为 for-in 不仅仅遍历 array 自身的属性，它还遍历 array 原型链上的所有可枚举的属性。</li>\n</ul>\n<p>下面我们看个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.fatherName = &quot;Father&quot;;</span><br><span class=\"line\">const arr = [1, 2, 3];</span><br><span class=\"line\">arr.name = &quot;Hello world&quot;;</span><br><span class=\"line\">let index;</span><br><span class=\"line\">for(index in arr) &#123;</span><br><span class=\"line\">    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//arr[0] = 1</span><br><span class=\"line\">//arr[1] = 2</span><br><span class=\"line\">//arr[2] = 3</span><br><span class=\"line\">//arr[name] = Hello world</span><br><span class=\"line\">//arr[fatherName] = Father</span><br></pre></td></tr></table></figure>\n<p>写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。</p>\n<ul>\n<li>但是有一种情况例外，那就是稀疏数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let key;</span><br><span class=\"line\">const arr = [];</span><br><span class=\"line\">arr[0] = &quot;a&quot;;</span><br><span class=\"line\">arr[100] = &quot;b&quot;;</span><br><span class=\"line\">arr[10000] = &quot;c&quot;;</span><br><span class=\"line\">for(key in arr) &#123;</span><br><span class=\"line\">    if(arr.hasOwnProperty(key) &amp;&amp; </span><br><span class=\"line\">    /^0$|^[1-9]\\d*$/.test(key) &amp;&amp; </span><br><span class=\"line\">    key &lt;= 4294967294 </span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">     console.log(arr[key]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>for-in 只会遍历存在的实体.</li>\n</ul>\n<p>上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，而普通 for 循环则会遍历 10001 次）。<br>所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。</p>\n<p>for-in 性能<br>正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。<br>因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。</p>\n<p>如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;</span><br><span class=\"line\"> &quot;prop1&quot;: &quot;value1&quot;,</span><br><span class=\"line\"> &quot;prop2&quot;: &quot;value2&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">const props = [&quot;prop1&quot;, &quot;prop2&quot;];</span><br><span class=\"line\">for(let i = 0; i &lt; props.length; i++) &#123;</span><br><span class=\"line\"> console.log(obj[props[i]]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，将对象的属性都存入一个数组中，相对于 for-in 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。</p>\n<h4 id=\"for-in总结：\"><a href=\"#for-in总结：\" class=\"headerlink\" title=\"for-in总结：\"></a>for-in总结：</h4><p>最后来一个面试题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nums = [12,32,54,56,78,89];</span><br><span class=\"line\">for(var n in nums)&#123;</span><br><span class=\"line\">    console.log(n);  // 0,1,2,3,4,5</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为for-in的真正作用已经解释了很多，所以我们只需要梳理一下知识点，即可轻松解答</p>\n<p>总结：<br>①：Array实际上不存在索引（但存在类似的属性）<br>②：for-in只能遍历可枚举属性（几乎所有属性）<br>③：for-in并不直接获取数组元素（获取元素方法：数组[索引属性]）<br>④：for-in输出顺序不确定（不会自动排列）</p>\n<p>由此可得：<br>①：console.log(n)不可能输出元素<br>②：n是索引属性</p>\n<ul>\n<li>所以，Array不存在索引，但for-in遍历索引属性（普通的for循环是遍历数组长度）。</li>\n</ul>\n<p>补充：（过滤不想要的属性）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i in a) &#123;</span><br><span class=\"line\">    // 跳过继承的属性</span><br><span class=\"line\">    if (!a.hasOwnProperty(i)) continue; // continue结束本次循环</span><br><span class=\"line\"></span><br><span class=\"line\">    // 跳过不是非负整数的 i</span><br><span class=\"line\">    if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"forEach-遍历所有元素并回调\"><a href=\"#forEach-遍历所有元素并回调\" class=\"headerlink\" title=\"forEach (遍历所有元素并回调)\"></a>forEach (遍历所有元素并回调)</h2><p>在 ES5 中，引入了新的循环，即 forEach 循环。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 2, 3];</span><br><span class=\"line\">arr.forEach((data) =&gt; &#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//1</span><br><span class=\"line\">//2</span><br><span class=\"line\">//3</span><br></pre></td></tr></table></figure>\n<p>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数。<br>那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 </p>\n<p>callback 函数会被依次传入三个参数：</p>\n<p>forEach(值,索引,数组对象本身)，默认只遍历值</p>\n<ul>\n<li>数组当前项的值；</li>\n<li>数组当前项的索引；</li>\n<li>数组对象本身；</li>\n</ul>\n<p>需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。<br>调用forEach 后添加到数组中的项不会被 callback 访问到。</p>\n<p>如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。<br>已删除的项不会被遍历到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [];</span><br><span class=\"line\">arr[0] = &quot;a&quot;;</span><br><span class=\"line\">arr[3] = &quot;b&quot;;</span><br><span class=\"line\">arr[10] = &quot;c&quot;;</span><br><span class=\"line\">arr.name = &quot;Hello world&quot;;</span><br><span class=\"line\">arr.forEach((data, index, array) =&gt; &#123;</span><br><span class=\"line\">    console.log(data, index, array);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a 0 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br><span class=\"line\">b 3 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br><span class=\"line\">c 10 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br></pre></td></tr></table></figure>\n<p>这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。</p>\n<p>所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。</p>\n<p>另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：</p>\n<ul>\n<li>every: 循环在第一次 return false 后返回</li>\n<li>some: 循环在第一次 return true 后返回</li>\n<li>filter: 返回一个新的数组，该数组内的元素满足回调函数</li>\n<li>map: 将原数组中的元素处理后再返回</li>\n<li>reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。</li>\n</ul>\n<p>forEach 性能：一般<br>forEach 的速度不如 for ，因为forEach会遍历所有元素，并一一进行回调。</p>"},{"title":"js函数理解","date":"2018-04-30T08:43:47.000Z","_content":"[toc]\n\n# 函数\n\n函数是一段代码，它只定义一次，但可以被执行或调用任意次。\n在 JavaScript 里，函数即对象，程序可以随意操控它们。\n（万物皆对象）\n\n## 函数定义\n\n在 JavaScript 中，函数实际上是对象，每个函数都是 Function 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。\n\n函数通常有以下3中定义方式。例如：\n\n<!-- more -->\n\n```\n// 写法一：函数声明（推荐写法）\nfunction sum (num1, num2) {\n    return num1 + num2;\n}\n\n// 写法二：函数表达式（推荐写法）\nvar sum = function(num1, num2){\n    return num1 + num2;\n};\n\n// 写法三：Function 构造函数（不推荐写法）\nvar sum = new Function(\"num1\", \"num2\", \"return num1 + num2\"); \n```\n\n>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。\n\n换句话说，一个函数可能会有多个名字。\n例如：\n\n```\nfunction sum(num1, num2){\n    return num1 + num2;\n}\nconsole.log(sum(10,10));        // 20\n\nvar anotherSum = sum;\nconsole.log(anotherSum(10,10)); // 20\n\nsum = null;\nconsole.log(anotherSum(10,10)); // 20\n```\n## 没有重载--函数名是指针\n\n将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。\n(因为改变函数体内容，只是指向改变，内存并没有清空)\n```\nfunction addSomeNumber(num){\n    return num + 100;\n}\n\nfunction addSomeNumber(num, num2) {\n    return num + 200;\n}\n\nvar result = addSomeNumber(100);    // 300\n```\n显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。\n以上代码实际上与下面的代码没有什么区别：\n(因为改变函数体内容，只是指向改变，内存并没有清空)\n```\nvar addSomeNumber = function (num){\n    return num + 100;\n};\n\naddSomeNumber = function (num, num2) {\n    return num + 200;\n};\n\nvar result = addSomeNumber(100);    // 300\n```\n\n## 函数声明与函数表达式--变量提升\n\n解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。\n解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；----变量提升\n至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。\n\n例如：\n```\nconsole.log(sum(10,10)); // 20\nfunction sum(num1, num2){\n    return num1 + num2;\n}\n```\n以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。\n```\nconsole.log(sum(10,10)); // Uncaught TypeError: sum is not a function\nvar sum = function(num1, num2){\n    return num1 + num2;\n};\n```\n\n## 作为值的函数\n\n因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。\n也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。\n```\nfunction callSomeFunction(someFunction, someArgument){\n    return someFunction(someArgument);\n}\n```\n这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。\n然后，就可以像下面的例子一样传递函数了。\n```\nfunction add10(num){\n    return num + 10;\n}\n\nvar result1 = callSomeFunction(add10, 10);\nconsole.log(result1);   // 20\n\nfunction getGreeting(name){\n    return \"Hello, \" + name;\n}\n\nvar result2 = callSomeFunction(getGreeting, \"Nicholas\");\nconsole.log(result2);   // \"Hello, Nicholas\"\n```\n\n## 函数的形参和实参\n\n在函数内部，有两个特殊的对象：arguments 和 this。\n其中，arguments 是一个类数组对象，包含着传入函数中的所有参数。\n虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。\n请看下面这个非常经典的阶乘函数。\n```\nfunction factorial(num){\n\tif (num <= 1) {\n        return 1;\n    } else {\n        return num * factorial(num-1)\n    }\n}\n```\n\n定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。\n但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。\n为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee\n```\nfunction factorial(num){\n    if (num <=1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num-1)\n    }\n}\n```\n在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial。\n这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。\n例如：\n```\n// 这里需要结合上一段代码\nvar trueFactorial = factorial;\n\nfactorial = function(){// 重置了factorial函数指向\n    return 0;\n};\n\nconsole.log(trueFactorial(5));  // 120\nconsole.log(factorial(5));      // 0\n```\n#### arguments用法：使用在函数体中，可用 `arguments.callee` 指向拥有这个 arguments 对象的函数。\n\n## 函数的属性和方法\n\nJavaScript 中的函数是对象，因此函数也有属性和方法。\n每个函数都包含两个属性：length 和 prototype。\n其中，length 属性表示函数希望接收的命名参数的个数，也就是形参个数。\n\n不过这不重要。\n\n接下来要说的才是属性与方法。\nJavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为：\n\n```\n/*apply()方法*/\nfunction.apply(thisObj[, argArray])\n\n/*call()方法*/\nfunction.call(thisObj[, arg1[, arg2[, [,...argN]]]]);\n```\n\n它们各自的定义：\n\n#### apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。\n>例如：B.apply(A, arguments);即A对象应用B对象的方法。\n\n#### call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。\n>例如：B.call(A, args1,args2);即A对象调用B对象的方法。\n\n它们的共同之处：\n都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。\n\n它们的不同之处：\n\napply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。\n如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。\n\ncall：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 \n\n实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。\n\n基本用法\n```\nfunction add(a,b){\n  return a+b;  \n}\nfunction sub(a,b){\n  return a-b;  \n}\nvar a1 = add.apply(sub,[4,2]);　　//sub应用add的方法\nvar a2 = sub.apply(add,[4,2]);\nalert(a1);  //6     \nalert(a2);  //2\n\n/*call的用法*/\nvar a2 = add.call(sub,4,2); //sub调用add的方法\nalert(a2); //6 \n```\n\n## 关卡：\n```\n// 挑战一，合并任意个数的字符串\nvar concat = function(){\n    var result = '';\n    for(var i = 0; i < arguments.length; i ++){ // 遍历arguments实参长度\n        result += arguments[i]; // 把所有实参元素累加\n    }\n    return result;\n}\nconsole.log(concat('st','on','e'));  // stone\n```\n","source":"_posts/js函数理解.md","raw":"---\ntitle: js函数理解\ndate: 2018-04-30 16:43:47\ncategories:\n  - JS学习笔记\ntags:\n  - 函数 js\n---\n[toc]\n\n# 函数\n\n函数是一段代码，它只定义一次，但可以被执行或调用任意次。\n在 JavaScript 里，函数即对象，程序可以随意操控它们。\n（万物皆对象）\n\n## 函数定义\n\n在 JavaScript 中，函数实际上是对象，每个函数都是 Function 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。\n\n函数通常有以下3中定义方式。例如：\n\n<!-- more -->\n\n```\n// 写法一：函数声明（推荐写法）\nfunction sum (num1, num2) {\n    return num1 + num2;\n}\n\n// 写法二：函数表达式（推荐写法）\nvar sum = function(num1, num2){\n    return num1 + num2;\n};\n\n// 写法三：Function 构造函数（不推荐写法）\nvar sum = new Function(\"num1\", \"num2\", \"return num1 + num2\"); \n```\n\n>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。\n\n换句话说，一个函数可能会有多个名字。\n例如：\n\n```\nfunction sum(num1, num2){\n    return num1 + num2;\n}\nconsole.log(sum(10,10));        // 20\n\nvar anotherSum = sum;\nconsole.log(anotherSum(10,10)); // 20\n\nsum = null;\nconsole.log(anotherSum(10,10)); // 20\n```\n## 没有重载--函数名是指针\n\n将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。\n(因为改变函数体内容，只是指向改变，内存并没有清空)\n```\nfunction addSomeNumber(num){\n    return num + 100;\n}\n\nfunction addSomeNumber(num, num2) {\n    return num + 200;\n}\n\nvar result = addSomeNumber(100);    // 300\n```\n显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。\n以上代码实际上与下面的代码没有什么区别：\n(因为改变函数体内容，只是指向改变，内存并没有清空)\n```\nvar addSomeNumber = function (num){\n    return num + 100;\n};\n\naddSomeNumber = function (num, num2) {\n    return num + 200;\n};\n\nvar result = addSomeNumber(100);    // 300\n```\n\n## 函数声明与函数表达式--变量提升\n\n解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。\n解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；----变量提升\n至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。\n\n例如：\n```\nconsole.log(sum(10,10)); // 20\nfunction sum(num1, num2){\n    return num1 + num2;\n}\n```\n以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。\n```\nconsole.log(sum(10,10)); // Uncaught TypeError: sum is not a function\nvar sum = function(num1, num2){\n    return num1 + num2;\n};\n```\n\n## 作为值的函数\n\n因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。\n也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。\n```\nfunction callSomeFunction(someFunction, someArgument){\n    return someFunction(someArgument);\n}\n```\n这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。\n然后，就可以像下面的例子一样传递函数了。\n```\nfunction add10(num){\n    return num + 10;\n}\n\nvar result1 = callSomeFunction(add10, 10);\nconsole.log(result1);   // 20\n\nfunction getGreeting(name){\n    return \"Hello, \" + name;\n}\n\nvar result2 = callSomeFunction(getGreeting, \"Nicholas\");\nconsole.log(result2);   // \"Hello, Nicholas\"\n```\n\n## 函数的形参和实参\n\n在函数内部，有两个特殊的对象：arguments 和 this。\n其中，arguments 是一个类数组对象，包含着传入函数中的所有参数。\n虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。\n请看下面这个非常经典的阶乘函数。\n```\nfunction factorial(num){\n\tif (num <= 1) {\n        return 1;\n    } else {\n        return num * factorial(num-1)\n    }\n}\n```\n\n定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。\n但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。\n为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee\n```\nfunction factorial(num){\n    if (num <=1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num-1)\n    }\n}\n```\n在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial。\n这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。\n例如：\n```\n// 这里需要结合上一段代码\nvar trueFactorial = factorial;\n\nfactorial = function(){// 重置了factorial函数指向\n    return 0;\n};\n\nconsole.log(trueFactorial(5));  // 120\nconsole.log(factorial(5));      // 0\n```\n#### arguments用法：使用在函数体中，可用 `arguments.callee` 指向拥有这个 arguments 对象的函数。\n\n## 函数的属性和方法\n\nJavaScript 中的函数是对象，因此函数也有属性和方法。\n每个函数都包含两个属性：length 和 prototype。\n其中，length 属性表示函数希望接收的命名参数的个数，也就是形参个数。\n\n不过这不重要。\n\n接下来要说的才是属性与方法。\nJavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为：\n\n```\n/*apply()方法*/\nfunction.apply(thisObj[, argArray])\n\n/*call()方法*/\nfunction.call(thisObj[, arg1[, arg2[, [,...argN]]]]);\n```\n\n它们各自的定义：\n\n#### apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。\n>例如：B.apply(A, arguments);即A对象应用B对象的方法。\n\n#### call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。\n>例如：B.call(A, args1,args2);即A对象调用B对象的方法。\n\n它们的共同之处：\n都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。\n\n它们的不同之处：\n\napply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。\n如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。\n\ncall：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 \n\n实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。\n\n基本用法\n```\nfunction add(a,b){\n  return a+b;  \n}\nfunction sub(a,b){\n  return a-b;  \n}\nvar a1 = add.apply(sub,[4,2]);　　//sub应用add的方法\nvar a2 = sub.apply(add,[4,2]);\nalert(a1);  //6     \nalert(a2);  //2\n\n/*call的用法*/\nvar a2 = add.call(sub,4,2); //sub调用add的方法\nalert(a2); //6 \n```\n\n## 关卡：\n```\n// 挑战一，合并任意个数的字符串\nvar concat = function(){\n    var result = '';\n    for(var i = 0; i < arguments.length; i ++){ // 遍历arguments实参长度\n        result += arguments[i]; // 把所有实参元素累加\n    }\n    return result;\n}\nconsole.log(concat('st','on','e'));  // stone\n```\n","slug":"js函数理解","published":1,"updated":"2019-06-16T08:31:35.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhev000c9kudwm0th5pa","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>函数是一段代码，它只定义一次，但可以被执行或调用任意次。<br>在 JavaScript 里，函数即对象，程序可以随意操控它们。<br>（万物皆对象）</p>\n<h2 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h2><p>在 JavaScript 中，函数实际上是对象，每个函数都是 Function 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>\n<p>函数通常有以下3中定义方式。例如：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 写法一：函数声明（推荐写法）</span><br><span class=\"line\">function sum (num1, num2) &#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法二：函数表达式（推荐写法）</span><br><span class=\"line\">var sum = function(num1, num2)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法三：Function 构造函数（不推荐写法）</span><br><span class=\"line\">var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。</p>\n</blockquote>\n<p>换句话说，一个函数可能会有多个名字。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sum(num1, num2)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(sum(10,10));        // 20</span><br><span class=\"line\"></span><br><span class=\"line\">var anotherSum = sum;</span><br><span class=\"line\">console.log(anotherSum(10,10)); // 20</span><br><span class=\"line\"></span><br><span class=\"line\">sum = null;</span><br><span class=\"line\">console.log(anotherSum(10,10)); // 20</span><br></pre></td></tr></table></figure>\n<h2 id=\"没有重载–函数名是指针\"><a href=\"#没有重载–函数名是指针\" class=\"headerlink\" title=\"没有重载–函数名是指针\"></a>没有重载–函数名是指针</h2><p>将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。<br>(因为改变函数体内容，只是指向改变，内存并没有清空)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addSomeNumber(num)&#123;</span><br><span class=\"line\">    return num + 100;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function addSomeNumber(num, num2) &#123;</span><br><span class=\"line\">    return num + 200;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result = addSomeNumber(100);    // 300</span><br></pre></td></tr></table></figure></p>\n<p>显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。<br>以上代码实际上与下面的代码没有什么区别：<br>(因为改变函数体内容，只是指向改变，内存并没有清空)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addSomeNumber = function (num)&#123;</span><br><span class=\"line\">    return num + 100;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">addSomeNumber = function (num, num2) &#123;</span><br><span class=\"line\">    return num + 200;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var result = addSomeNumber(100);    // 300</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数声明与函数表达式–变量提升\"><a href=\"#函数声明与函数表达式–变量提升\" class=\"headerlink\" title=\"函数声明与函数表达式–变量提升\"></a>函数声明与函数表达式–变量提升</h2><p>解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。<br>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；—-变量提升<br>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(sum(10,10)); // 20</span><br><span class=\"line\">function sum(num1, num2)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(sum(10,10)); // Uncaught TypeError: sum is not a function</span><br><span class=\"line\">var sum = function(num1, num2)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h2><p>因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。<br>也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function callSomeFunction(someFunction, someArgument)&#123;</span><br><span class=\"line\">    return someFunction(someArgument);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。<br>然后，就可以像下面的例子一样传递函数了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add10(num)&#123;</span><br><span class=\"line\">    return num + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result1 = callSomeFunction(add10, 10);</span><br><span class=\"line\">console.log(result1);   // 20</span><br><span class=\"line\"></span><br><span class=\"line\">function getGreeting(name)&#123;</span><br><span class=\"line\">    return &quot;Hello, &quot; + name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;);</span><br><span class=\"line\">console.log(result2);   // &quot;Hello, Nicholas&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数的形参和实参\"><a href=\"#函数的形参和实参\" class=\"headerlink\" title=\"函数的形参和实参\"></a>函数的形参和实参</h2><p>在函数内部，有两个特殊的对象：arguments 和 this。<br>其中，arguments 是一个类数组对象，包含着传入函数中的所有参数。<br>虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。<br>请看下面这个非常经典的阶乘函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(num)&#123;</span><br><span class=\"line\">\tif (num &lt;= 1) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return num * factorial(num-1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。<br>但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。<br>为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(num)&#123;</span><br><span class=\"line\">    if (num &lt;=1) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return num * arguments.callee(num-1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial。<br>这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这里需要结合上一段代码</span><br><span class=\"line\">var trueFactorial = factorial;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial = function()&#123;// 重置了factorial函数指向</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(trueFactorial(5));  // 120</span><br><span class=\"line\">console.log(factorial(5));      // 0</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"arguments用法：使用在函数体中，可用-arguments-callee-指向拥有这个-arguments-对象的函数。\"><a href=\"#arguments用法：使用在函数体中，可用-arguments-callee-指向拥有这个-arguments-对象的函数。\" class=\"headerlink\" title=\"arguments用法：使用在函数体中，可用 arguments.callee 指向拥有这个 arguments 对象的函数。\"></a>arguments用法：使用在函数体中，可用 <code>arguments.callee</code> 指向拥有这个 arguments 对象的函数。</h4><h2 id=\"函数的属性和方法\"><a href=\"#函数的属性和方法\" class=\"headerlink\" title=\"函数的属性和方法\"></a>函数的属性和方法</h2><p>JavaScript 中的函数是对象，因此函数也有属性和方法。<br>每个函数都包含两个属性：length 和 prototype。<br>其中，length 属性表示函数希望接收的命名参数的个数，也就是形参个数。</p>\n<p>不过这不重要。</p>\n<p>接下来要说的才是属性与方法。<br>JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*apply()方法*/</span><br><span class=\"line\">function.apply(thisObj[, argArray])</span><br><span class=\"line\"></span><br><span class=\"line\">/*call()方法*/</span><br><span class=\"line\">function.call(thisObj[, arg1[, arg2[, [,...argN]]]]);</span><br></pre></td></tr></table></figure>\n<p>它们各自的定义：</p>\n<h4 id=\"apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。\"><a href=\"#apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。\" class=\"headerlink\" title=\"apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。\"></a>apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。</h4><blockquote>\n<p>例如：B.apply(A, arguments);即A对象应用B对象的方法。</p>\n</blockquote>\n<h4 id=\"call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。\"><a href=\"#call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。\" class=\"headerlink\" title=\"call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。\"></a>call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。</h4><blockquote>\n<p>例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p>\n</blockquote>\n<p>它们的共同之处：<br>都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。</p>\n<p>它们的不同之处：</p>\n<p>apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。<br>如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。</p>\n<p>call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 </p>\n<p>实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。</p>\n<p>基本用法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(a,b)&#123;</span><br><span class=\"line\">  return a+b;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sub(a,b)&#123;</span><br><span class=\"line\">  return a-b;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = add.apply(sub,[4,2]);　　//sub应用add的方法</span><br><span class=\"line\">var a2 = sub.apply(add,[4,2]);</span><br><span class=\"line\">alert(a1);  //6     </span><br><span class=\"line\">alert(a2);  //2</span><br><span class=\"line\"></span><br><span class=\"line\">/*call的用法*/</span><br><span class=\"line\">var a2 = add.call(sub,4,2); //sub调用add的方法</span><br><span class=\"line\">alert(a2); //6</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关卡：\"><a href=\"#关卡：\" class=\"headerlink\" title=\"关卡：\"></a>关卡：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 挑战一，合并任意个数的字符串</span><br><span class=\"line\">var concat = function()&#123;</span><br><span class=\"line\">    var result = &apos;&apos;;</span><br><span class=\"line\">    for(var i = 0; i &lt; arguments.length; i ++)&#123; // 遍历arguments实参长度</span><br><span class=\"line\">        result += arguments[i]; // 把所有实参元素累加</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(concat(&apos;st&apos;,&apos;on&apos;,&apos;e&apos;));  // stone</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>函数是一段代码，它只定义一次，但可以被执行或调用任意次。<br>在 JavaScript 里，函数即对象，程序可以随意操控它们。<br>（万物皆对象）</p>\n<h2 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h2><p>在 JavaScript 中，函数实际上是对象，每个函数都是 Function 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>\n<p>函数通常有以下3中定义方式。例如：</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 写法一：函数声明（推荐写法）</span><br><span class=\"line\">function sum (num1, num2) &#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法二：函数表达式（推荐写法）</span><br><span class=\"line\">var sum = function(num1, num2)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 写法三：Function 构造函数（不推荐写法）</span><br><span class=\"line\">var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。</p>\n</blockquote>\n<p>换句话说，一个函数可能会有多个名字。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sum(num1, num2)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(sum(10,10));        // 20</span><br><span class=\"line\"></span><br><span class=\"line\">var anotherSum = sum;</span><br><span class=\"line\">console.log(anotherSum(10,10)); // 20</span><br><span class=\"line\"></span><br><span class=\"line\">sum = null;</span><br><span class=\"line\">console.log(anotherSum(10,10)); // 20</span><br></pre></td></tr></table></figure>\n<h2 id=\"没有重载–函数名是指针\"><a href=\"#没有重载–函数名是指针\" class=\"headerlink\" title=\"没有重载–函数名是指针\"></a>没有重载–函数名是指针</h2><p>将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。<br>(因为改变函数体内容，只是指向改变，内存并没有清空)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addSomeNumber(num)&#123;</span><br><span class=\"line\">    return num + 100;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function addSomeNumber(num, num2) &#123;</span><br><span class=\"line\">    return num + 200;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result = addSomeNumber(100);    // 300</span><br></pre></td></tr></table></figure></p>\n<p>显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。<br>以上代码实际上与下面的代码没有什么区别：<br>(因为改变函数体内容，只是指向改变，内存并没有清空)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var addSomeNumber = function (num)&#123;</span><br><span class=\"line\">    return num + 100;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">addSomeNumber = function (num, num2) &#123;</span><br><span class=\"line\">    return num + 200;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var result = addSomeNumber(100);    // 300</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数声明与函数表达式–变量提升\"><a href=\"#函数声明与函数表达式–变量提升\" class=\"headerlink\" title=\"函数声明与函数表达式–变量提升\"></a>函数声明与函数表达式–变量提升</h2><p>解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。<br>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；—-变量提升<br>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(sum(10,10)); // 20</span><br><span class=\"line\">function sum(num1, num2)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(sum(10,10)); // Uncaught TypeError: sum is not a function</span><br><span class=\"line\">var sum = function(num1, num2)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"作为值的函数\"><a href=\"#作为值的函数\" class=\"headerlink\" title=\"作为值的函数\"></a>作为值的函数</h2><p>因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。<br>也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function callSomeFunction(someFunction, someArgument)&#123;</span><br><span class=\"line\">    return someFunction(someArgument);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。<br>然后，就可以像下面的例子一样传递函数了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add10(num)&#123;</span><br><span class=\"line\">    return num + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result1 = callSomeFunction(add10, 10);</span><br><span class=\"line\">console.log(result1);   // 20</span><br><span class=\"line\"></span><br><span class=\"line\">function getGreeting(name)&#123;</span><br><span class=\"line\">    return &quot;Hello, &quot; + name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;);</span><br><span class=\"line\">console.log(result2);   // &quot;Hello, Nicholas&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数的形参和实参\"><a href=\"#函数的形参和实参\" class=\"headerlink\" title=\"函数的形参和实参\"></a>函数的形参和实参</h2><p>在函数内部，有两个特殊的对象：arguments 和 this。<br>其中，arguments 是一个类数组对象，包含着传入函数中的所有参数。<br>虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。<br>请看下面这个非常经典的阶乘函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(num)&#123;</span><br><span class=\"line\">\tif (num &lt;= 1) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return num * factorial(num-1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。<br>但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。<br>为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(num)&#123;</span><br><span class=\"line\">    if (num &lt;=1) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return num * arguments.callee(num-1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial。<br>这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这里需要结合上一段代码</span><br><span class=\"line\">var trueFactorial = factorial;</span><br><span class=\"line\"></span><br><span class=\"line\">factorial = function()&#123;// 重置了factorial函数指向</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(trueFactorial(5));  // 120</span><br><span class=\"line\">console.log(factorial(5));      // 0</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"arguments用法：使用在函数体中，可用-arguments-callee-指向拥有这个-arguments-对象的函数。\"><a href=\"#arguments用法：使用在函数体中，可用-arguments-callee-指向拥有这个-arguments-对象的函数。\" class=\"headerlink\" title=\"arguments用法：使用在函数体中，可用 arguments.callee 指向拥有这个 arguments 对象的函数。\"></a>arguments用法：使用在函数体中，可用 <code>arguments.callee</code> 指向拥有这个 arguments 对象的函数。</h4><h2 id=\"函数的属性和方法\"><a href=\"#函数的属性和方法\" class=\"headerlink\" title=\"函数的属性和方法\"></a>函数的属性和方法</h2><p>JavaScript 中的函数是对象，因此函数也有属性和方法。<br>每个函数都包含两个属性：length 和 prototype。<br>其中，length 属性表示函数希望接收的命名参数的个数，也就是形参个数。</p>\n<p>不过这不重要。</p>\n<p>接下来要说的才是属性与方法。<br>JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*apply()方法*/</span><br><span class=\"line\">function.apply(thisObj[, argArray])</span><br><span class=\"line\"></span><br><span class=\"line\">/*call()方法*/</span><br><span class=\"line\">function.call(thisObj[, arg1[, arg2[, [,...argN]]]]);</span><br></pre></td></tr></table></figure>\n<p>它们各自的定义：</p>\n<h4 id=\"apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。\"><a href=\"#apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。\" class=\"headerlink\" title=\"apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。\"></a>apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。</h4><blockquote>\n<p>例如：B.apply(A, arguments);即A对象应用B对象的方法。</p>\n</blockquote>\n<h4 id=\"call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。\"><a href=\"#call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。\" class=\"headerlink\" title=\"call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。\"></a>call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。</h4><blockquote>\n<p>例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p>\n</blockquote>\n<p>它们的共同之处：<br>都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。</p>\n<p>它们的不同之处：</p>\n<p>apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。<br>如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。</p>\n<p>call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 </p>\n<p>实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。</p>\n<p>基本用法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(a,b)&#123;</span><br><span class=\"line\">  return a+b;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function sub(a,b)&#123;</span><br><span class=\"line\">  return a-b;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a1 = add.apply(sub,[4,2]);　　//sub应用add的方法</span><br><span class=\"line\">var a2 = sub.apply(add,[4,2]);</span><br><span class=\"line\">alert(a1);  //6     </span><br><span class=\"line\">alert(a2);  //2</span><br><span class=\"line\"></span><br><span class=\"line\">/*call的用法*/</span><br><span class=\"line\">var a2 = add.call(sub,4,2); //sub调用add的方法</span><br><span class=\"line\">alert(a2); //6</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关卡：\"><a href=\"#关卡：\" class=\"headerlink\" title=\"关卡：\"></a>关卡：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 挑战一，合并任意个数的字符串</span><br><span class=\"line\">var concat = function()&#123;</span><br><span class=\"line\">    var result = &apos;&apos;;</span><br><span class=\"line\">    for(var i = 0; i &lt; arguments.length; i ++)&#123; // 遍历arguments实参长度</span><br><span class=\"line\">        result += arguments[i]; // 把所有实参元素累加</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(concat(&apos;st&apos;,&apos;on&apos;,&apos;e&apos;));  // stone</span><br></pre></td></tr></table></figure>"},{"title":"js对象理解","date":"2018-04-29T06:52:23.000Z","_content":"[toc]\n\n# 创建对象\n\n对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。\n\n JavaScript 的「三类对象」和「两类属性」进行区分：\n\n内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。\n宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。\n自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。\n\n自有属性（own property），是直接在对象中定义的属性。\n继承属性（inherited property），是在对象的原型对象中定义的属性。\n<!-- more -->\n\n## 使用对象字面量创建对象（推荐）\n\n```\n// 推荐写法\nvar person = {\n    name : \"stone\",\n    age : 28\n};\n\n// 也可以写成\nvar person = {};\nperson.name = \"stone\";\nperson.age = 28;\n```\n\n## 使用 `new` 关键字创建对象\n\n`new` 关键字`创建并初始化`一个新对象。关键字 new 后跟随一个`函数调用`。\n这里的函数称做构造函数（constructor），`构造函数用以初始化一个新创建的对象`。\nJavaScript 语言核心中的原始类型都包含内置构造函数。例如：\n```\nvar person = new Object();\nperson.name = \"stone\";\nperson.age = 28;\n```\n- 只要在 `new` 后面跟随一个已创建的对象，就可以继承它的原型属性。 \n\n## 使用 `Object.create()` 函数创建对象\n\n`Object.create()` 创建一个具有指定原型且可选择性地包含指定属性的对象。\n\n>Object.create(prototype, descriptors)\n\n参数\nprototype\n必需。  要用作原型的对象。  可以为 null。  \ndescriptors\n可选。  包含一个或多个属性描述符的 JavaScript 对象。  \n“数据属性”是可获取且可设置值的属性。\n数据属性描述符包含 value(值) 特性，以及 writable(可写)、enumerable（可枚举） 和 configurable（可配置） 特性。\n如果未指定最后三个特性，则它们默认为 false。\n只要检索或设置该值，“访问器属性”就会调用用户提供的函数。\n访问器属性描述符包含 set 特性和/或 get 特性。\n\n下面的示例创建使用 null 原型的对象并添加两个可枚举的属性。\n\n```\nvar newObj = Object.create(null, {\n            size: {\n                value: \"large\",\n                enumerable: true\n            },\n            shape: {\n                value: \"round\",\n                enumerable: true\n            }\n        });\n\nconsole.log(newObj.size + \"<br/>\");\nconsole.log(newObj.shape + \"<br/>\");\nconsole.log(Object.getPrototypeOf(newObj));\n\n// Object.getPrototypeOf 函数可获取原始对象的原型。\n\n// 输出(Output):\n// large\n// round\n// null\n```\n\n## 原型（prototype）\n\n所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。\nObject.prototype 是所有对象的原型对象，也是原型链终点，但是它默认是null的。\nObject.prototype.__proto__为null （普通的对象）\nObject.prototype 的存在价值就是象征Object类型本身,是根对象\n\n通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。\n\n因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。\n同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。\n\n没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。\n其他原型对象都是普通对象，普通对象都具有原型。\n\n所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。\n例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。\n\n这一系列链接的原型对象就是所谓的「原型链（prototype chain）」。\n\n#### 注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（__proto__）属性\n\n函数的prototype属性:在定义函数时自动添加的,默认值是一个空的Object对象\n对象的__proto__属性:创建对象是自动创建、添加的,默认值为其对应构造函数的prototype属性值\n\n## 属性的查询和设置\n```\n//设置\nperson.name = \"sophie\"; // 赋值\n//查询\nconsole.log(person.name);   // \"sophie\"\n```\n\n## 属性的访问错误\n\n查询一个不存在的属性并不会报错，如果不存在，则返回undefined\n\n## 删除属性\nJavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。\n\nin 运算符的左侧是属性名（字符串），右侧是对象。\n如果对象的自有属性或继承属性中包含这个属性则返回 true。\n\n```\nvar o = { x: 1 }\nconsole.log(\"x\" in o);          // true，x是o的属性\nconsole.log(\"y\" in o);          // false，y不是o的属性\nconsole.log(\"toString\" in o);   // true，toString是继承属性\n```\n\n除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined\n\n `hasOwnProperty()` 方法用来检测给定的名字是否是对象的`自有属性`。\n对于继承属性它将返回 false。\n\n`propertyIsEnumerable()` 检测对象有`自有属性`且`可枚举性`为 true 时它才返回 true。\n\n## 枚举属性\n\n除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。\n\nfor-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。\n对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如：\n```\nvar o = {x:1, y:2, z:3};            // 三个可枚举的自有属性\no.propertyIsEnumerable(\"toString\"); // false，内置方法不可枚举\nfor (p in o) {          // 遍历属性\n    console.log(p);     // 输出x、y和z，不会输出toString\n}\n```\n\n有许多实用工具库给 Object.prototype 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。\n\n为了过滤继承的属性，我们可以对 for-in 进行改造\n只许加入两个判断\nhasOwnProperty()\n这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。\ntypeof 判断对象类型\n```\nfor(p in o) {\n   if (!o.hasOwnProperty(p)) continue;          // 跳过继承的属性\n   if (typeof o[p] === \"function\") continue;    // 跳过函数方法\n}\n```\n\n除了 for-in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。\n\n第一个是 Object.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。\n\n第二个是 Object.getOwnPropertyNames()，它和 Ojbect.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。\n\n## 属性的 getter 和 setter\n\n由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」\n它不同于「数据属性（data property）」，数据属性只有一个简单的值。\n并且和数据属性不同，存取器属性不具有可写性（writable attribute）。\n\n```\nvar o = {\n    // 普通的数据属性\n    data_prop: value,\n\n    // 存取器属性都是成对定义的函数\n    get accessor_prop() { /*这里是函数体 */ },\n    set accessor_prop(value) { /* 这里是函数体*/ }\n};\n```\n\n存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。\n注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。\n\n## 序列化对象（JSON）\n对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。\nJSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串\nJSON.parse() 用于将一个 JSON 字符串转换为对象。\n\n## 关卡\n\n[枚举题](https://github.com/stone0090/javascript-lessons/blob/master/1.7-ObjectObjects/Answer.md)\n\n# 总结\n\n创建对象的三种方式，在默认情况下，都一样。\n但是在涉及原型的情况下 new 和 create() ，就产生了区别。至于字面量方法，则是无法继承原型。\n\n`new` 关键字`创建并初始化`一个新对象。\n关键字 `new` 后跟随一个`函数调用`，新对象会继承它的原型属性。\n\n工厂模式、构造函数模式、原型模式等……面向对象常用语法\n\n`Object.create()` 创建一个具有`指定原型`且`可选择性地包含指定属性`的对象。\n\nnew的高级应用？\n","source":"_posts/js对象理解.md","raw":"---\ntitle: js对象理解\ndate: 2018-04-29 14:52:23\ncategories:\n  - JS学习笔记\ntags:\n  - 对象 js\n---\n[toc]\n\n# 创建对象\n\n对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。\n\n JavaScript 的「三类对象」和「两类属性」进行区分：\n\n内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。\n宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。\n自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。\n\n自有属性（own property），是直接在对象中定义的属性。\n继承属性（inherited property），是在对象的原型对象中定义的属性。\n<!-- more -->\n\n## 使用对象字面量创建对象（推荐）\n\n```\n// 推荐写法\nvar person = {\n    name : \"stone\",\n    age : 28\n};\n\n// 也可以写成\nvar person = {};\nperson.name = \"stone\";\nperson.age = 28;\n```\n\n## 使用 `new` 关键字创建对象\n\n`new` 关键字`创建并初始化`一个新对象。关键字 new 后跟随一个`函数调用`。\n这里的函数称做构造函数（constructor），`构造函数用以初始化一个新创建的对象`。\nJavaScript 语言核心中的原始类型都包含内置构造函数。例如：\n```\nvar person = new Object();\nperson.name = \"stone\";\nperson.age = 28;\n```\n- 只要在 `new` 后面跟随一个已创建的对象，就可以继承它的原型属性。 \n\n## 使用 `Object.create()` 函数创建对象\n\n`Object.create()` 创建一个具有指定原型且可选择性地包含指定属性的对象。\n\n>Object.create(prototype, descriptors)\n\n参数\nprototype\n必需。  要用作原型的对象。  可以为 null。  \ndescriptors\n可选。  包含一个或多个属性描述符的 JavaScript 对象。  \n“数据属性”是可获取且可设置值的属性。\n数据属性描述符包含 value(值) 特性，以及 writable(可写)、enumerable（可枚举） 和 configurable（可配置） 特性。\n如果未指定最后三个特性，则它们默认为 false。\n只要检索或设置该值，“访问器属性”就会调用用户提供的函数。\n访问器属性描述符包含 set 特性和/或 get 特性。\n\n下面的示例创建使用 null 原型的对象并添加两个可枚举的属性。\n\n```\nvar newObj = Object.create(null, {\n            size: {\n                value: \"large\",\n                enumerable: true\n            },\n            shape: {\n                value: \"round\",\n                enumerable: true\n            }\n        });\n\nconsole.log(newObj.size + \"<br/>\");\nconsole.log(newObj.shape + \"<br/>\");\nconsole.log(Object.getPrototypeOf(newObj));\n\n// Object.getPrototypeOf 函数可获取原始对象的原型。\n\n// 输出(Output):\n// large\n// round\n// null\n```\n\n## 原型（prototype）\n\n所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。\nObject.prototype 是所有对象的原型对象，也是原型链终点，但是它默认是null的。\nObject.prototype.__proto__为null （普通的对象）\nObject.prototype 的存在价值就是象征Object类型本身,是根对象\n\n通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。\n\n因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。\n同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。\n\n没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。\n其他原型对象都是普通对象，普通对象都具有原型。\n\n所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。\n例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。\n\n这一系列链接的原型对象就是所谓的「原型链（prototype chain）」。\n\n#### 注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（__proto__）属性\n\n函数的prototype属性:在定义函数时自动添加的,默认值是一个空的Object对象\n对象的__proto__属性:创建对象是自动创建、添加的,默认值为其对应构造函数的prototype属性值\n\n## 属性的查询和设置\n```\n//设置\nperson.name = \"sophie\"; // 赋值\n//查询\nconsole.log(person.name);   // \"sophie\"\n```\n\n## 属性的访问错误\n\n查询一个不存在的属性并不会报错，如果不存在，则返回undefined\n\n## 删除属性\nJavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。\n\nin 运算符的左侧是属性名（字符串），右侧是对象。\n如果对象的自有属性或继承属性中包含这个属性则返回 true。\n\n```\nvar o = { x: 1 }\nconsole.log(\"x\" in o);          // true，x是o的属性\nconsole.log(\"y\" in o);          // false，y不是o的属性\nconsole.log(\"toString\" in o);   // true，toString是继承属性\n```\n\n除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined\n\n `hasOwnProperty()` 方法用来检测给定的名字是否是对象的`自有属性`。\n对于继承属性它将返回 false。\n\n`propertyIsEnumerable()` 检测对象有`自有属性`且`可枚举性`为 true 时它才返回 true。\n\n## 枚举属性\n\n除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。\n\nfor-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。\n对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如：\n```\nvar o = {x:1, y:2, z:3};            // 三个可枚举的自有属性\no.propertyIsEnumerable(\"toString\"); // false，内置方法不可枚举\nfor (p in o) {          // 遍历属性\n    console.log(p);     // 输出x、y和z，不会输出toString\n}\n```\n\n有许多实用工具库给 Object.prototype 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。\n\n为了过滤继承的属性，我们可以对 for-in 进行改造\n只许加入两个判断\nhasOwnProperty()\n这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。\ntypeof 判断对象类型\n```\nfor(p in o) {\n   if (!o.hasOwnProperty(p)) continue;          // 跳过继承的属性\n   if (typeof o[p] === \"function\") continue;    // 跳过函数方法\n}\n```\n\n除了 for-in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。\n\n第一个是 Object.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。\n\n第二个是 Object.getOwnPropertyNames()，它和 Ojbect.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。\n\n## 属性的 getter 和 setter\n\n由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」\n它不同于「数据属性（data property）」，数据属性只有一个简单的值。\n并且和数据属性不同，存取器属性不具有可写性（writable attribute）。\n\n```\nvar o = {\n    // 普通的数据属性\n    data_prop: value,\n\n    // 存取器属性都是成对定义的函数\n    get accessor_prop() { /*这里是函数体 */ },\n    set accessor_prop(value) { /* 这里是函数体*/ }\n};\n```\n\n存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。\n注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。\n\n## 序列化对象（JSON）\n对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。\nJSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串\nJSON.parse() 用于将一个 JSON 字符串转换为对象。\n\n## 关卡\n\n[枚举题](https://github.com/stone0090/javascript-lessons/blob/master/1.7-ObjectObjects/Answer.md)\n\n# 总结\n\n创建对象的三种方式，在默认情况下，都一样。\n但是在涉及原型的情况下 new 和 create() ，就产生了区别。至于字面量方法，则是无法继承原型。\n\n`new` 关键字`创建并初始化`一个新对象。\n关键字 `new` 后跟随一个`函数调用`，新对象会继承它的原型属性。\n\n工厂模式、构造函数模式、原型模式等……面向对象常用语法\n\n`Object.create()` 创建一个具有`指定原型`且`可选择性地包含指定属性`的对象。\n\nnew的高级应用？\n","slug":"js对象理解","published":1,"updated":"2019-04-07T14:56:55.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhex000d9kud9c65z7lm","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h1 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h1><p>对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。</p>\n<p> JavaScript 的「三类对象」和「两类属性」进行区分：</p>\n<p>内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。<br>宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。<br>自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。</p>\n<p>自有属性（own property），是直接在对象中定义的属性。<br>继承属性（inherited property），是在对象的原型对象中定义的属性。<br><a id=\"more\"></a></p>\n<h2 id=\"使用对象字面量创建对象（推荐）\"><a href=\"#使用对象字面量创建对象（推荐）\" class=\"headerlink\" title=\"使用对象字面量创建对象（推荐）\"></a>使用对象字面量创建对象（推荐）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 推荐写法</span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name : &quot;stone&quot;,</span><br><span class=\"line\">    age : 28</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 也可以写成</span><br><span class=\"line\">var person = &#123;&#125;;</span><br><span class=\"line\">person.name = &quot;stone&quot;;</span><br><span class=\"line\">person.age = 28;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-new-关键字创建对象\"><a href=\"#使用-new-关键字创建对象\" class=\"headerlink\" title=\"使用 new 关键字创建对象\"></a>使用 <code>new</code> 关键字创建对象</h2><p><code>new</code> 关键字<code>创建并初始化</code>一个新对象。关键字 new 后跟随一个<code>函数调用</code>。<br>这里的函数称做构造函数（constructor），<code>构造函数用以初始化一个新创建的对象</code>。<br>JavaScript 语言核心中的原始类型都包含内置构造函数。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = new Object();</span><br><span class=\"line\">person.name = &quot;stone&quot;;</span><br><span class=\"line\">person.age = 28;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>只要在 <code>new</code> 后面跟随一个已创建的对象，就可以继承它的原型属性。 </li>\n</ul>\n<h2 id=\"使用-Object-create-函数创建对象\"><a href=\"#使用-Object-create-函数创建对象\" class=\"headerlink\" title=\"使用 Object.create() 函数创建对象\"></a>使用 <code>Object.create()</code> 函数创建对象</h2><p><code>Object.create()</code> 创建一个具有指定原型且可选择性地包含指定属性的对象。</p>\n<blockquote>\n<p>Object.create(prototype, descriptors)</p>\n</blockquote>\n<p>参数<br>prototype<br>必需。  要用作原型的对象。  可以为 null。<br>descriptors<br>可选。  包含一个或多个属性描述符的 JavaScript 对象。<br>“数据属性”是可获取且可设置值的属性。<br>数据属性描述符包含 value(值) 特性，以及 writable(可写)、enumerable（可枚举） 和 configurable（可配置） 特性。<br>如果未指定最后三个特性，则它们默认为 false。<br>只要检索或设置该值，“访问器属性”就会调用用户提供的函数。<br>访问器属性描述符包含 set 特性和/或 get 特性。</p>\n<p>下面的示例创建使用 null 原型的对象并添加两个可枚举的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newObj = Object.create(null, &#123;</span><br><span class=\"line\">            size: &#123;</span><br><span class=\"line\">                value: &quot;large&quot;,</span><br><span class=\"line\">                enumerable: true</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            shape: &#123;</span><br><span class=\"line\">                value: &quot;round&quot;,</span><br><span class=\"line\">                enumerable: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(newObj.size + &quot;&lt;br/&gt;&quot;);</span><br><span class=\"line\">console.log(newObj.shape + &quot;&lt;br/&gt;&quot;);</span><br><span class=\"line\">console.log(Object.getPrototypeOf(newObj));</span><br><span class=\"line\"></span><br><span class=\"line\">// Object.getPrototypeOf 函数可获取原始对象的原型。</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出(Output):</span><br><span class=\"line\">// large</span><br><span class=\"line\">// round</span><br><span class=\"line\">// null</span><br></pre></td></tr></table></figure>\n<h2 id=\"原型（prototype）\"><a href=\"#原型（prototype）\" class=\"headerlink\" title=\"原型（prototype）\"></a>原型（prototype）</h2><p>所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。<br>Object.prototype 是所有对象的原型对象，也是原型链终点，但是它默认是null的。<br>Object.prototype.<strong>proto</strong>为null （普通的对象）<br>Object.prototype 的存在价值就是象征Object类型本身,是根对象</p>\n<p>通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。</p>\n<p>因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。<br>同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。</p>\n<p>没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。<br>其他原型对象都是普通对象，普通对象都具有原型。</p>\n<p>所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。<br>例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。</p>\n<p>这一系列链接的原型对象就是所谓的「原型链（prototype chain）」。</p>\n<h4 id=\"注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性\"><a href=\"#注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性\" class=\"headerlink\" title=\"注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性\"></a>注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（<strong>proto</strong>）属性</h4><p>函数的prototype属性:在定义函数时自动添加的,默认值是一个空的Object对象<br>对象的<strong>proto</strong>属性:创建对象是自动创建、添加的,默认值为其对应构造函数的prototype属性值</p>\n<h2 id=\"属性的查询和设置\"><a href=\"#属性的查询和设置\" class=\"headerlink\" title=\"属性的查询和设置\"></a>属性的查询和设置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置</span><br><span class=\"line\">person.name = &quot;sophie&quot;; // 赋值</span><br><span class=\"line\">//查询</span><br><span class=\"line\">console.log(person.name);   // &quot;sophie&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"属性的访问错误\"><a href=\"#属性的访问错误\" class=\"headerlink\" title=\"属性的访问错误\"></a>属性的访问错误</h2><p>查询一个不存在的属性并不会报错，如果不存在，则返回undefined</p>\n<h2 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h2><p>JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p>\n<p>in 运算符的左侧是属性名（字符串），右侧是对象。<br>如果对象的自有属性或继承属性中包含这个属性则返回 true。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123; x: 1 &#125;</span><br><span class=\"line\">console.log(&quot;x&quot; in o);          // true，x是o的属性</span><br><span class=\"line\">console.log(&quot;y&quot; in o);          // false，y不是o的属性</span><br><span class=\"line\">console.log(&quot;toString&quot; in o);   // true，toString是继承属性</span><br></pre></td></tr></table></figure>\n<p>除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined</p>\n<p> <code>hasOwnProperty()</code> 方法用来检测给定的名字是否是对象的<code>自有属性</code>。<br>对于继承属性它将返回 false。</p>\n<p><code>propertyIsEnumerable()</code> 检测对象有<code>自有属性</code>且<code>可枚举性</code>为 true 时它才返回 true。</p>\n<h2 id=\"枚举属性\"><a href=\"#枚举属性\" class=\"headerlink\" title=\"枚举属性\"></a>枚举属性</h2><p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。</p>\n<p>for-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。<br>对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123;x:1, y:2, z:3&#125;;            // 三个可枚举的自有属性</span><br><span class=\"line\">o.propertyIsEnumerable(&quot;toString&quot;); // false，内置方法不可枚举</span><br><span class=\"line\">for (p in o) &#123;          // 遍历属性</span><br><span class=\"line\">    console.log(p);     // 输出x、y和z，不会输出toString</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有许多实用工具库给 Object.prototype 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。</p>\n<p>为了过滤继承的属性，我们可以对 for-in 进行改造<br>只许加入两个判断<br>hasOwnProperty()<br>这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。<br>typeof 判断对象类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(p in o) &#123;</span><br><span class=\"line\">   if (!o.hasOwnProperty(p)) continue;          // 跳过继承的属性</span><br><span class=\"line\">   if (typeof o[p] === &quot;function&quot;) continue;    // 跳过函数方法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了 for-in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。</p>\n<p>第一个是 Object.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。</p>\n<p>第二个是 Object.getOwnPropertyNames()，它和 Ojbect.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。</p>\n<h2 id=\"属性的-getter-和-setter\"><a href=\"#属性的-getter-和-setter\" class=\"headerlink\" title=\"属性的 getter 和 setter\"></a>属性的 getter 和 setter</h2><p>由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」<br>它不同于「数据属性（data property）」，数据属性只有一个简单的值。<br>并且和数据属性不同，存取器属性不具有可写性（writable attribute）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123;</span><br><span class=\"line\">    // 普通的数据属性</span><br><span class=\"line\">    data_prop: value,</span><br><span class=\"line\"></span><br><span class=\"line\">    // 存取器属性都是成对定义的函数</span><br><span class=\"line\">    get accessor_prop() &#123; /*这里是函数体 */ &#125;,</span><br><span class=\"line\">    set accessor_prop(value) &#123; /* 这里是函数体*/ &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。<br>注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。</p>\n<h2 id=\"序列化对象（JSON）\"><a href=\"#序列化对象（JSON）\" class=\"headerlink\" title=\"序列化对象（JSON）\"></a>序列化对象（JSON）</h2><p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。<br>JSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串<br>JSON.parse() 用于将一个 JSON 字符串转换为对象。</p>\n<h2 id=\"关卡\"><a href=\"#关卡\" class=\"headerlink\" title=\"关卡\"></a>关卡</h2><p><a href=\"https://github.com/stone0090/javascript-lessons/blob/master/1.7-ObjectObjects/Answer.md\" target=\"_blank\" rel=\"noopener\">枚举题</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>创建对象的三种方式，在默认情况下，都一样。<br>但是在涉及原型的情况下 new 和 create() ，就产生了区别。至于字面量方法，则是无法继承原型。</p>\n<p><code>new</code> 关键字<code>创建并初始化</code>一个新对象。<br>关键字 <code>new</code> 后跟随一个<code>函数调用</code>，新对象会继承它的原型属性。</p>\n<p>工厂模式、构造函数模式、原型模式等……面向对象常用语法</p>\n<p><code>Object.create()</code> 创建一个具有<code>指定原型</code>且<code>可选择性地包含指定属性</code>的对象。</p>\n<p>new的高级应用？</p>\n","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h1 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h1><p>对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。</p>\n<p> JavaScript 的「三类对象」和「两类属性」进行区分：</p>\n<p>内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。<br>宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。<br>自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。</p>\n<p>自有属性（own property），是直接在对象中定义的属性。<br>继承属性（inherited property），是在对象的原型对象中定义的属性。<br>","more":"</p>\n<h2 id=\"使用对象字面量创建对象（推荐）\"><a href=\"#使用对象字面量创建对象（推荐）\" class=\"headerlink\" title=\"使用对象字面量创建对象（推荐）\"></a>使用对象字面量创建对象（推荐）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 推荐写法</span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name : &quot;stone&quot;,</span><br><span class=\"line\">    age : 28</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 也可以写成</span><br><span class=\"line\">var person = &#123;&#125;;</span><br><span class=\"line\">person.name = &quot;stone&quot;;</span><br><span class=\"line\">person.age = 28;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-new-关键字创建对象\"><a href=\"#使用-new-关键字创建对象\" class=\"headerlink\" title=\"使用 new 关键字创建对象\"></a>使用 <code>new</code> 关键字创建对象</h2><p><code>new</code> 关键字<code>创建并初始化</code>一个新对象。关键字 new 后跟随一个<code>函数调用</code>。<br>这里的函数称做构造函数（constructor），<code>构造函数用以初始化一个新创建的对象</code>。<br>JavaScript 语言核心中的原始类型都包含内置构造函数。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = new Object();</span><br><span class=\"line\">person.name = &quot;stone&quot;;</span><br><span class=\"line\">person.age = 28;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>只要在 <code>new</code> 后面跟随一个已创建的对象，就可以继承它的原型属性。 </li>\n</ul>\n<h2 id=\"使用-Object-create-函数创建对象\"><a href=\"#使用-Object-create-函数创建对象\" class=\"headerlink\" title=\"使用 Object.create() 函数创建对象\"></a>使用 <code>Object.create()</code> 函数创建对象</h2><p><code>Object.create()</code> 创建一个具有指定原型且可选择性地包含指定属性的对象。</p>\n<blockquote>\n<p>Object.create(prototype, descriptors)</p>\n</blockquote>\n<p>参数<br>prototype<br>必需。  要用作原型的对象。  可以为 null。<br>descriptors<br>可选。  包含一个或多个属性描述符的 JavaScript 对象。<br>“数据属性”是可获取且可设置值的属性。<br>数据属性描述符包含 value(值) 特性，以及 writable(可写)、enumerable（可枚举） 和 configurable（可配置） 特性。<br>如果未指定最后三个特性，则它们默认为 false。<br>只要检索或设置该值，“访问器属性”就会调用用户提供的函数。<br>访问器属性描述符包含 set 特性和/或 get 特性。</p>\n<p>下面的示例创建使用 null 原型的对象并添加两个可枚举的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newObj = Object.create(null, &#123;</span><br><span class=\"line\">            size: &#123;</span><br><span class=\"line\">                value: &quot;large&quot;,</span><br><span class=\"line\">                enumerable: true</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            shape: &#123;</span><br><span class=\"line\">                value: &quot;round&quot;,</span><br><span class=\"line\">                enumerable: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(newObj.size + &quot;&lt;br/&gt;&quot;);</span><br><span class=\"line\">console.log(newObj.shape + &quot;&lt;br/&gt;&quot;);</span><br><span class=\"line\">console.log(Object.getPrototypeOf(newObj));</span><br><span class=\"line\"></span><br><span class=\"line\">// Object.getPrototypeOf 函数可获取原始对象的原型。</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出(Output):</span><br><span class=\"line\">// large</span><br><span class=\"line\">// round</span><br><span class=\"line\">// null</span><br></pre></td></tr></table></figure>\n<h2 id=\"原型（prototype）\"><a href=\"#原型（prototype）\" class=\"headerlink\" title=\"原型（prototype）\"></a>原型（prototype）</h2><p>所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。<br>Object.prototype 是所有对象的原型对象，也是原型链终点，但是它默认是null的。<br>Object.prototype.<strong>proto</strong>为null （普通的对象）<br>Object.prototype 的存在价值就是象征Object类型本身,是根对象</p>\n<p>通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。</p>\n<p>因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。<br>同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。</p>\n<p>没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。<br>其他原型对象都是普通对象，普通对象都具有原型。</p>\n<p>所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。<br>例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。</p>\n<p>这一系列链接的原型对象就是所谓的「原型链（prototype chain）」。</p>\n<h4 id=\"注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性\"><a href=\"#注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性\" class=\"headerlink\" title=\"注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性\"></a>注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（<strong>proto</strong>）属性</h4><p>函数的prototype属性:在定义函数时自动添加的,默认值是一个空的Object对象<br>对象的<strong>proto</strong>属性:创建对象是自动创建、添加的,默认值为其对应构造函数的prototype属性值</p>\n<h2 id=\"属性的查询和设置\"><a href=\"#属性的查询和设置\" class=\"headerlink\" title=\"属性的查询和设置\"></a>属性的查询和设置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置</span><br><span class=\"line\">person.name = &quot;sophie&quot;; // 赋值</span><br><span class=\"line\">//查询</span><br><span class=\"line\">console.log(person.name);   // &quot;sophie&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"属性的访问错误\"><a href=\"#属性的访问错误\" class=\"headerlink\" title=\"属性的访问错误\"></a>属性的访问错误</h2><p>查询一个不存在的属性并不会报错，如果不存在，则返回undefined</p>\n<h2 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h2><p>JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p>\n<p>in 运算符的左侧是属性名（字符串），右侧是对象。<br>如果对象的自有属性或继承属性中包含这个属性则返回 true。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123; x: 1 &#125;</span><br><span class=\"line\">console.log(&quot;x&quot; in o);          // true，x是o的属性</span><br><span class=\"line\">console.log(&quot;y&quot; in o);          // false，y不是o的属性</span><br><span class=\"line\">console.log(&quot;toString&quot; in o);   // true，toString是继承属性</span><br></pre></td></tr></table></figure>\n<p>除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined</p>\n<p> <code>hasOwnProperty()</code> 方法用来检测给定的名字是否是对象的<code>自有属性</code>。<br>对于继承属性它将返回 false。</p>\n<p><code>propertyIsEnumerable()</code> 检测对象有<code>自有属性</code>且<code>可枚举性</code>为 true 时它才返回 true。</p>\n<h2 id=\"枚举属性\"><a href=\"#枚举属性\" class=\"headerlink\" title=\"枚举属性\"></a>枚举属性</h2><p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。</p>\n<p>for-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。<br>对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123;x:1, y:2, z:3&#125;;            // 三个可枚举的自有属性</span><br><span class=\"line\">o.propertyIsEnumerable(&quot;toString&quot;); // false，内置方法不可枚举</span><br><span class=\"line\">for (p in o) &#123;          // 遍历属性</span><br><span class=\"line\">    console.log(p);     // 输出x、y和z，不会输出toString</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有许多实用工具库给 Object.prototype 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。</p>\n<p>为了过滤继承的属性，我们可以对 for-in 进行改造<br>只许加入两个判断<br>hasOwnProperty()<br>这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。<br>typeof 判断对象类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(p in o) &#123;</span><br><span class=\"line\">   if (!o.hasOwnProperty(p)) continue;          // 跳过继承的属性</span><br><span class=\"line\">   if (typeof o[p] === &quot;function&quot;) continue;    // 跳过函数方法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>除了 for-in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。</p>\n<p>第一个是 Object.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。</p>\n<p>第二个是 Object.getOwnPropertyNames()，它和 Ojbect.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。</p>\n<h2 id=\"属性的-getter-和-setter\"><a href=\"#属性的-getter-和-setter\" class=\"headerlink\" title=\"属性的 getter 和 setter\"></a>属性的 getter 和 setter</h2><p>由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」<br>它不同于「数据属性（data property）」，数据属性只有一个简单的值。<br>并且和数据属性不同，存取器属性不具有可写性（writable attribute）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = &#123;</span><br><span class=\"line\">    // 普通的数据属性</span><br><span class=\"line\">    data_prop: value,</span><br><span class=\"line\"></span><br><span class=\"line\">    // 存取器属性都是成对定义的函数</span><br><span class=\"line\">    get accessor_prop() &#123; /*这里是函数体 */ &#125;,</span><br><span class=\"line\">    set accessor_prop(value) &#123; /* 这里是函数体*/ &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。<br>注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。</p>\n<h2 id=\"序列化对象（JSON）\"><a href=\"#序列化对象（JSON）\" class=\"headerlink\" title=\"序列化对象（JSON）\"></a>序列化对象（JSON）</h2><p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。<br>JSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串<br>JSON.parse() 用于将一个 JSON 字符串转换为对象。</p>\n<h2 id=\"关卡\"><a href=\"#关卡\" class=\"headerlink\" title=\"关卡\"></a>关卡</h2><p><a href=\"https://github.com/stone0090/javascript-lessons/blob/master/1.7-ObjectObjects/Answer.md\" target=\"_blank\" rel=\"noopener\">枚举题</a></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>创建对象的三种方式，在默认情况下，都一样。<br>但是在涉及原型的情况下 new 和 create() ，就产生了区别。至于字面量方法，则是无法继承原型。</p>\n<p><code>new</code> 关键字<code>创建并初始化</code>一个新对象。<br>关键字 <code>new</code> 后跟随一个<code>函数调用</code>，新对象会继承它的原型属性。</p>\n<p>工厂模式、构造函数模式、原型模式等……面向对象常用语法</p>\n<p><code>Object.create()</code> 创建一个具有<code>指定原型</code>且<code>可选择性地包含指定属性</code>的对象。</p>\n<p>new的高级应用？</p>"},{"title":"js数组方法","date":"2018-04-29T08:55:21.000Z","_content":"[toc]\n\n## 使用数组字面量创建数组（推荐）\n```\nvar empty = [];\n```\n## 使用 `new` 关键字创建数组\n\n使用 new 关键字调用构造函数 Array() 是创建数组的另一种方法。\n我们可以用三种方式调用构造函数。例如：\n<!-- more -->\n```\n// 调用时没有参数\nvar a = new Array();\n\n// 调用时有一个数值参数，它指定长度\nvar a = new Array(10); \n\n// 显式指定多个数组元素或者数组的一个非数值元素\nvar a = new Array(5, 4, 3, 2, 1, \"testing\");\n```\n\n## 稀疏数组\n\n#### 稀疏数组就是包含从0开始的不连续索引的数组。\n\n## 数组遍历\n\n经典for循环\n\n```\nvar keys = Object.keys(o);   // 获得 o 对象属性名组成的数组\nvar values = []              // 在数组中存储匹配属性的值\nfor(var i = 0; i < keys.length; i++) {  // 对于数组中每个索引\n    var key = keys[i];                  // 获得索引处的键值\n    values[i] = o[key];                 // 在 values 数组中保存属性值\n}\n```\n\nfor-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。\nforEach(值,索引,数组对象本身) 循环所有元素并回调，传入的参数仅表示是否回调\n具体案例参考另一篇博客，[javascript循环语句](https://blak-kong.github.io/2018/04/28/javascript%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/#forEach-遍历所有元素并回调)\n \n\n## 数组检测\n\n#### `Array.isArray()` es5语法：给定一个未知的对象，判定它是否为数组。\n \n\n## 数组转换\n\n转换方法`toString()`：当调用数组的 toString() 方法，会返回以逗号分隔数组中每个值的字符串。为了创建这个字符串会调用数组每一项的 toString() 方法。\n\n转换方法`toLocaleString()`：基本同上。但内置本地字符串格式转换功能（时间格式转换）。\n```\nvar sd=new Date()\nsd.toLocaleString() //\"2017/2/15 上午11:21:31\"\nsd.toString() //\"Wed Feb 15 2017 11:21:31 GMT+0800 (CST)\"\n```\n\n\n#### `join()` 可以使用不同的分隔符来构建字符串数组。\n\n```\nvar colors = [\"red\", \"green\", \"blue\"];\nconsole.log(colors.join(\",\"));    // red,green,blue\nconsole.log(colors.join(\"||\"));   // red||green||blue\n```\n\n#### `split()` 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。\n第一个参数是指定字符串或正则表达式。若传入第二个参数，可以指定数组长度\n```\n\"2:3:4:5\".split(\":\")\t//将返回[\"2\", \"3\", \"4\", \"5\"]\n\"|a|b|c\".split(\"|\")\t    //将返回[\"\", \"a\", \"b\", \"c\"]\n```\n\n## 栈方法和队列方法\n\n### 栈方法（后进先出）：`push()` 和 `pop()` \n// 越后面加入数组的，越先被`pop()`移除\n`push()` 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。\n`pop()` 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。\n\n```\nvar colors = [];                            // 创建一个数组\nvar count = colors.push(\"red\", \"green\");    // 推入两项\nconsole.log(count);                         // 2，数组的长度\n\ncount = colors.push(\"black\");               // 推入另一项\nconsole.log(count);                         // 3，数组的长度\n\nvar item = colors.pop();                    // 取得最后一项\nconsole.log(item);                          // \"black\",返回移除的项\nconsole.log(colors.length);                 // 2，数组的长度\n```\n\n### 队列方法（先进先出）`push()` 和 `shift()`\n\n`push()` 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。\n`shift()` 从数组前端移除第一项，减少数组的 length 值，然后返回移除的项。\n\n### 反向队列方法（反方向先进先出）`unshift()`和`pop()` \n\n`unshift()` 把任意数量参数逐个添加到数组前端，然后返回length 值\n`pop()` 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。\n\n## 重排序方法\n\n数组中有两个重排序的方法：reverse() 和 sort()。\n\n#### reverse() 方法可以反转数组元素的顺序。\n\n#### sort() 方法可以按升序或降序排列数组元素。\n\nsort具体用法，可以查看[深入理解js对象排序-sort()](https://blak-kong.github.io/2018/04/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjs%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/#more)\n\n通用代码演示\n```\nvar arr = [10, 20, 1, 2];\n\narr.sort(function (x, y) {\n    if (x < y) {\n        return -1;\n    }\n    if (x > y) {\n        return 1;\n    }\n    return 0;\n});\nconsole.log(arr); // [1, 2, 10, 20]\n```\n\n## 数组操作\n\n#### `concat()` 基于当前数组中的所有项创建一个新数组。\n\n这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。\n\n```\nvar a = [\"red\", \"green\", \"blue\"];\nvar b = a.concat(\"yellow\", [\"black\", \"brown\"]);//基于a创建新数组\n\nconsole.log(a);     // red,green,blue\nconsole.log(b);    // red,green,blue,yellow,black,brown\n```\n\n#### `slice()` 它能够基于当前数组中的一或多个项创建一个新数组。\n\nslice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。\n\n在只有一个参数的情况下，slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。\n如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。\n\n- 注意，slice() 方法不会影响原始数组。\n\n```\nvar a = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"];\nvar a1 = a.slice(1);\nvar a2 = a.slice(1,4);\n\nconsole.log(a1);   // green,blue,yellow,purple\nconsole.log(a2);   // green,blue,yellow\n```\n\n#### `splice()` 它的主要用途是向数组的中部插入元素,或者进行删除、替换\n\n写法：Array.splice(起始位置，删除数量，插入)\n\n只写前两项，是从指定位置开始删除\n不写第二项，写第三项，是插入元素\n三个都写，则是替换指定位置的元素\n\n## 位置方法\n\nECMAScript 5 为数组实例添加了两个位置方法：\nindexOf() 和 lastIndexOf()。\n这两个方法都接收两个参数：要`查找的项`和（可选的）`查找起点位置的索引`\n\n#### `indexOf()` 方法从数组的开头（位置0）开始向后查找\n\n#### `lastIndexOf()` 方法则从数组的末尾开始向前查找。\n\n注意：最终返回的索引，都是数组开头往后算。\n\n这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1。\n它们在比较第一个参数与数组中的每一项时，会使用全等操作符；\n也就是说，要求查找的项必须严格相等（就像使用 === 一样）。\n\n例如：\n```\nvar numbers = [1,2,3,4,5,4,3,2,1];\nconsole.log(numbers.indexOf(4));          // 3 从前往后，查找数组第一个4\nconsole.log(numbers.lastIndexOf(4));      // 5 从后往前，查找数组第一个4\nconsole.log(numbers.indexOf(4, 4));       // 5 从前往后，从索引4开始查找元素4\nconsole.log(numbers.lastIndexOf(4, 4));   // 3 从后往前，从索引-4开始往前查找元素4\n\nvar person = { name: \"Nicholas\" };\nvar people = [{ name: \"Nicholas\" }];\nvar morePeople = [person];\nconsole.log(people.indexOf(person));      // -1  没找到 -1\nconsole.log(morePeople.indexOf(person));  // 0   找到索引 0\n```\n\n## 迭代方法\n\nECMAScript 5 为数组定义了5个迭代方法。\n\n每个方法都接收两个参数：要在每一项上运行的`函数`和（可选的）`运行该函数的作用域对象`。\n传入这些方法中的函数会接收三个参数：`值`、`索引`和`数组对象本身`。\n根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。\n\n通用使用方法\n\n- array1.xxxx(callbackfn[, thisArg])\n\narray1\n必需。一个数组对象。\n\ncallbackfn\n必需。一个接受最多三个参数的函数。对于数组中的每个元素，filter 方法都会调用 callbackfn 函数一次。\n\nthisArg\n可选。可在 callbackfn 函数中为其引用 this 关键字的对象。如果省略 thisArg，则 undefined 将用作 this 值。\n\n以下是这5个迭代方法的作用。\n\n- `every()` 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true。\n- `filter()` 过滤器：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。\n- `forEach()` 元素遍历：对数组中的每一项运行给定函数。这个方法没有返回值。\n- `map()` 数组映射：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n- `some()` 对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true。\n\n5个迭代方法的用法：\n\n#### `every()` 确定数组的所有成员是否满足指定的测试。\n\narray1.every(callbackfn[, thisArg])\n\n- 判断数组元素是否全部都能整除2\n\n```\n// 定义回调函数\nfunction CheckIfEven(value, index, ar) { // CheckIfEven(值，索引，数组本身)\n\n    if (value % 2 == 0) { // 取余，检查是否能整除2\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// 创建数组 Create an array.\nvar numbers = [2, 4, 5, 6, 8];\n\n// 检查回调函数是否返回所有的数组值\nif (numbers.every(CheckIfEven)) {\n        console.log(\"All are even.\"); // true,满足指定的测试时运行\n    } else {\n        console.log(\"Some are not even.\"); // false,不满足指定的测试时运行\n    }\n\n// 输出(Output):  Some are not even.\n```\n\n#### `filter()` 返回数组中的满足回调函数中指定的条件的元素\n\narray1.filter(callbackfn[, thisArg])\n\n- 以下代码为，使用过滤器判断数组中的质数\n\n```\n// 定义回调函数\nfunction CheckIfPrime(value, index, ar) {\n    // Math.floor向下取整\n    // Math.sqrt() 方法可返回一个数的平方根。\n    high = Math.floor(Math.sqrt(value)) + 1; // 平方根向下取整再加一\n\n    for (var div = 2; div <= high; div++) { // 判断是否能否被2以上的数整除\n        if (value % div == 0) { // 如果能被整除，则不是质数\n            return false;\n        }\n    } \n    return true;\n}\n\n// 创建初始数组\nvar numbers = [31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53];\n\n// 获取原始数组中的质数\nvar primes = numbers.filter(CheckIfPrime);\n\nconsole.log(primes);  // [31,37,41,43,47,53]\n```\n\n#### `forEach()` 为数组中的每个元素执行指定操作。\n\narray1.forEach(callbackfn[, thisArg])\n\n若不写回调函数，则默认操作为遍历所有元素。\n\n- 以下代码为，数组求和\n\n```\n// 创建数组\nvar numbers = [10, 11, 12];\n\n// 调用每个数组元素，并回调函数\nvar sum = 0;\nnumbers.forEach(\n    function addNumber(value) { sum += value; } // 所有元素加起来\n);\n\nconsole.log(sum);  // 输出(Output): 33\n```\n\n#### `map()` 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。\n\narray1.map(callbackfn[, thisArg])\n\n- 以下代码为，数组取余\n\n```\n// 定义一个包含取余属性的对象\n// 原型方法定义\nvar obj = {\n    divisor: 10, // 除以10\n    remainder: function (value) {\n        return value % this.divisor;\n    }\n}\n\n// 创建数组\nvar numbers = [6, 12, 25, 30];\n\n// 获取余数\nvar result = numbers.map(obj.remainder, obj);\nconsole.log(result);\n\n// 输出(Output):  [6,2,5,0]\n```\n\n#### `some()` 确定指定的回调函数是否为数组中的任何元素均返回 true。\n\narray1.some(callbackfn[, thisArg])\n\n- some()判断是否存在至少一个数符合条件\n\n```\n// 创建一个函数，如果值为true，则返回true。\nvar isOutsideRange = function (value) {\n    // 检测是否超出范围\n    return value < this.minimum || value > this.maximum;\n}\n\n// 创建数组.\nvar numbers = [6, 12, 16, 22, -12];\n\n// 范围对象是“这个”对象。\nvar range = { minimum: 10, maximum: 20 };\n\nconsole.log(numbers.some(isOutsideRange, range));  // true 存在小于10和大于20的数\n```\n\n## 挑战 数组去重\n\n// 挑战一，一维数组\n\n- 思路\n使用indexOf(i)检测新数组newArr里有没有包含Arr里的i项\n如果没有则向newArr里添加Aii[i]项\n如果有则跳过；不做任何操作。\n\n```\nvar arr = [2,3,4,2,3,5,6,4,3,2];\nvar unique = function(arr){\n    var result = []; // 创建空数组，用于存放新数组\n    arr.forEach(function(item){\n\n        // indexOf()会使用全等操作符,判断item索引与遍历数组中所有元素都不相等，才运行\n        if(result.indexOf(item) < 0){\n\n        // 此处代码，只有数组索引小于0（数组中不存在），才会运行\n        // 所以可以达到去重效果\n            result.push(item);\n        }\n    });\n    return result;\n}\nconsole.log(unique(arr)); // [2,3,4,5,6]\n```\n\n// 挑战二（二维数组）\n```\nvar arr = [2,3,4,[2,3,4,5],3,5,[2,3,4,2],4,3,6,2];\nvar unique = function(arr){\n    var result = []; // 创建空数组，用于存放新数组\n    arr.forEach(function(item) { // 遍历数组元素给item\n        if (Array.isArray(item)) { // 判定item是否为数组，只有数组才能往下运行\n            item.forEach(function(i) { // 把item中的数组，遍历给i\n                // indexOf()会使用全等操作符,判断i索引与遍历数组中所有元素都不相等，才能往下运行\n                if (result.indexOf(i) < 0) {\n                    result.push(i);\n                }\n            });\n        } else {\n            if (result.indexOf(item) < 0) {\n                result.push(item);\n            }\n        }\n    });\n    return result;\n}\nconsole.log(unique(arr)); // [2,3,4,5,6]\n```\n\n","source":"_posts/js数组方法.md","raw":"---\ntitle: js数组方法\ndate: 2018-04-29 16:55:21\ncategories:\n  - JS学习笔记\ntags:\n  - 数组 js\n---\n[toc]\n\n## 使用数组字面量创建数组（推荐）\n```\nvar empty = [];\n```\n## 使用 `new` 关键字创建数组\n\n使用 new 关键字调用构造函数 Array() 是创建数组的另一种方法。\n我们可以用三种方式调用构造函数。例如：\n<!-- more -->\n```\n// 调用时没有参数\nvar a = new Array();\n\n// 调用时有一个数值参数，它指定长度\nvar a = new Array(10); \n\n// 显式指定多个数组元素或者数组的一个非数值元素\nvar a = new Array(5, 4, 3, 2, 1, \"testing\");\n```\n\n## 稀疏数组\n\n#### 稀疏数组就是包含从0开始的不连续索引的数组。\n\n## 数组遍历\n\n经典for循环\n\n```\nvar keys = Object.keys(o);   // 获得 o 对象属性名组成的数组\nvar values = []              // 在数组中存储匹配属性的值\nfor(var i = 0; i < keys.length; i++) {  // 对于数组中每个索引\n    var key = keys[i];                  // 获得索引处的键值\n    values[i] = o[key];                 // 在 values 数组中保存属性值\n}\n```\n\nfor-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。\nforEach(值,索引,数组对象本身) 循环所有元素并回调，传入的参数仅表示是否回调\n具体案例参考另一篇博客，[javascript循环语句](https://blak-kong.github.io/2018/04/28/javascript%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/#forEach-遍历所有元素并回调)\n \n\n## 数组检测\n\n#### `Array.isArray()` es5语法：给定一个未知的对象，判定它是否为数组。\n \n\n## 数组转换\n\n转换方法`toString()`：当调用数组的 toString() 方法，会返回以逗号分隔数组中每个值的字符串。为了创建这个字符串会调用数组每一项的 toString() 方法。\n\n转换方法`toLocaleString()`：基本同上。但内置本地字符串格式转换功能（时间格式转换）。\n```\nvar sd=new Date()\nsd.toLocaleString() //\"2017/2/15 上午11:21:31\"\nsd.toString() //\"Wed Feb 15 2017 11:21:31 GMT+0800 (CST)\"\n```\n\n\n#### `join()` 可以使用不同的分隔符来构建字符串数组。\n\n```\nvar colors = [\"red\", \"green\", \"blue\"];\nconsole.log(colors.join(\",\"));    // red,green,blue\nconsole.log(colors.join(\"||\"));   // red||green||blue\n```\n\n#### `split()` 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。\n第一个参数是指定字符串或正则表达式。若传入第二个参数，可以指定数组长度\n```\n\"2:3:4:5\".split(\":\")\t//将返回[\"2\", \"3\", \"4\", \"5\"]\n\"|a|b|c\".split(\"|\")\t    //将返回[\"\", \"a\", \"b\", \"c\"]\n```\n\n## 栈方法和队列方法\n\n### 栈方法（后进先出）：`push()` 和 `pop()` \n// 越后面加入数组的，越先被`pop()`移除\n`push()` 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。\n`pop()` 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。\n\n```\nvar colors = [];                            // 创建一个数组\nvar count = colors.push(\"red\", \"green\");    // 推入两项\nconsole.log(count);                         // 2，数组的长度\n\ncount = colors.push(\"black\");               // 推入另一项\nconsole.log(count);                         // 3，数组的长度\n\nvar item = colors.pop();                    // 取得最后一项\nconsole.log(item);                          // \"black\",返回移除的项\nconsole.log(colors.length);                 // 2，数组的长度\n```\n\n### 队列方法（先进先出）`push()` 和 `shift()`\n\n`push()` 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。\n`shift()` 从数组前端移除第一项，减少数组的 length 值，然后返回移除的项。\n\n### 反向队列方法（反方向先进先出）`unshift()`和`pop()` \n\n`unshift()` 把任意数量参数逐个添加到数组前端，然后返回length 值\n`pop()` 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。\n\n## 重排序方法\n\n数组中有两个重排序的方法：reverse() 和 sort()。\n\n#### reverse() 方法可以反转数组元素的顺序。\n\n#### sort() 方法可以按升序或降序排列数组元素。\n\nsort具体用法，可以查看[深入理解js对象排序-sort()](https://blak-kong.github.io/2018/04/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjs%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/#more)\n\n通用代码演示\n```\nvar arr = [10, 20, 1, 2];\n\narr.sort(function (x, y) {\n    if (x < y) {\n        return -1;\n    }\n    if (x > y) {\n        return 1;\n    }\n    return 0;\n});\nconsole.log(arr); // [1, 2, 10, 20]\n```\n\n## 数组操作\n\n#### `concat()` 基于当前数组中的所有项创建一个新数组。\n\n这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。\n\n```\nvar a = [\"red\", \"green\", \"blue\"];\nvar b = a.concat(\"yellow\", [\"black\", \"brown\"]);//基于a创建新数组\n\nconsole.log(a);     // red,green,blue\nconsole.log(b);    // red,green,blue,yellow,black,brown\n```\n\n#### `slice()` 它能够基于当前数组中的一或多个项创建一个新数组。\n\nslice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。\n\n在只有一个参数的情况下，slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。\n如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。\n\n- 注意，slice() 方法不会影响原始数组。\n\n```\nvar a = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"];\nvar a1 = a.slice(1);\nvar a2 = a.slice(1,4);\n\nconsole.log(a1);   // green,blue,yellow,purple\nconsole.log(a2);   // green,blue,yellow\n```\n\n#### `splice()` 它的主要用途是向数组的中部插入元素,或者进行删除、替换\n\n写法：Array.splice(起始位置，删除数量，插入)\n\n只写前两项，是从指定位置开始删除\n不写第二项，写第三项，是插入元素\n三个都写，则是替换指定位置的元素\n\n## 位置方法\n\nECMAScript 5 为数组实例添加了两个位置方法：\nindexOf() 和 lastIndexOf()。\n这两个方法都接收两个参数：要`查找的项`和（可选的）`查找起点位置的索引`\n\n#### `indexOf()` 方法从数组的开头（位置0）开始向后查找\n\n#### `lastIndexOf()` 方法则从数组的末尾开始向前查找。\n\n注意：最终返回的索引，都是数组开头往后算。\n\n这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1。\n它们在比较第一个参数与数组中的每一项时，会使用全等操作符；\n也就是说，要求查找的项必须严格相等（就像使用 === 一样）。\n\n例如：\n```\nvar numbers = [1,2,3,4,5,4,3,2,1];\nconsole.log(numbers.indexOf(4));          // 3 从前往后，查找数组第一个4\nconsole.log(numbers.lastIndexOf(4));      // 5 从后往前，查找数组第一个4\nconsole.log(numbers.indexOf(4, 4));       // 5 从前往后，从索引4开始查找元素4\nconsole.log(numbers.lastIndexOf(4, 4));   // 3 从后往前，从索引-4开始往前查找元素4\n\nvar person = { name: \"Nicholas\" };\nvar people = [{ name: \"Nicholas\" }];\nvar morePeople = [person];\nconsole.log(people.indexOf(person));      // -1  没找到 -1\nconsole.log(morePeople.indexOf(person));  // 0   找到索引 0\n```\n\n## 迭代方法\n\nECMAScript 5 为数组定义了5个迭代方法。\n\n每个方法都接收两个参数：要在每一项上运行的`函数`和（可选的）`运行该函数的作用域对象`。\n传入这些方法中的函数会接收三个参数：`值`、`索引`和`数组对象本身`。\n根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。\n\n通用使用方法\n\n- array1.xxxx(callbackfn[, thisArg])\n\narray1\n必需。一个数组对象。\n\ncallbackfn\n必需。一个接受最多三个参数的函数。对于数组中的每个元素，filter 方法都会调用 callbackfn 函数一次。\n\nthisArg\n可选。可在 callbackfn 函数中为其引用 this 关键字的对象。如果省略 thisArg，则 undefined 将用作 this 值。\n\n以下是这5个迭代方法的作用。\n\n- `every()` 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true。\n- `filter()` 过滤器：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。\n- `forEach()` 元素遍历：对数组中的每一项运行给定函数。这个方法没有返回值。\n- `map()` 数组映射：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n- `some()` 对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true。\n\n5个迭代方法的用法：\n\n#### `every()` 确定数组的所有成员是否满足指定的测试。\n\narray1.every(callbackfn[, thisArg])\n\n- 判断数组元素是否全部都能整除2\n\n```\n// 定义回调函数\nfunction CheckIfEven(value, index, ar) { // CheckIfEven(值，索引，数组本身)\n\n    if (value % 2 == 0) { // 取余，检查是否能整除2\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// 创建数组 Create an array.\nvar numbers = [2, 4, 5, 6, 8];\n\n// 检查回调函数是否返回所有的数组值\nif (numbers.every(CheckIfEven)) {\n        console.log(\"All are even.\"); // true,满足指定的测试时运行\n    } else {\n        console.log(\"Some are not even.\"); // false,不满足指定的测试时运行\n    }\n\n// 输出(Output):  Some are not even.\n```\n\n#### `filter()` 返回数组中的满足回调函数中指定的条件的元素\n\narray1.filter(callbackfn[, thisArg])\n\n- 以下代码为，使用过滤器判断数组中的质数\n\n```\n// 定义回调函数\nfunction CheckIfPrime(value, index, ar) {\n    // Math.floor向下取整\n    // Math.sqrt() 方法可返回一个数的平方根。\n    high = Math.floor(Math.sqrt(value)) + 1; // 平方根向下取整再加一\n\n    for (var div = 2; div <= high; div++) { // 判断是否能否被2以上的数整除\n        if (value % div == 0) { // 如果能被整除，则不是质数\n            return false;\n        }\n    } \n    return true;\n}\n\n// 创建初始数组\nvar numbers = [31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53];\n\n// 获取原始数组中的质数\nvar primes = numbers.filter(CheckIfPrime);\n\nconsole.log(primes);  // [31,37,41,43,47,53]\n```\n\n#### `forEach()` 为数组中的每个元素执行指定操作。\n\narray1.forEach(callbackfn[, thisArg])\n\n若不写回调函数，则默认操作为遍历所有元素。\n\n- 以下代码为，数组求和\n\n```\n// 创建数组\nvar numbers = [10, 11, 12];\n\n// 调用每个数组元素，并回调函数\nvar sum = 0;\nnumbers.forEach(\n    function addNumber(value) { sum += value; } // 所有元素加起来\n);\n\nconsole.log(sum);  // 输出(Output): 33\n```\n\n#### `map()` 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。\n\narray1.map(callbackfn[, thisArg])\n\n- 以下代码为，数组取余\n\n```\n// 定义一个包含取余属性的对象\n// 原型方法定义\nvar obj = {\n    divisor: 10, // 除以10\n    remainder: function (value) {\n        return value % this.divisor;\n    }\n}\n\n// 创建数组\nvar numbers = [6, 12, 25, 30];\n\n// 获取余数\nvar result = numbers.map(obj.remainder, obj);\nconsole.log(result);\n\n// 输出(Output):  [6,2,5,0]\n```\n\n#### `some()` 确定指定的回调函数是否为数组中的任何元素均返回 true。\n\narray1.some(callbackfn[, thisArg])\n\n- some()判断是否存在至少一个数符合条件\n\n```\n// 创建一个函数，如果值为true，则返回true。\nvar isOutsideRange = function (value) {\n    // 检测是否超出范围\n    return value < this.minimum || value > this.maximum;\n}\n\n// 创建数组.\nvar numbers = [6, 12, 16, 22, -12];\n\n// 范围对象是“这个”对象。\nvar range = { minimum: 10, maximum: 20 };\n\nconsole.log(numbers.some(isOutsideRange, range));  // true 存在小于10和大于20的数\n```\n\n## 挑战 数组去重\n\n// 挑战一，一维数组\n\n- 思路\n使用indexOf(i)检测新数组newArr里有没有包含Arr里的i项\n如果没有则向newArr里添加Aii[i]项\n如果有则跳过；不做任何操作。\n\n```\nvar arr = [2,3,4,2,3,5,6,4,3,2];\nvar unique = function(arr){\n    var result = []; // 创建空数组，用于存放新数组\n    arr.forEach(function(item){\n\n        // indexOf()会使用全等操作符,判断item索引与遍历数组中所有元素都不相等，才运行\n        if(result.indexOf(item) < 0){\n\n        // 此处代码，只有数组索引小于0（数组中不存在），才会运行\n        // 所以可以达到去重效果\n            result.push(item);\n        }\n    });\n    return result;\n}\nconsole.log(unique(arr)); // [2,3,4,5,6]\n```\n\n// 挑战二（二维数组）\n```\nvar arr = [2,3,4,[2,3,4,5],3,5,[2,3,4,2],4,3,6,2];\nvar unique = function(arr){\n    var result = []; // 创建空数组，用于存放新数组\n    arr.forEach(function(item) { // 遍历数组元素给item\n        if (Array.isArray(item)) { // 判定item是否为数组，只有数组才能往下运行\n            item.forEach(function(i) { // 把item中的数组，遍历给i\n                // indexOf()会使用全等操作符,判断i索引与遍历数组中所有元素都不相等，才能往下运行\n                if (result.indexOf(i) < 0) {\n                    result.push(i);\n                }\n            });\n        } else {\n            if (result.indexOf(item) < 0) {\n                result.push(item);\n            }\n        }\n    });\n    return result;\n}\nconsole.log(unique(arr)); // [2,3,4,5,6]\n```\n\n","slug":"js数组方法","published":1,"updated":"2019-04-07T14:56:55.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhf2000h9kud9nr0o8ac","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h2 id=\"使用数组字面量创建数组（推荐）\"><a href=\"#使用数组字面量创建数组（推荐）\" class=\"headerlink\" title=\"使用数组字面量创建数组（推荐）\"></a>使用数组字面量创建数组（推荐）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var empty = [];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-new-关键字创建数组\"><a href=\"#使用-new-关键字创建数组\" class=\"headerlink\" title=\"使用 new 关键字创建数组\"></a>使用 <code>new</code> 关键字创建数组</h2><p>使用 new 关键字调用构造函数 Array() 是创建数组的另一种方法。<br>我们可以用三种方式调用构造函数。例如：<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 调用时没有参数</span><br><span class=\"line\">var a = new Array();</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用时有一个数值参数，它指定长度</span><br><span class=\"line\">var a = new Array(10); </span><br><span class=\"line\"></span><br><span class=\"line\">// 显式指定多个数组元素或者数组的一个非数值元素</span><br><span class=\"line\">var a = new Array(5, 4, 3, 2, 1, &quot;testing&quot;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"稀疏数组\"><a href=\"#稀疏数组\" class=\"headerlink\" title=\"稀疏数组\"></a>稀疏数组</h2><h4 id=\"稀疏数组就是包含从0开始的不连续索引的数组。\"><a href=\"#稀疏数组就是包含从0开始的不连续索引的数组。\" class=\"headerlink\" title=\"稀疏数组就是包含从0开始的不连续索引的数组。\"></a>稀疏数组就是包含从0开始的不连续索引的数组。</h4><h2 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h2><p>经典for循环</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var keys = Object.keys(o);   // 获得 o 对象属性名组成的数组</span><br><span class=\"line\">var values = []              // 在数组中存储匹配属性的值</span><br><span class=\"line\">for(var i = 0; i &lt; keys.length; i++) &#123;  // 对于数组中每个索引</span><br><span class=\"line\">    var key = keys[i];                  // 获得索引处的键值</span><br><span class=\"line\">    values[i] = o[key];                 // 在 values 数组中保存属性值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>for-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。<br>forEach(值,索引,数组对象本身) 循环所有元素并回调，传入的参数仅表示是否回调<br>具体案例参考另一篇博客，<a href=\"https://blak-kong.github.io/2018/04/28/javascript%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/#forEach-遍历所有元素并回调\">javascript循环语句</a></p>\n<h2 id=\"数组检测\"><a href=\"#数组检测\" class=\"headerlink\" title=\"数组检测\"></a>数组检测</h2><h4 id=\"Array-isArray-es5语法：给定一个未知的对象，判定它是否为数组。\"><a href=\"#Array-isArray-es5语法：给定一个未知的对象，判定它是否为数组。\" class=\"headerlink\" title=\"Array.isArray() es5语法：给定一个未知的对象，判定它是否为数组。\"></a><code>Array.isArray()</code> es5语法：给定一个未知的对象，判定它是否为数组。</h4><h2 id=\"数组转换\"><a href=\"#数组转换\" class=\"headerlink\" title=\"数组转换\"></a>数组转换</h2><p>转换方法<code>toString()</code>：当调用数组的 toString() 方法，会返回以逗号分隔数组中每个值的字符串。为了创建这个字符串会调用数组每一项的 toString() 方法。</p>\n<p>转换方法<code>toLocaleString()</code>：基本同上。但内置本地字符串格式转换功能（时间格式转换）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sd=new Date()</span><br><span class=\"line\">sd.toLocaleString() //&quot;2017/2/15 上午11:21:31&quot;</span><br><span class=\"line\">sd.toString() //&quot;Wed Feb 15 2017 11:21:31 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"join-可以使用不同的分隔符来构建字符串数组。\"><a href=\"#join-可以使用不同的分隔符来构建字符串数组。\" class=\"headerlink\" title=\"join() 可以使用不同的分隔符来构建字符串数组。\"></a><code>join()</code> 可以使用不同的分隔符来构建字符串数组。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class=\"line\">console.log(colors.join(&quot;,&quot;));    // red,green,blue</span><br><span class=\"line\">console.log(colors.join(&quot;||&quot;));   // red||green||blue</span><br></pre></td></tr></table></figure>\n<h4 id=\"split-用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。\"><a href=\"#split-用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。\" class=\"headerlink\" title=\"split() 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。\"></a><code>split()</code> 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。</h4><p>第一个参数是指定字符串或正则表达式。若传入第二个参数，可以指定数组长度<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;2:3:4:5&quot;.split(&quot;:&quot;)\t//将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class=\"line\">&quot;|a|b|c&quot;.split(&quot;|&quot;)\t    //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"栈方法和队列方法\"><a href=\"#栈方法和队列方法\" class=\"headerlink\" title=\"栈方法和队列方法\"></a>栈方法和队列方法</h2><h3 id=\"栈方法（后进先出）：push-和-pop\"><a href=\"#栈方法（后进先出）：push-和-pop\" class=\"headerlink\" title=\"栈方法（后进先出）：push() 和 pop()\"></a>栈方法（后进先出）：<code>push()</code> 和 <code>pop()</code></h3><p>// 越后面加入数组的，越先被<code>pop()</code>移除<br><code>push()</code> 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。<br><code>pop()</code> 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var colors = [];                            // 创建一个数组</span><br><span class=\"line\">var count = colors.push(&quot;red&quot;, &quot;green&quot;);    // 推入两项</span><br><span class=\"line\">console.log(count);                         // 2，数组的长度</span><br><span class=\"line\"></span><br><span class=\"line\">count = colors.push(&quot;black&quot;);               // 推入另一项</span><br><span class=\"line\">console.log(count);                         // 3，数组的长度</span><br><span class=\"line\"></span><br><span class=\"line\">var item = colors.pop();                    // 取得最后一项</span><br><span class=\"line\">console.log(item);                          // &quot;black&quot;,返回移除的项</span><br><span class=\"line\">console.log(colors.length);                 // 2，数组的长度</span><br></pre></td></tr></table></figure>\n<h3 id=\"队列方法（先进先出）push-和-shift\"><a href=\"#队列方法（先进先出）push-和-shift\" class=\"headerlink\" title=\"队列方法（先进先出）push() 和 shift()\"></a>队列方法（先进先出）<code>push()</code> 和 <code>shift()</code></h3><p><code>push()</code> 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。<br><code>shift()</code> 从数组前端移除第一项，减少数组的 length 值，然后返回移除的项。</p>\n<h3 id=\"反向队列方法（反方向先进先出）unshift-和pop\"><a href=\"#反向队列方法（反方向先进先出）unshift-和pop\" class=\"headerlink\" title=\"反向队列方法（反方向先进先出）unshift()和pop()\"></a>反向队列方法（反方向先进先出）<code>unshift()</code>和<code>pop()</code></h3><p><code>unshift()</code> 把任意数量参数逐个添加到数组前端，然后返回length 值<br><code>pop()</code> 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>\n<h2 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h2><p>数组中有两个重排序的方法：reverse() 和 sort()。</p>\n<h4 id=\"reverse-方法可以反转数组元素的顺序。\"><a href=\"#reverse-方法可以反转数组元素的顺序。\" class=\"headerlink\" title=\"reverse() 方法可以反转数组元素的顺序。\"></a>reverse() 方法可以反转数组元素的顺序。</h4><h4 id=\"sort-方法可以按升序或降序排列数组元素。\"><a href=\"#sort-方法可以按升序或降序排列数组元素。\" class=\"headerlink\" title=\"sort() 方法可以按升序或降序排列数组元素。\"></a>sort() 方法可以按升序或降序排列数组元素。</h4><p>sort具体用法，可以查看<a href=\"https://blak-kong.github.io/2018/04/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjs%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/#more\">深入理解js对象排序-sort()</a></p>\n<p>通用代码演示<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [10, 20, 1, 2];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.sort(function (x, y) &#123;</span><br><span class=\"line\">    if (x &lt; y) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (x &gt; y) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(arr); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h2><h4 id=\"concat-基于当前数组中的所有项创建一个新数组。\"><a href=\"#concat-基于当前数组中的所有项创建一个新数组。\" class=\"headerlink\" title=\"concat() 基于当前数组中的所有项创建一个新数组。\"></a><code>concat()</code> 基于当前数组中的所有项创建一个新数组。</h4><p>这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class=\"line\">var b = a.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);//基于a创建新数组</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);     // red,green,blue</span><br><span class=\"line\">console.log(b);    // red,green,blue,yellow,black,brown</span><br></pre></td></tr></table></figure>\n<h4 id=\"slice-它能够基于当前数组中的一或多个项创建一个新数组。\"><a href=\"#slice-它能够基于当前数组中的一或多个项创建一个新数组。\" class=\"headerlink\" title=\"slice() 它能够基于当前数组中的一或多个项创建一个新数组。\"></a><code>slice()</code> 它能够基于当前数组中的一或多个项创建一个新数组。</h4><p>slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。</p>\n<p>在只有一个参数的情况下，slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。</p>\n<ul>\n<li>注意，slice() 方法不会影响原始数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];</span><br><span class=\"line\">var a1 = a.slice(1);</span><br><span class=\"line\">var a2 = a.slice(1,4);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a1);   // green,blue,yellow,purple</span><br><span class=\"line\">console.log(a2);   // green,blue,yellow</span><br></pre></td></tr></table></figure>\n<h4 id=\"splice-它的主要用途是向数组的中部插入元素-或者进行删除、替换\"><a href=\"#splice-它的主要用途是向数组的中部插入元素-或者进行删除、替换\" class=\"headerlink\" title=\"splice() 它的主要用途是向数组的中部插入元素,或者进行删除、替换\"></a><code>splice()</code> 它的主要用途是向数组的中部插入元素,或者进行删除、替换</h4><p>写法：Array.splice(起始位置，删除数量，插入)</p>\n<p>只写前两项，是从指定位置开始删除<br>不写第二项，写第三项，是插入元素<br>三个都写，则是替换指定位置的元素</p>\n<h2 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h2><p>ECMAScript 5 为数组实例添加了两个位置方法：<br>indexOf() 和 lastIndexOf()。<br>这两个方法都接收两个参数：要<code>查找的项</code>和（可选的）<code>查找起点位置的索引</code></p>\n<h4 id=\"indexOf-方法从数组的开头（位置0）开始向后查找\"><a href=\"#indexOf-方法从数组的开头（位置0）开始向后查找\" class=\"headerlink\" title=\"indexOf() 方法从数组的开头（位置0）开始向后查找\"></a><code>indexOf()</code> 方法从数组的开头（位置0）开始向后查找</h4><h4 id=\"lastIndexOf-方法则从数组的末尾开始向前查找。\"><a href=\"#lastIndexOf-方法则从数组的末尾开始向前查找。\" class=\"headerlink\" title=\"lastIndexOf() 方法则从数组的末尾开始向前查找。\"></a><code>lastIndexOf()</code> 方法则从数组的末尾开始向前查找。</h4><p>注意：最终返回的索引，都是数组开头往后算。</p>\n<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1。<br>它们在比较第一个参数与数组中的每一项时，会使用全等操作符；<br>也就是说，要求查找的项必须严格相等（就像使用 === 一样）。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class=\"line\">console.log(numbers.indexOf(4));          // 3 从前往后，查找数组第一个4</span><br><span class=\"line\">console.log(numbers.lastIndexOf(4));      // 5 从后往前，查找数组第一个4</span><br><span class=\"line\">console.log(numbers.indexOf(4, 4));       // 5 从前往后，从索引4开始查找元素4</span><br><span class=\"line\">console.log(numbers.lastIndexOf(4, 4));   // 3 从后往前，从索引-4开始往前查找元素4</span><br><span class=\"line\"></span><br><span class=\"line\">var person = &#123; name: &quot;Nicholas&quot; &#125;;</span><br><span class=\"line\">var people = [&#123; name: &quot;Nicholas&quot; &#125;];</span><br><span class=\"line\">var morePeople = [person];</span><br><span class=\"line\">console.log(people.indexOf(person));      // -1  没找到 -1</span><br><span class=\"line\">console.log(morePeople.indexOf(person));  // 0   找到索引 0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h2><p>ECMAScript 5 为数组定义了5个迭代方法。</p>\n<p>每个方法都接收两个参数：要在每一项上运行的<code>函数</code>和（可选的）<code>运行该函数的作用域对象</code>。<br>传入这些方法中的函数会接收三个参数：<code>值</code>、<code>索引</code>和<code>数组对象本身</code>。<br>根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。</p>\n<p>通用使用方法</p>\n<ul>\n<li>array1.xxxx(callbackfn[, thisArg])</li>\n</ul>\n<p>array1<br>必需。一个数组对象。</p>\n<p>callbackfn<br>必需。一个接受最多三个参数的函数。对于数组中的每个元素，filter 方法都会调用 callbackfn 函数一次。</p>\n<p>thisArg<br>可选。可在 callbackfn 函数中为其引用 this 关键字的对象。如果省略 thisArg，则 undefined 将用作 this 值。</p>\n<p>以下是这5个迭代方法的作用。</p>\n<ul>\n<li><code>every()</code> 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true。</li>\n<li><code>filter()</code> 过滤器：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>\n<li><code>forEach()</code> 元素遍历：对数组中的每一项运行给定函数。这个方法没有返回值。</li>\n<li><code>map()</code> 数组映射：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>\n<li><code>some()</code> 对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true。</li>\n</ul>\n<p>5个迭代方法的用法：</p>\n<h4 id=\"every-确定数组的所有成员是否满足指定的测试。\"><a href=\"#every-确定数组的所有成员是否满足指定的测试。\" class=\"headerlink\" title=\"every() 确定数组的所有成员是否满足指定的测试。\"></a><code>every()</code> 确定数组的所有成员是否满足指定的测试。</h4><p>array1.every(callbackfn[, thisArg])</p>\n<ul>\n<li>判断数组元素是否全部都能整除2</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义回调函数</span><br><span class=\"line\">function CheckIfEven(value, index, ar) &#123; // CheckIfEven(值，索引，数组本身)</span><br><span class=\"line\"></span><br><span class=\"line\">    if (value % 2 == 0) &#123; // 取余，检查是否能整除2</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建数组 Create an array.</span><br><span class=\"line\">var numbers = [2, 4, 5, 6, 8];</span><br><span class=\"line\"></span><br><span class=\"line\">// 检查回调函数是否返回所有的数组值</span><br><span class=\"line\">if (numbers.every(CheckIfEven)) &#123;</span><br><span class=\"line\">        console.log(&quot;All are even.&quot;); // true,满足指定的测试时运行</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        console.log(&quot;Some are not even.&quot;); // false,不满足指定的测试时运行</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出(Output):  Some are not even.</span><br></pre></td></tr></table></figure>\n<h4 id=\"filter-返回数组中的满足回调函数中指定的条件的元素\"><a href=\"#filter-返回数组中的满足回调函数中指定的条件的元素\" class=\"headerlink\" title=\"filter() 返回数组中的满足回调函数中指定的条件的元素\"></a><code>filter()</code> 返回数组中的满足回调函数中指定的条件的元素</h4><p>array1.filter(callbackfn[, thisArg])</p>\n<ul>\n<li>以下代码为，使用过滤器判断数组中的质数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义回调函数</span><br><span class=\"line\">function CheckIfPrime(value, index, ar) &#123;</span><br><span class=\"line\">    // Math.floor向下取整</span><br><span class=\"line\">    // Math.sqrt() 方法可返回一个数的平方根。</span><br><span class=\"line\">    high = Math.floor(Math.sqrt(value)) + 1; // 平方根向下取整再加一</span><br><span class=\"line\"></span><br><span class=\"line\">    for (var div = 2; div &lt;= high; div++) &#123; // 判断是否能否被2以上的数整除</span><br><span class=\"line\">        if (value % div == 0) &#123; // 如果能被整除，则不是质数</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建初始数组</span><br><span class=\"line\">var numbers = [31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53];</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取原始数组中的质数</span><br><span class=\"line\">var primes = numbers.filter(CheckIfPrime);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(primes);  // [31,37,41,43,47,53]</span><br></pre></td></tr></table></figure>\n<h4 id=\"forEach-为数组中的每个元素执行指定操作。\"><a href=\"#forEach-为数组中的每个元素执行指定操作。\" class=\"headerlink\" title=\"forEach() 为数组中的每个元素执行指定操作。\"></a><code>forEach()</code> 为数组中的每个元素执行指定操作。</h4><p>array1.forEach(callbackfn[, thisArg])</p>\n<p>若不写回调函数，则默认操作为遍历所有元素。</p>\n<ul>\n<li>以下代码为，数组求和</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建数组</span><br><span class=\"line\">var numbers = [10, 11, 12];</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用每个数组元素，并回调函数</span><br><span class=\"line\">var sum = 0;</span><br><span class=\"line\">numbers.forEach(</span><br><span class=\"line\">    function addNumber(value) &#123; sum += value; &#125; // 所有元素加起来</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(sum);  // 输出(Output): 33</span><br></pre></td></tr></table></figure>\n<h4 id=\"map-对数组的每个元素调用定义的回调函数，并返回包含结果的数组。\"><a href=\"#map-对数组的每个元素调用定义的回调函数，并返回包含结果的数组。\" class=\"headerlink\" title=\"map() 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。\"></a><code>map()</code> 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。</h4><p>array1.map(callbackfn[, thisArg])</p>\n<ul>\n<li>以下代码为，数组取余</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个包含取余属性的对象</span><br><span class=\"line\">// 原型方法定义</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    divisor: 10, // 除以10</span><br><span class=\"line\">    remainder: function (value) &#123;</span><br><span class=\"line\">        return value % this.divisor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建数组</span><br><span class=\"line\">var numbers = [6, 12, 25, 30];</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取余数</span><br><span class=\"line\">var result = numbers.map(obj.remainder, obj);</span><br><span class=\"line\">console.log(result);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出(Output):  [6,2,5,0]</span><br></pre></td></tr></table></figure>\n<h4 id=\"some-确定指定的回调函数是否为数组中的任何元素均返回-true。\"><a href=\"#some-确定指定的回调函数是否为数组中的任何元素均返回-true。\" class=\"headerlink\" title=\"some() 确定指定的回调函数是否为数组中的任何元素均返回 true。\"></a><code>some()</code> 确定指定的回调函数是否为数组中的任何元素均返回 true。</h4><p>array1.some(callbackfn[, thisArg])</p>\n<ul>\n<li>some()判断是否存在至少一个数符合条件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建一个函数，如果值为true，则返回true。</span><br><span class=\"line\">var isOutsideRange = function (value) &#123;</span><br><span class=\"line\">    // 检测是否超出范围</span><br><span class=\"line\">    return value &lt; this.minimum || value &gt; this.maximum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建数组.</span><br><span class=\"line\">var numbers = [6, 12, 16, 22, -12];</span><br><span class=\"line\"></span><br><span class=\"line\">// 范围对象是“这个”对象。</span><br><span class=\"line\">var range = &#123; minimum: 10, maximum: 20 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(numbers.some(isOutsideRange, range));  // true 存在小于10和大于20的数</span><br></pre></td></tr></table></figure>\n<h2 id=\"挑战-数组去重\"><a href=\"#挑战-数组去重\" class=\"headerlink\" title=\"挑战 数组去重\"></a>挑战 数组去重</h2><p>// 挑战一，一维数组</p>\n<ul>\n<li>思路<br>使用indexOf(i)检测新数组newArr里有没有包含Arr里的i项<br>如果没有则向newArr里添加Aii[i]项<br>如果有则跳过；不做任何操作。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [2,3,4,2,3,5,6,4,3,2];</span><br><span class=\"line\">var unique = function(arr)&#123;</span><br><span class=\"line\">    var result = []; // 创建空数组，用于存放新数组</span><br><span class=\"line\">    arr.forEach(function(item)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // indexOf()会使用全等操作符,判断item索引与遍历数组中所有元素都不相等，才运行</span><br><span class=\"line\">        if(result.indexOf(item) &lt; 0)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 此处代码，只有数组索引小于0（数组中不存在），才会运行</span><br><span class=\"line\">        // 所以可以达到去重效果</span><br><span class=\"line\">            result.push(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(unique(arr)); // [2,3,4,5,6]</span><br></pre></td></tr></table></figure>\n<p>// 挑战二（二维数组）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [2,3,4,[2,3,4,5],3,5,[2,3,4,2],4,3,6,2];</span><br><span class=\"line\">var unique = function(arr)&#123;</span><br><span class=\"line\">    var result = []; // 创建空数组，用于存放新数组</span><br><span class=\"line\">    arr.forEach(function(item) &#123; // 遍历数组元素给item</span><br><span class=\"line\">        if (Array.isArray(item)) &#123; // 判定item是否为数组，只有数组才能往下运行</span><br><span class=\"line\">            item.forEach(function(i) &#123; // 把item中的数组，遍历给i</span><br><span class=\"line\">                // indexOf()会使用全等操作符,判断i索引与遍历数组中所有元素都不相等，才能往下运行</span><br><span class=\"line\">                if (result.indexOf(i) &lt; 0) &#123;</span><br><span class=\"line\">                    result.push(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (result.indexOf(item) &lt; 0) &#123;</span><br><span class=\"line\">                result.push(item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(unique(arr)); // [2,3,4,5,6]</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h2 id=\"使用数组字面量创建数组（推荐）\"><a href=\"#使用数组字面量创建数组（推荐）\" class=\"headerlink\" title=\"使用数组字面量创建数组（推荐）\"></a>使用数组字面量创建数组（推荐）</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var empty = [];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-new-关键字创建数组\"><a href=\"#使用-new-关键字创建数组\" class=\"headerlink\" title=\"使用 new 关键字创建数组\"></a>使用 <code>new</code> 关键字创建数组</h2><p>使用 new 关键字调用构造函数 Array() 是创建数组的另一种方法。<br>我们可以用三种方式调用构造函数。例如：<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 调用时没有参数</span><br><span class=\"line\">var a = new Array();</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用时有一个数值参数，它指定长度</span><br><span class=\"line\">var a = new Array(10); </span><br><span class=\"line\"></span><br><span class=\"line\">// 显式指定多个数组元素或者数组的一个非数值元素</span><br><span class=\"line\">var a = new Array(5, 4, 3, 2, 1, &quot;testing&quot;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"稀疏数组\"><a href=\"#稀疏数组\" class=\"headerlink\" title=\"稀疏数组\"></a>稀疏数组</h2><h4 id=\"稀疏数组就是包含从0开始的不连续索引的数组。\"><a href=\"#稀疏数组就是包含从0开始的不连续索引的数组。\" class=\"headerlink\" title=\"稀疏数组就是包含从0开始的不连续索引的数组。\"></a>稀疏数组就是包含从0开始的不连续索引的数组。</h4><h2 id=\"数组遍历\"><a href=\"#数组遍历\" class=\"headerlink\" title=\"数组遍历\"></a>数组遍历</h2><p>经典for循环</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var keys = Object.keys(o);   // 获得 o 对象属性名组成的数组</span><br><span class=\"line\">var values = []              // 在数组中存储匹配属性的值</span><br><span class=\"line\">for(var i = 0; i &lt; keys.length; i++) &#123;  // 对于数组中每个索引</span><br><span class=\"line\">    var key = keys[i];                  // 获得索引处的键值</span><br><span class=\"line\">    values[i] = o[key];                 // 在 values 数组中保存属性值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>for-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。<br>forEach(值,索引,数组对象本身) 循环所有元素并回调，传入的参数仅表示是否回调<br>具体案例参考另一篇博客，<a href=\"https://blak-kong.github.io/2018/04/28/javascript%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/#forEach-遍历所有元素并回调\">javascript循环语句</a></p>\n<h2 id=\"数组检测\"><a href=\"#数组检测\" class=\"headerlink\" title=\"数组检测\"></a>数组检测</h2><h4 id=\"Array-isArray-es5语法：给定一个未知的对象，判定它是否为数组。\"><a href=\"#Array-isArray-es5语法：给定一个未知的对象，判定它是否为数组。\" class=\"headerlink\" title=\"Array.isArray() es5语法：给定一个未知的对象，判定它是否为数组。\"></a><code>Array.isArray()</code> es5语法：给定一个未知的对象，判定它是否为数组。</h4><h2 id=\"数组转换\"><a href=\"#数组转换\" class=\"headerlink\" title=\"数组转换\"></a>数组转换</h2><p>转换方法<code>toString()</code>：当调用数组的 toString() 方法，会返回以逗号分隔数组中每个值的字符串。为了创建这个字符串会调用数组每一项的 toString() 方法。</p>\n<p>转换方法<code>toLocaleString()</code>：基本同上。但内置本地字符串格式转换功能（时间格式转换）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sd=new Date()</span><br><span class=\"line\">sd.toLocaleString() //&quot;2017/2/15 上午11:21:31&quot;</span><br><span class=\"line\">sd.toString() //&quot;Wed Feb 15 2017 11:21:31 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"join-可以使用不同的分隔符来构建字符串数组。\"><a href=\"#join-可以使用不同的分隔符来构建字符串数组。\" class=\"headerlink\" title=\"join() 可以使用不同的分隔符来构建字符串数组。\"></a><code>join()</code> 可以使用不同的分隔符来构建字符串数组。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class=\"line\">console.log(colors.join(&quot;,&quot;));    // red,green,blue</span><br><span class=\"line\">console.log(colors.join(&quot;||&quot;));   // red||green||blue</span><br></pre></td></tr></table></figure>\n<h4 id=\"split-用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。\"><a href=\"#split-用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。\" class=\"headerlink\" title=\"split() 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。\"></a><code>split()</code> 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。</h4><p>第一个参数是指定字符串或正则表达式。若传入第二个参数，可以指定数组长度<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;2:3:4:5&quot;.split(&quot;:&quot;)\t//将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class=\"line\">&quot;|a|b|c&quot;.split(&quot;|&quot;)\t    //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"栈方法和队列方法\"><a href=\"#栈方法和队列方法\" class=\"headerlink\" title=\"栈方法和队列方法\"></a>栈方法和队列方法</h2><h3 id=\"栈方法（后进先出）：push-和-pop\"><a href=\"#栈方法（后进先出）：push-和-pop\" class=\"headerlink\" title=\"栈方法（后进先出）：push() 和 pop()\"></a>栈方法（后进先出）：<code>push()</code> 和 <code>pop()</code></h3><p>// 越后面加入数组的，越先被<code>pop()</code>移除<br><code>push()</code> 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。<br><code>pop()</code> 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var colors = [];                            // 创建一个数组</span><br><span class=\"line\">var count = colors.push(&quot;red&quot;, &quot;green&quot;);    // 推入两项</span><br><span class=\"line\">console.log(count);                         // 2，数组的长度</span><br><span class=\"line\"></span><br><span class=\"line\">count = colors.push(&quot;black&quot;);               // 推入另一项</span><br><span class=\"line\">console.log(count);                         // 3，数组的长度</span><br><span class=\"line\"></span><br><span class=\"line\">var item = colors.pop();                    // 取得最后一项</span><br><span class=\"line\">console.log(item);                          // &quot;black&quot;,返回移除的项</span><br><span class=\"line\">console.log(colors.length);                 // 2，数组的长度</span><br></pre></td></tr></table></figure>\n<h3 id=\"队列方法（先进先出）push-和-shift\"><a href=\"#队列方法（先进先出）push-和-shift\" class=\"headerlink\" title=\"队列方法（先进先出）push() 和 shift()\"></a>队列方法（先进先出）<code>push()</code> 和 <code>shift()</code></h3><p><code>push()</code> 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。<br><code>shift()</code> 从数组前端移除第一项，减少数组的 length 值，然后返回移除的项。</p>\n<h3 id=\"反向队列方法（反方向先进先出）unshift-和pop\"><a href=\"#反向队列方法（反方向先进先出）unshift-和pop\" class=\"headerlink\" title=\"反向队列方法（反方向先进先出）unshift()和pop()\"></a>反向队列方法（反方向先进先出）<code>unshift()</code>和<code>pop()</code></h3><p><code>unshift()</code> 把任意数量参数逐个添加到数组前端，然后返回length 值<br><code>pop()</code> 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p>\n<h2 id=\"重排序方法\"><a href=\"#重排序方法\" class=\"headerlink\" title=\"重排序方法\"></a>重排序方法</h2><p>数组中有两个重排序的方法：reverse() 和 sort()。</p>\n<h4 id=\"reverse-方法可以反转数组元素的顺序。\"><a href=\"#reverse-方法可以反转数组元素的顺序。\" class=\"headerlink\" title=\"reverse() 方法可以反转数组元素的顺序。\"></a>reverse() 方法可以反转数组元素的顺序。</h4><h4 id=\"sort-方法可以按升序或降序排列数组元素。\"><a href=\"#sort-方法可以按升序或降序排列数组元素。\" class=\"headerlink\" title=\"sort() 方法可以按升序或降序排列数组元素。\"></a>sort() 方法可以按升序或降序排列数组元素。</h4><p>sort具体用法，可以查看<a href=\"https://blak-kong.github.io/2018/04/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjs%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/#more\">深入理解js对象排序-sort()</a></p>\n<p>通用代码演示<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [10, 20, 1, 2];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.sort(function (x, y) &#123;</span><br><span class=\"line\">    if (x &lt; y) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (x &gt; y) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(arr); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h2><h4 id=\"concat-基于当前数组中的所有项创建一个新数组。\"><a href=\"#concat-基于当前数组中的所有项创建一个新数组。\" class=\"headerlink\" title=\"concat() 基于当前数组中的所有项创建一个新数组。\"></a><code>concat()</code> 基于当前数组中的所有项创建一个新数组。</h4><p>这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class=\"line\">var b = a.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);//基于a创建新数组</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a);     // red,green,blue</span><br><span class=\"line\">console.log(b);    // red,green,blue,yellow,black,brown</span><br></pre></td></tr></table></figure>\n<h4 id=\"slice-它能够基于当前数组中的一或多个项创建一个新数组。\"><a href=\"#slice-它能够基于当前数组中的一或多个项创建一个新数组。\" class=\"headerlink\" title=\"slice() 它能够基于当前数组中的一或多个项创建一个新数组。\"></a><code>slice()</code> 它能够基于当前数组中的一或多个项创建一个新数组。</h4><p>slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。</p>\n<p>在只有一个参数的情况下，slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。</p>\n<ul>\n<li>注意，slice() 方法不会影响原始数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];</span><br><span class=\"line\">var a1 = a.slice(1);</span><br><span class=\"line\">var a2 = a.slice(1,4);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a1);   // green,blue,yellow,purple</span><br><span class=\"line\">console.log(a2);   // green,blue,yellow</span><br></pre></td></tr></table></figure>\n<h4 id=\"splice-它的主要用途是向数组的中部插入元素-或者进行删除、替换\"><a href=\"#splice-它的主要用途是向数组的中部插入元素-或者进行删除、替换\" class=\"headerlink\" title=\"splice() 它的主要用途是向数组的中部插入元素,或者进行删除、替换\"></a><code>splice()</code> 它的主要用途是向数组的中部插入元素,或者进行删除、替换</h4><p>写法：Array.splice(起始位置，删除数量，插入)</p>\n<p>只写前两项，是从指定位置开始删除<br>不写第二项，写第三项，是插入元素<br>三个都写，则是替换指定位置的元素</p>\n<h2 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h2><p>ECMAScript 5 为数组实例添加了两个位置方法：<br>indexOf() 和 lastIndexOf()。<br>这两个方法都接收两个参数：要<code>查找的项</code>和（可选的）<code>查找起点位置的索引</code></p>\n<h4 id=\"indexOf-方法从数组的开头（位置0）开始向后查找\"><a href=\"#indexOf-方法从数组的开头（位置0）开始向后查找\" class=\"headerlink\" title=\"indexOf() 方法从数组的开头（位置0）开始向后查找\"></a><code>indexOf()</code> 方法从数组的开头（位置0）开始向后查找</h4><h4 id=\"lastIndexOf-方法则从数组的末尾开始向前查找。\"><a href=\"#lastIndexOf-方法则从数组的末尾开始向前查找。\" class=\"headerlink\" title=\"lastIndexOf() 方法则从数组的末尾开始向前查找。\"></a><code>lastIndexOf()</code> 方法则从数组的末尾开始向前查找。</h4><p>注意：最终返回的索引，都是数组开头往后算。</p>\n<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1。<br>它们在比较第一个参数与数组中的每一项时，会使用全等操作符；<br>也就是说，要求查找的项必须严格相等（就像使用 === 一样）。</p>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class=\"line\">console.log(numbers.indexOf(4));          // 3 从前往后，查找数组第一个4</span><br><span class=\"line\">console.log(numbers.lastIndexOf(4));      // 5 从后往前，查找数组第一个4</span><br><span class=\"line\">console.log(numbers.indexOf(4, 4));       // 5 从前往后，从索引4开始查找元素4</span><br><span class=\"line\">console.log(numbers.lastIndexOf(4, 4));   // 3 从后往前，从索引-4开始往前查找元素4</span><br><span class=\"line\"></span><br><span class=\"line\">var person = &#123; name: &quot;Nicholas&quot; &#125;;</span><br><span class=\"line\">var people = [&#123; name: &quot;Nicholas&quot; &#125;];</span><br><span class=\"line\">var morePeople = [person];</span><br><span class=\"line\">console.log(people.indexOf(person));      // -1  没找到 -1</span><br><span class=\"line\">console.log(morePeople.indexOf(person));  // 0   找到索引 0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h2><p>ECMAScript 5 为数组定义了5个迭代方法。</p>\n<p>每个方法都接收两个参数：要在每一项上运行的<code>函数</code>和（可选的）<code>运行该函数的作用域对象</code>。<br>传入这些方法中的函数会接收三个参数：<code>值</code>、<code>索引</code>和<code>数组对象本身</code>。<br>根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。</p>\n<p>通用使用方法</p>\n<ul>\n<li>array1.xxxx(callbackfn[, thisArg])</li>\n</ul>\n<p>array1<br>必需。一个数组对象。</p>\n<p>callbackfn<br>必需。一个接受最多三个参数的函数。对于数组中的每个元素，filter 方法都会调用 callbackfn 函数一次。</p>\n<p>thisArg<br>可选。可在 callbackfn 函数中为其引用 this 关键字的对象。如果省略 thisArg，则 undefined 将用作 this 值。</p>\n<p>以下是这5个迭代方法的作用。</p>\n<ul>\n<li><code>every()</code> 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true。</li>\n<li><code>filter()</code> 过滤器：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>\n<li><code>forEach()</code> 元素遍历：对数组中的每一项运行给定函数。这个方法没有返回值。</li>\n<li><code>map()</code> 数组映射：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>\n<li><code>some()</code> 对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true。</li>\n</ul>\n<p>5个迭代方法的用法：</p>\n<h4 id=\"every-确定数组的所有成员是否满足指定的测试。\"><a href=\"#every-确定数组的所有成员是否满足指定的测试。\" class=\"headerlink\" title=\"every() 确定数组的所有成员是否满足指定的测试。\"></a><code>every()</code> 确定数组的所有成员是否满足指定的测试。</h4><p>array1.every(callbackfn[, thisArg])</p>\n<ul>\n<li>判断数组元素是否全部都能整除2</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义回调函数</span><br><span class=\"line\">function CheckIfEven(value, index, ar) &#123; // CheckIfEven(值，索引，数组本身)</span><br><span class=\"line\"></span><br><span class=\"line\">    if (value % 2 == 0) &#123; // 取余，检查是否能整除2</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建数组 Create an array.</span><br><span class=\"line\">var numbers = [2, 4, 5, 6, 8];</span><br><span class=\"line\"></span><br><span class=\"line\">// 检查回调函数是否返回所有的数组值</span><br><span class=\"line\">if (numbers.every(CheckIfEven)) &#123;</span><br><span class=\"line\">        console.log(&quot;All are even.&quot;); // true,满足指定的测试时运行</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        console.log(&quot;Some are not even.&quot;); // false,不满足指定的测试时运行</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出(Output):  Some are not even.</span><br></pre></td></tr></table></figure>\n<h4 id=\"filter-返回数组中的满足回调函数中指定的条件的元素\"><a href=\"#filter-返回数组中的满足回调函数中指定的条件的元素\" class=\"headerlink\" title=\"filter() 返回数组中的满足回调函数中指定的条件的元素\"></a><code>filter()</code> 返回数组中的满足回调函数中指定的条件的元素</h4><p>array1.filter(callbackfn[, thisArg])</p>\n<ul>\n<li>以下代码为，使用过滤器判断数组中的质数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义回调函数</span><br><span class=\"line\">function CheckIfPrime(value, index, ar) &#123;</span><br><span class=\"line\">    // Math.floor向下取整</span><br><span class=\"line\">    // Math.sqrt() 方法可返回一个数的平方根。</span><br><span class=\"line\">    high = Math.floor(Math.sqrt(value)) + 1; // 平方根向下取整再加一</span><br><span class=\"line\"></span><br><span class=\"line\">    for (var div = 2; div &lt;= high; div++) &#123; // 判断是否能否被2以上的数整除</span><br><span class=\"line\">        if (value % div == 0) &#123; // 如果能被整除，则不是质数</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建初始数组</span><br><span class=\"line\">var numbers = [31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53];</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取原始数组中的质数</span><br><span class=\"line\">var primes = numbers.filter(CheckIfPrime);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(primes);  // [31,37,41,43,47,53]</span><br></pre></td></tr></table></figure>\n<h4 id=\"forEach-为数组中的每个元素执行指定操作。\"><a href=\"#forEach-为数组中的每个元素执行指定操作。\" class=\"headerlink\" title=\"forEach() 为数组中的每个元素执行指定操作。\"></a><code>forEach()</code> 为数组中的每个元素执行指定操作。</h4><p>array1.forEach(callbackfn[, thisArg])</p>\n<p>若不写回调函数，则默认操作为遍历所有元素。</p>\n<ul>\n<li>以下代码为，数组求和</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建数组</span><br><span class=\"line\">var numbers = [10, 11, 12];</span><br><span class=\"line\"></span><br><span class=\"line\">// 调用每个数组元素，并回调函数</span><br><span class=\"line\">var sum = 0;</span><br><span class=\"line\">numbers.forEach(</span><br><span class=\"line\">    function addNumber(value) &#123; sum += value; &#125; // 所有元素加起来</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(sum);  // 输出(Output): 33</span><br></pre></td></tr></table></figure>\n<h4 id=\"map-对数组的每个元素调用定义的回调函数，并返回包含结果的数组。\"><a href=\"#map-对数组的每个元素调用定义的回调函数，并返回包含结果的数组。\" class=\"headerlink\" title=\"map() 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。\"></a><code>map()</code> 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。</h4><p>array1.map(callbackfn[, thisArg])</p>\n<ul>\n<li>以下代码为，数组取余</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个包含取余属性的对象</span><br><span class=\"line\">// 原型方法定义</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    divisor: 10, // 除以10</span><br><span class=\"line\">    remainder: function (value) &#123;</span><br><span class=\"line\">        return value % this.divisor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建数组</span><br><span class=\"line\">var numbers = [6, 12, 25, 30];</span><br><span class=\"line\"></span><br><span class=\"line\">// 获取余数</span><br><span class=\"line\">var result = numbers.map(obj.remainder, obj);</span><br><span class=\"line\">console.log(result);</span><br><span class=\"line\"></span><br><span class=\"line\">// 输出(Output):  [6,2,5,0]</span><br></pre></td></tr></table></figure>\n<h4 id=\"some-确定指定的回调函数是否为数组中的任何元素均返回-true。\"><a href=\"#some-确定指定的回调函数是否为数组中的任何元素均返回-true。\" class=\"headerlink\" title=\"some() 确定指定的回调函数是否为数组中的任何元素均返回 true。\"></a><code>some()</code> 确定指定的回调函数是否为数组中的任何元素均返回 true。</h4><p>array1.some(callbackfn[, thisArg])</p>\n<ul>\n<li>some()判断是否存在至少一个数符合条件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建一个函数，如果值为true，则返回true。</span><br><span class=\"line\">var isOutsideRange = function (value) &#123;</span><br><span class=\"line\">    // 检测是否超出范围</span><br><span class=\"line\">    return value &lt; this.minimum || value &gt; this.maximum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建数组.</span><br><span class=\"line\">var numbers = [6, 12, 16, 22, -12];</span><br><span class=\"line\"></span><br><span class=\"line\">// 范围对象是“这个”对象。</span><br><span class=\"line\">var range = &#123; minimum: 10, maximum: 20 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(numbers.some(isOutsideRange, range));  // true 存在小于10和大于20的数</span><br></pre></td></tr></table></figure>\n<h2 id=\"挑战-数组去重\"><a href=\"#挑战-数组去重\" class=\"headerlink\" title=\"挑战 数组去重\"></a>挑战 数组去重</h2><p>// 挑战一，一维数组</p>\n<ul>\n<li>思路<br>使用indexOf(i)检测新数组newArr里有没有包含Arr里的i项<br>如果没有则向newArr里添加Aii[i]项<br>如果有则跳过；不做任何操作。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [2,3,4,2,3,5,6,4,3,2];</span><br><span class=\"line\">var unique = function(arr)&#123;</span><br><span class=\"line\">    var result = []; // 创建空数组，用于存放新数组</span><br><span class=\"line\">    arr.forEach(function(item)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // indexOf()会使用全等操作符,判断item索引与遍历数组中所有元素都不相等，才运行</span><br><span class=\"line\">        if(result.indexOf(item) &lt; 0)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 此处代码，只有数组索引小于0（数组中不存在），才会运行</span><br><span class=\"line\">        // 所以可以达到去重效果</span><br><span class=\"line\">            result.push(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(unique(arr)); // [2,3,4,5,6]</span><br></pre></td></tr></table></figure>\n<p>// 挑战二（二维数组）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [2,3,4,[2,3,4,5],3,5,[2,3,4,2],4,3,6,2];</span><br><span class=\"line\">var unique = function(arr)&#123;</span><br><span class=\"line\">    var result = []; // 创建空数组，用于存放新数组</span><br><span class=\"line\">    arr.forEach(function(item) &#123; // 遍历数组元素给item</span><br><span class=\"line\">        if (Array.isArray(item)) &#123; // 判定item是否为数组，只有数组才能往下运行</span><br><span class=\"line\">            item.forEach(function(i) &#123; // 把item中的数组，遍历给i</span><br><span class=\"line\">                // indexOf()会使用全等操作符,判断i索引与遍历数组中所有元素都不相等，才能往下运行</span><br><span class=\"line\">                if (result.indexOf(i) &lt; 0) &#123;</span><br><span class=\"line\">                    result.push(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (result.indexOf(item) &lt; 0) &#123;</span><br><span class=\"line\">                result.push(item);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(unique(arr)); // [2,3,4,5,6]</span><br></pre></td></tr></table></figure></p>"},{"title":"js面向对象（原型链）","date":"2018-04-30T18:38:44.000Z","_content":"[toc]\n\n# 原型及原型链\n\n原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 __proto__ 属性指向创建它的构造函数的 prototype（原型）属性。\n原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、__proto__ 这五个概念入手。\n\n<!-- more -->\n\n# 函数对象\n\n前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。\n比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。\n下面示例代码对「普通对象」和「函数对象」进行了区分。\n\n普通对象\n```\nvar o1 = {};\nvar o2 = new Object();\n```\n\n函数对象\n```\nfunction f1(){};\nvar f2 = function(){};\nvar f3 = new Function('str','console.log(str)');\n```\n\n简单的说，凡是使用 function 关键字或 Function 构造函数创建的对象都是函数对象。\n而且，只有函数对象才拥有 `prototype` （原型）属性。\n\n## `constructor` 构造函数\n\n函数还有一种用法，就是把它作为构造函数使用。\n像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。\n此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。\n\n构造原型\n```\n<script>\n// 构造函数首字母应大写，便于区分普通函数\nfunction Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function(){\n        console.log(this.name);\n    };\n}\n\nvar person1 = new Person(\"Stone\", 28, \"Software Engineer\");\nvar person2 = new Person(\"Sophie\", 29, \"English Teacher\");\n<script/>\n```\n\n## `new` 操作符\n\n要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：\n\n1. 创建一个新对象；\n2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；\n3. 执行构造函数中的代码（为这个新对象添加属性）；\n4. 返回新对象。\n\n构造函数与其他函数的唯一区别，就在于调用它们的方式不同。\n\n>归根结底，使用 `new` 关键字，可以在后面跟随一个`函数调用`。\n\n只要通过 new 操作符来调用，那它就可以作为构造函数；\n而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。\n\n## 构造函数的问题\n构造函数模式虽然好用，但也并非没有缺点。\n使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。\n\n>函数名是指针，使用`构造函数调用`创建新对象，解决了内存覆盖问题：\n>但所有对象都是深拷贝，并没有变方便。没有必要创建两个完成同样任务的 Function 实例\n\n## `prototype` 原型\n\n我们创建的每个函数都有一个 prototype（原型）属性。\n使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。\n换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。\n\n```\nfunction Person(){}\n\nPerson.prototype.name = \"Stone\";\nPerson.prototype.age = 28;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName();   // \"Stone\"\n\nvar person2 = new Person();\nperson2.sayName();   // \"Stone\"\n\nconsole.log(person1.sayName == person2.sayName);  // true\n```\n此例子有缺陷，因为共享了内存。\n\n若是原型链中存在引用类型，那么一个值改变，所有值都会跟着改变。\n\n## 理解原型对象\n\n在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针（__potor__）。就拿前面的例子来说，Person.prototype.constructor 指向 Person。\n而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。\n\n此时，我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。\n如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。\n\n这就是js的屏蔽方法。\n当为对象实例添加一个属性时，这个属性就会屏蔽原型中保存的同名属性\n\n## 更简单的原型语法\n\n为了摆脱每添加一个属性和方法就要敲一遍 `Person.prototype`\n为了减少不必要的输入，也为了从视觉上更好地封装原型的功能\n常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象\n```\nfunction Person(){}\n\nPerson.prototype = {\n    name : \"Stone\",\n    age : 28,\n    job: \"Software Engineer\",\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n```\n\n注意：此时 `constructor` 属性不再指向 Person 了。尽管仍能使用。\n\n解决办法是把它加回去`constructor : Person`\n\n注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。\n默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。\n\n```\nfunction Person(){}\n\nPerson.prototype = {\n    name : \"Stone\",\n    age : 28,\n    job : \"Software Engineer\",\n    sayName : function () {\n        console.log(this.name);\n    }\n}; \n\n// 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器\n// Object.defineProperty(obj, prop, descriptor)\n// 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\nObject.defineProperty(Person.prototype, \"constructor\", {\n    enumerable: false,\n    value: Person\n});\n```\nobj: 要在其上定义属性的对象。\nprop: 要定义或修改的属性的名称。\ndescriptor: 将被定义或修改的属性描述符。\n\n## 原型的动态性\n\n由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。\n```\nvar friend = new Person();\n\nPerson.prototype.sayHi = function(){\n    console.log(\"hi\");\n};\n\nfriend.sayHi();   // \"hi\"（没有问题！）\n```\n其原因可以归结为实例与原型之间的松散连接关系。\n因为实例与原型之间的连接只不过是一个指针，而非一个副本.\n\n\n但如果是重写整个原型对象，那么情况就不一样了。\n我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]的 `__potoy__` 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。\n\n>请记住：实例中的指针仅指向原型，而不指向构造函数。\n\n## 原型对象的问题\n\n原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，问题很突出\n\n```\nfunction Person(){}\n\nPerson.prototype = {\n    constructor: Person,\n    name : \"Stone\",\n    age : 28,\n    job : \"Software Engineer\",\n    friends : [\"ZhangSan\", \"LiSi\"],\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\"WangWu\");\n\nconsole.log(person1.friends);    // \"ZhangSan,LiSi,WangWu\"\nconsole.log(person2.friends);    // \"ZhangSan,LiSi,WangWu\"\nconsole.log(person1.friends === person2.friends);  // true\n```\n\n>引用类型单独占一块堆内存,连原型也只是指针指向数组\n\n## 构造函数和原型结合\n\n#### 构造函数用于定义实例属性，而原型用于定义方法和共享的属性。\n结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。\n下面的代码重写了前面的例子\n\n```\nfunction Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = [\"ZhangSan\", \"LiSi\"];\n}\n\nPerson.prototype = {\n    constructor : Person,\n    sayName : function(){\n        console.log(this.name);\n    }\n}\n\nvar person1 = new Person(\"Stone\", 28, \"Software Engineer\");\nvar person2 = new Person(\"Sophie\", 29, \"English Teacher\");\n\nperson1.friends.push(\"WangWu\");\nconsole.log(person1.friends);    // \"ZhangSan,LiSi,WangWu\"\nconsole.log(person2.friends);    // \"ZhangSan,LiSi\"\nconsole.log(person1.friends === person2.friends);    // false\n```\n构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。\n\n## __proto__\n\n当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 __proto__ , 指向构造函数的原型。\n```\nfunction Person(){}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\nObject.__proto__ = Object.prototype;\n\n## 原型链\nJavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。\n其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\n\n简单回顾一下构造函数、原型和实例的关系：\n\n每个构造函数都有一个原型对象(调用对象)\n原型对象都包含一个指向构造函数的指针(prototype)\n而实例都包含一个指向原型对象的内部指针。(__proto__)\n\n","source":"_posts/js面向对象（原型链）.md","raw":"---\ntitle: js面向对象（原型链）\ndate: 2018-05-01 02:38:44\ncategories:\n  - JS学习笔记\ntags:\n  - 面向对象 原型链 js\n---\n[toc]\n\n# 原型及原型链\n\n原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 __proto__ 属性指向创建它的构造函数的 prototype（原型）属性。\n原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、__proto__ 这五个概念入手。\n\n<!-- more -->\n\n# 函数对象\n\n前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。\n比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。\n下面示例代码对「普通对象」和「函数对象」进行了区分。\n\n普通对象\n```\nvar o1 = {};\nvar o2 = new Object();\n```\n\n函数对象\n```\nfunction f1(){};\nvar f2 = function(){};\nvar f3 = new Function('str','console.log(str)');\n```\n\n简单的说，凡是使用 function 关键字或 Function 构造函数创建的对象都是函数对象。\n而且，只有函数对象才拥有 `prototype` （原型）属性。\n\n## `constructor` 构造函数\n\n函数还有一种用法，就是把它作为构造函数使用。\n像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。\n此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。\n\n构造原型\n```\n<script>\n// 构造函数首字母应大写，便于区分普通函数\nfunction Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function(){\n        console.log(this.name);\n    };\n}\n\nvar person1 = new Person(\"Stone\", 28, \"Software Engineer\");\nvar person2 = new Person(\"Sophie\", 29, \"English Teacher\");\n<script/>\n```\n\n## `new` 操作符\n\n要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：\n\n1. 创建一个新对象；\n2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；\n3. 执行构造函数中的代码（为这个新对象添加属性）；\n4. 返回新对象。\n\n构造函数与其他函数的唯一区别，就在于调用它们的方式不同。\n\n>归根结底，使用 `new` 关键字，可以在后面跟随一个`函数调用`。\n\n只要通过 new 操作符来调用，那它就可以作为构造函数；\n而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。\n\n## 构造函数的问题\n构造函数模式虽然好用，但也并非没有缺点。\n使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。\n\n>函数名是指针，使用`构造函数调用`创建新对象，解决了内存覆盖问题：\n>但所有对象都是深拷贝，并没有变方便。没有必要创建两个完成同样任务的 Function 实例\n\n## `prototype` 原型\n\n我们创建的每个函数都有一个 prototype（原型）属性。\n使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。\n换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。\n\n```\nfunction Person(){}\n\nPerson.prototype.name = \"Stone\";\nPerson.prototype.age = 28;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName();   // \"Stone\"\n\nvar person2 = new Person();\nperson2.sayName();   // \"Stone\"\n\nconsole.log(person1.sayName == person2.sayName);  // true\n```\n此例子有缺陷，因为共享了内存。\n\n若是原型链中存在引用类型，那么一个值改变，所有值都会跟着改变。\n\n## 理解原型对象\n\n在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针（__potor__）。就拿前面的例子来说，Person.prototype.constructor 指向 Person。\n而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。\n\n此时，我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。\n如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。\n\n这就是js的屏蔽方法。\n当为对象实例添加一个属性时，这个属性就会屏蔽原型中保存的同名属性\n\n## 更简单的原型语法\n\n为了摆脱每添加一个属性和方法就要敲一遍 `Person.prototype`\n为了减少不必要的输入，也为了从视觉上更好地封装原型的功能\n常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象\n```\nfunction Person(){}\n\nPerson.prototype = {\n    name : \"Stone\",\n    age : 28,\n    job: \"Software Engineer\",\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n```\n\n注意：此时 `constructor` 属性不再指向 Person 了。尽管仍能使用。\n\n解决办法是把它加回去`constructor : Person`\n\n注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。\n默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。\n\n```\nfunction Person(){}\n\nPerson.prototype = {\n    name : \"Stone\",\n    age : 28,\n    job : \"Software Engineer\",\n    sayName : function () {\n        console.log(this.name);\n    }\n}; \n\n// 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器\n// Object.defineProperty(obj, prop, descriptor)\n// 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\nObject.defineProperty(Person.prototype, \"constructor\", {\n    enumerable: false,\n    value: Person\n});\n```\nobj: 要在其上定义属性的对象。\nprop: 要定义或修改的属性的名称。\ndescriptor: 将被定义或修改的属性描述符。\n\n## 原型的动态性\n\n由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。\n```\nvar friend = new Person();\n\nPerson.prototype.sayHi = function(){\n    console.log(\"hi\");\n};\n\nfriend.sayHi();   // \"hi\"（没有问题！）\n```\n其原因可以归结为实例与原型之间的松散连接关系。\n因为实例与原型之间的连接只不过是一个指针，而非一个副本.\n\n\n但如果是重写整个原型对象，那么情况就不一样了。\n我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]的 `__potoy__` 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。\n\n>请记住：实例中的指针仅指向原型，而不指向构造函数。\n\n## 原型对象的问题\n\n原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，问题很突出\n\n```\nfunction Person(){}\n\nPerson.prototype = {\n    constructor: Person,\n    name : \"Stone\",\n    age : 28,\n    job : \"Software Engineer\",\n    friends : [\"ZhangSan\", \"LiSi\"],\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\"WangWu\");\n\nconsole.log(person1.friends);    // \"ZhangSan,LiSi,WangWu\"\nconsole.log(person2.friends);    // \"ZhangSan,LiSi,WangWu\"\nconsole.log(person1.friends === person2.friends);  // true\n```\n\n>引用类型单独占一块堆内存,连原型也只是指针指向数组\n\n## 构造函数和原型结合\n\n#### 构造函数用于定义实例属性，而原型用于定义方法和共享的属性。\n结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。\n下面的代码重写了前面的例子\n\n```\nfunction Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = [\"ZhangSan\", \"LiSi\"];\n}\n\nPerson.prototype = {\n    constructor : Person,\n    sayName : function(){\n        console.log(this.name);\n    }\n}\n\nvar person1 = new Person(\"Stone\", 28, \"Software Engineer\");\nvar person2 = new Person(\"Sophie\", 29, \"English Teacher\");\n\nperson1.friends.push(\"WangWu\");\nconsole.log(person1.friends);    // \"ZhangSan,LiSi,WangWu\"\nconsole.log(person2.friends);    // \"ZhangSan,LiSi\"\nconsole.log(person1.friends === person2.friends);    // false\n```\n构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。\n\n## __proto__\n\n当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 __proto__ , 指向构造函数的原型。\n```\nfunction Person(){}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\nObject.__proto__ = Object.prototype;\n\n## 原型链\nJavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。\n其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\n\n简单回顾一下构造函数、原型和实例的关系：\n\n每个构造函数都有一个原型对象(调用对象)\n原型对象都包含一个指向构造函数的指针(prototype)\n而实例都包含一个指向原型对象的内部指针。(__proto__)\n\n","slug":"js面向对象（原型链）","published":1,"updated":"2019-06-16T08:31:46.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhf6000j9kudsrufuq7g","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h1 id=\"原型及原型链\"><a href=\"#原型及原型链\" class=\"headerlink\" title=\"原型及原型链\"></a>原型及原型链</h1><p>原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 <strong>proto</strong> 属性指向创建它的构造函数的 prototype（原型）属性。<br>原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、<strong>proto</strong> 这五个概念入手。</p>\n<a id=\"more\"></a>\n<h1 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h1><p>前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。<br>比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。<br>下面示例代码对「普通对象」和「函数对象」进行了区分。</p>\n<p>普通对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 = &#123;&#125;;</span><br><span class=\"line\">var o2 = new Object();</span><br></pre></td></tr></table></figure></p>\n<p>函数对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1()&#123;&#125;;</span><br><span class=\"line\">var f2 = function()&#123;&#125;;</span><br><span class=\"line\">var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>简单的说，凡是使用 function 关键字或 Function 构造函数创建的对象都是函数对象。<br>而且，只有函数对象才拥有 <code>prototype</code> （原型）属性。</p>\n<h2 id=\"constructor-构造函数\"><a href=\"#constructor-构造函数\" class=\"headerlink\" title=\"constructor 构造函数\"></a><code>constructor</code> 构造函数</h2><p>函数还有一种用法，就是把它作为构造函数使用。<br>像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。<br>此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。</p>\n<p>构造原型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 构造函数首字母应大写，便于区分普通函数</span><br><span class=\"line\">function Person(name, age, job)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">    this.job = job;</span><br><span class=\"line\">    this.sayName = function()&#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class=\"line\">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class=\"line\">&lt;script/&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"new-操作符\"><a href=\"#new-操作符\" class=\"headerlink\" title=\"new 操作符\"></a><code>new</code> 操作符</h2><p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p>\n<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）；</li>\n<li>返回新对象。</li>\n</ol>\n<p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。</p>\n<blockquote>\n<p>归根结底，使用 <code>new</code> 关键字，可以在后面跟随一个<code>函数调用</code>。</p>\n</blockquote>\n<p>只要通过 new 操作符来调用，那它就可以作为构造函数；<br>而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。</p>\n<h2 id=\"构造函数的问题\"><a href=\"#构造函数的问题\" class=\"headerlink\" title=\"构造函数的问题\"></a>构造函数的问题</h2><p>构造函数模式虽然好用，但也并非没有缺点。<br>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</p>\n<blockquote>\n<p>函数名是指针，使用<code>构造函数调用</code>创建新对象，解决了内存覆盖问题：<br>但所有对象都是深拷贝，并没有变方便。没有必要创建两个完成同样任务的 Function 实例</p>\n</blockquote>\n<h2 id=\"prototype-原型\"><a href=\"#prototype-原型\" class=\"headerlink\" title=\"prototype 原型\"></a><code>prototype</code> 原型</h2><p>我们创建的每个函数都有一个 prototype（原型）属性。<br>使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。<br>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.name = &quot;Stone&quot;;</span><br><span class=\"line\">Person.prototype.age = 28;</span><br><span class=\"line\">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class=\"line\">Person.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = new Person();</span><br><span class=\"line\">person1.sayName();   // &quot;Stone&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var person2 = new Person();</span><br><span class=\"line\">person2.sayName();   // &quot;Stone&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person1.sayName == person2.sayName);  // true</span><br></pre></td></tr></table></figure>\n<p>此例子有缺陷，因为共享了内存。</p>\n<p>若是原型链中存在引用类型，那么一个值改变，所有值都会跟着改变。</p>\n<h2 id=\"理解原型对象\"><a href=\"#理解原型对象\" class=\"headerlink\" title=\"理解原型对象\"></a>理解原型对象</h2><p>在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针（<strong>potor</strong>）。就拿前面的例子来说，Person.prototype.constructor 指向 Person。<br>而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p>\n<p>此时，我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。<br>如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。</p>\n<p>这就是js的屏蔽方法。<br>当为对象实例添加一个属性时，这个属性就会屏蔽原型中保存的同名属性</p>\n<h2 id=\"更简单的原型语法\"><a href=\"#更简单的原型语法\" class=\"headerlink\" title=\"更简单的原型语法\"></a>更简单的原型语法</h2><p>为了摆脱每添加一个属性和方法就要敲一遍 <code>Person.prototype</code><br>为了减少不必要的输入，也为了从视觉上更好地封装原型的功能<br>常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    name : &quot;Stone&quot;,</span><br><span class=\"line\">    age : 28,</span><br><span class=\"line\">    job: &quot;Software Engineer&quot;,</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意：此时 <code>constructor</code> 属性不再指向 Person 了。尽管仍能使用。</p>\n<p>解决办法是把它加回去<code>constructor : Person</code></p>\n<p>注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。<br>默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    name : &quot;Stone&quot;,</span><br><span class=\"line\">    age : 28,</span><br><span class=\"line\">    job : &quot;Software Engineer&quot;,</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">// 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器</span><br><span class=\"line\">// Object.defineProperty(obj, prop, descriptor)</span><br><span class=\"line\">// 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</span><br><span class=\"line\">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class=\"line\">    enumerable: false,</span><br><span class=\"line\">    value: Person</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>obj: 要在其上定义属性的对象。<br>prop: 要定义或修改的属性的名称。<br>descriptor: 将被定义或修改的属性描述符。</p>\n<h2 id=\"原型的动态性\"><a href=\"#原型的动态性\" class=\"headerlink\" title=\"原型的动态性\"></a>原型的动态性</h2><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var friend = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.sayHi = function()&#123;</span><br><span class=\"line\">    console.log(&quot;hi&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">friend.sayHi();   // &quot;hi&quot;（没有问题！）</span><br></pre></td></tr></table></figure></p>\n<p>其原因可以归结为实例与原型之间的松散连接关系。<br>因为实例与原型之间的连接只不过是一个指针，而非一个副本.</p>\n<p>但如果是重写整个原型对象，那么情况就不一样了。<br>我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]的 <code>__potoy__</code> 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p>\n<blockquote>\n<p>请记住：实例中的指针仅指向原型，而不指向构造函数。</p>\n</blockquote>\n<h2 id=\"原型对象的问题\"><a href=\"#原型对象的问题\" class=\"headerlink\" title=\"原型对象的问题\"></a>原型对象的问题</h2><p>原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，问题很突出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    constructor: Person,</span><br><span class=\"line\">    name : &quot;Stone&quot;,</span><br><span class=\"line\">    age : 28,</span><br><span class=\"line\">    job : &quot;Software Engineer&quot;,</span><br><span class=\"line\">    friends : [&quot;ZhangSan&quot;, &quot;LiSi&quot;],</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = new Person();</span><br><span class=\"line\">var person2 = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(&quot;WangWu&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class=\"line\">console.log(person2.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class=\"line\">console.log(person1.friends === person2.friends);  // true</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>引用类型单独占一块堆内存,连原型也只是指针指向数组</p>\n</blockquote>\n<h2 id=\"构造函数和原型结合\"><a href=\"#构造函数和原型结合\" class=\"headerlink\" title=\"构造函数和原型结合\"></a>构造函数和原型结合</h2><h4 id=\"构造函数用于定义实例属性，而原型用于定义方法和共享的属性。\"><a href=\"#构造函数用于定义实例属性，而原型用于定义方法和共享的属性。\" class=\"headerlink\" title=\"构造函数用于定义实例属性，而原型用于定义方法和共享的属性。\"></a>构造函数用于定义实例属性，而原型用于定义方法和共享的属性。</h4><p>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。<br>下面的代码重写了前面的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name, age, job)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">    this.job = job;</span><br><span class=\"line\">    this.friends = [&quot;ZhangSan&quot;, &quot;LiSi&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    constructor : Person,</span><br><span class=\"line\">    sayName : function()&#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class=\"line\">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(&quot;WangWu&quot;);</span><br><span class=\"line\">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class=\"line\">console.log(person2.friends);    // &quot;ZhangSan,LiSi&quot;</span><br><span class=\"line\">console.log(person1.friends === person2.friends);    // false</span><br></pre></td></tr></table></figure>\n<p>构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>\n<h2 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"proto\"></a><strong>proto</strong></h2><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 <strong>proto</strong> , 指向构造函数的原型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\">var person = new Person();</span><br><span class=\"line\">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure></p>\n<p>Object.<strong>proto</strong> = Object.prototype;</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>JavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。<br>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p>简单回顾一下构造函数、原型和实例的关系：</p>\n<p>每个构造函数都有一个原型对象(调用对象)<br>原型对象都包含一个指向构造函数的指针(prototype)<br>而实例都包含一个指向原型对象的内部指针。(<strong>proto</strong>)</p>\n","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h1 id=\"原型及原型链\"><a href=\"#原型及原型链\" class=\"headerlink\" title=\"原型及原型链\"></a>原型及原型链</h1><p>原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 <strong>proto</strong> 属性指向创建它的构造函数的 prototype（原型）属性。<br>原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、<strong>proto</strong> 这五个概念入手。</p>","more":"<h1 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h1><p>前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。<br>比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。<br>下面示例代码对「普通对象」和「函数对象」进行了区分。</p>\n<p>普通对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 = &#123;&#125;;</span><br><span class=\"line\">var o2 = new Object();</span><br></pre></td></tr></table></figure></p>\n<p>函数对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1()&#123;&#125;;</span><br><span class=\"line\">var f2 = function()&#123;&#125;;</span><br><span class=\"line\">var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>简单的说，凡是使用 function 关键字或 Function 构造函数创建的对象都是函数对象。<br>而且，只有函数对象才拥有 <code>prototype</code> （原型）属性。</p>\n<h2 id=\"constructor-构造函数\"><a href=\"#constructor-构造函数\" class=\"headerlink\" title=\"constructor 构造函数\"></a><code>constructor</code> 构造函数</h2><p>函数还有一种用法，就是把它作为构造函数使用。<br>像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。<br>此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。</p>\n<p>构造原型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 构造函数首字母应大写，便于区分普通函数</span><br><span class=\"line\">function Person(name, age, job)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">    this.job = job;</span><br><span class=\"line\">    this.sayName = function()&#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class=\"line\">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class=\"line\">&lt;script/&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"new-操作符\"><a href=\"#new-操作符\" class=\"headerlink\" title=\"new 操作符\"></a><code>new</code> 操作符</h2><p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p>\n<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）；</li>\n<li>返回新对象。</li>\n</ol>\n<p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。</p>\n<blockquote>\n<p>归根结底，使用 <code>new</code> 关键字，可以在后面跟随一个<code>函数调用</code>。</p>\n</blockquote>\n<p>只要通过 new 操作符来调用，那它就可以作为构造函数；<br>而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。</p>\n<h2 id=\"构造函数的问题\"><a href=\"#构造函数的问题\" class=\"headerlink\" title=\"构造函数的问题\"></a>构造函数的问题</h2><p>构造函数模式虽然好用，但也并非没有缺点。<br>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</p>\n<blockquote>\n<p>函数名是指针，使用<code>构造函数调用</code>创建新对象，解决了内存覆盖问题：<br>但所有对象都是深拷贝，并没有变方便。没有必要创建两个完成同样任务的 Function 实例</p>\n</blockquote>\n<h2 id=\"prototype-原型\"><a href=\"#prototype-原型\" class=\"headerlink\" title=\"prototype 原型\"></a><code>prototype</code> 原型</h2><p>我们创建的每个函数都有一个 prototype（原型）属性。<br>使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。<br>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.name = &quot;Stone&quot;;</span><br><span class=\"line\">Person.prototype.age = 28;</span><br><span class=\"line\">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class=\"line\">Person.prototype.sayName = function()&#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = new Person();</span><br><span class=\"line\">person1.sayName();   // &quot;Stone&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var person2 = new Person();</span><br><span class=\"line\">person2.sayName();   // &quot;Stone&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person1.sayName == person2.sayName);  // true</span><br></pre></td></tr></table></figure>\n<p>此例子有缺陷，因为共享了内存。</p>\n<p>若是原型链中存在引用类型，那么一个值改变，所有值都会跟着改变。</p>\n<h2 id=\"理解原型对象\"><a href=\"#理解原型对象\" class=\"headerlink\" title=\"理解原型对象\"></a>理解原型对象</h2><p>在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针（<strong>potor</strong>）。就拿前面的例子来说，Person.prototype.constructor 指向 Person。<br>而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p>\n<p>此时，我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。<br>如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。</p>\n<p>这就是js的屏蔽方法。<br>当为对象实例添加一个属性时，这个属性就会屏蔽原型中保存的同名属性</p>\n<h2 id=\"更简单的原型语法\"><a href=\"#更简单的原型语法\" class=\"headerlink\" title=\"更简单的原型语法\"></a>更简单的原型语法</h2><p>为了摆脱每添加一个属性和方法就要敲一遍 <code>Person.prototype</code><br>为了减少不必要的输入，也为了从视觉上更好地封装原型的功能<br>常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    name : &quot;Stone&quot;,</span><br><span class=\"line\">    age : 28,</span><br><span class=\"line\">    job: &quot;Software Engineer&quot;,</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意：此时 <code>constructor</code> 属性不再指向 Person 了。尽管仍能使用。</p>\n<p>解决办法是把它加回去<code>constructor : Person</code></p>\n<p>注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。<br>默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    name : &quot;Stone&quot;,</span><br><span class=\"line\">    age : 28,</span><br><span class=\"line\">    job : &quot;Software Engineer&quot;,</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">// 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器</span><br><span class=\"line\">// Object.defineProperty(obj, prop, descriptor)</span><br><span class=\"line\">// 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</span><br><span class=\"line\">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class=\"line\">    enumerable: false,</span><br><span class=\"line\">    value: Person</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>obj: 要在其上定义属性的对象。<br>prop: 要定义或修改的属性的名称。<br>descriptor: 将被定义或修改的属性描述符。</p>\n<h2 id=\"原型的动态性\"><a href=\"#原型的动态性\" class=\"headerlink\" title=\"原型的动态性\"></a>原型的动态性</h2><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var friend = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.sayHi = function()&#123;</span><br><span class=\"line\">    console.log(&quot;hi&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">friend.sayHi();   // &quot;hi&quot;（没有问题！）</span><br></pre></td></tr></table></figure></p>\n<p>其原因可以归结为实例与原型之间的松散连接关系。<br>因为实例与原型之间的连接只不过是一个指针，而非一个副本.</p>\n<p>但如果是重写整个原型对象，那么情况就不一样了。<br>我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]的 <code>__potoy__</code> 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p>\n<blockquote>\n<p>请记住：实例中的指针仅指向原型，而不指向构造函数。</p>\n</blockquote>\n<h2 id=\"原型对象的问题\"><a href=\"#原型对象的问题\" class=\"headerlink\" title=\"原型对象的问题\"></a>原型对象的问题</h2><p>原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，问题很突出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    constructor: Person,</span><br><span class=\"line\">    name : &quot;Stone&quot;,</span><br><span class=\"line\">    age : 28,</span><br><span class=\"line\">    job : &quot;Software Engineer&quot;,</span><br><span class=\"line\">    friends : [&quot;ZhangSan&quot;, &quot;LiSi&quot;],</span><br><span class=\"line\">    sayName : function () &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = new Person();</span><br><span class=\"line\">var person2 = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(&quot;WangWu&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class=\"line\">console.log(person2.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class=\"line\">console.log(person1.friends === person2.friends);  // true</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>引用类型单独占一块堆内存,连原型也只是指针指向数组</p>\n</blockquote>\n<h2 id=\"构造函数和原型结合\"><a href=\"#构造函数和原型结合\" class=\"headerlink\" title=\"构造函数和原型结合\"></a>构造函数和原型结合</h2><h4 id=\"构造函数用于定义实例属性，而原型用于定义方法和共享的属性。\"><a href=\"#构造函数用于定义实例属性，而原型用于定义方法和共享的属性。\" class=\"headerlink\" title=\"构造函数用于定义实例属性，而原型用于定义方法和共享的属性。\"></a>构造函数用于定义实例属性，而原型用于定义方法和共享的属性。</h4><p>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。<br>下面的代码重写了前面的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name, age, job)&#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">    this.job = job;</span><br><span class=\"line\">    this.friends = [&quot;ZhangSan&quot;, &quot;LiSi&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    constructor : Person,</span><br><span class=\"line\">    sayName : function()&#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class=\"line\">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(&quot;WangWu&quot;);</span><br><span class=\"line\">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class=\"line\">console.log(person2.friends);    // &quot;ZhangSan,LiSi&quot;</span><br><span class=\"line\">console.log(person1.friends === person2.friends);    // false</span><br></pre></td></tr></table></figure>\n<p>构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>\n<h2 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"proto\"></a><strong>proto</strong></h2><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 <strong>proto</strong> , 指向构造函数的原型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\">var person = new Person();</span><br><span class=\"line\">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure></p>\n<p>Object.<strong>proto</strong> = Object.prototype;</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>JavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。<br>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p>简单回顾一下构造函数、原型和实例的关系：</p>\n<p>每个构造函数都有一个原型对象(调用对象)<br>原型对象都包含一个指向构造函数的指针(prototype)<br>而实例都包含一个指向原型对象的内部指针。(<strong>proto</strong>)</p>"},{"title":"使用css module替代scopet","date":"2018-04-08T12:26:53.000Z","_content":"\n[toc]\n\n# 关于CSS Module\n\n- css modules是一种流行的模块化和组合CSS的系统。 vue-loader提供了与css modules的集成，作为scope CSS的替代方案。\n\n<!-- more -->\n\n## vue引入scopet，有缺陷的样式私有化\n最开始的时候，我们提倡并大量使用的是scoped这种技术\n在vue组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style标签上添加scoped属性，以表示它的只属于当下的模块，这是一个非常好的举措。\n\t<style scoped>\n\t  @media (min-width: 250px) {\n    .list-container:hover {\n      background: orange;\n    }\n\t}\n\t</style>\n\n    <!-- more -->\n\n这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域\n编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover\n\n- 但是，它并不能完全避免冲突\n\n如果用户在不同的父子级，定义了一个重复的类名，会影响到所有定义为errShow类名的组件的显示\n并且它会造成一种后果，每个样式的权重加重了：\n理论上我们要去修改这个样式，需要更高的权重去覆盖这个样式。\n这是增加复杂度的其中一个维度。\n\n### CSS modules则做的更好，它不是添加属性，而是直接改变类名\n\nSS Modules既不是官方标准，也不是浏览器的特性，而是在构建步骤中对CSS类名选择器限定作用域的一种方式（通过hash实现类似于命名空间的方法）。\n\n- 类名是动态生成的，唯一的，并准确对应到源文件中的各个类的样式。\n\n实际上，CSS Modules只是CSS模块化的一种方式。为什么我们需要CSS模块化呢？\n\nCSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。于是，亟待解决的就是样式冲突（污染）的问题。一般地，为了解决冲突，会把class命名写长一点，降低冲突几率；加上父元素的选择器，来限制范围等……\n\nCSS模块化就是来解决这个问题的，一般地，分为三类\n\n　　1、命名约定类\n\n　　该类CSS模块化方案主要用来规范CSS命名，最常见的是BEM，当然还有OOCSS等，在构建工具出现之前，大多数都是在CSS命名上做文章\n\n　　2、CSS in JS\n\n　　彻底抛弃CSS，用javascript来写CSS规则，常见的有styled-components\n\n　　3、使用JS来管理样式\n\n　　使用JS编译原生的CSS文件，使其具备模块化的能力，最常见的就是CSS Modules\n\n　　随着构建工具的兴起，越来越多的人开始使用后两者方案，书写CSS时，不用再特意地关心样式冲突问题。只需要使用约定的格式编写代码即可\n\n## VUE的CSS Module写法\n\n- 使用时需要进行添加`v-bind`，如样式绑定简写 `:class`\n\n① 在style标签中添加module属性，表示打开CSS-loader的模块模式\n\n\t<style module>\n\t.red {color: red;}\n\t</style>\n\n② 在模板中使用动态类绑定 `:class` ，并在类名前面加上 `$style.`\n\n\t<template>\n\t  <p :class=\"$style.red\">\n\t    This should be red\n\t  </p>\n\t</template>\n\n③ 如果类名包含中划线，则使用中括号语法\n\n\t<h4 :class=\"$style['header-tit']\">类别推荐</h4>\n\n④ 也可以使用数组或对象语法\n\n\t<p :class=\"{ [$style.red]: isRed }\">\n\t      Am I red?\n\t</p>\n\t<p :class=\"[$style.red, $style.bold]\">\n\t      Red and bold\n\t</p>\n\n⑤ 更复杂的对象语法\n\n\t    <ul\n\t　　　 :class=\"{\n\t        [$style.panelBox]:true,\n\t        [$style.transitionByPanelBox]:needTransition\n\t      }\"\n⑥ 更复杂的数组语法\n\n\t<li\n\t      :class=\"[\n\t        $style['aside-item'],\n\t        {[$style['aside-item_active']]:(i === index)}\n\t      ]\"\n\n\n## 配置\n\ncss-loader关于CSS modules的默认配置如下\n\n\t{\n\t  modules: true,\n\t  importLoaders: 1,\n\t  localIdentName: '[hash:base64]'\n\t}\n\n可以使用vue-loader的cssModules选项为css-loader进行自定义的配置\n\n\tmodule: {\n\t  rules: [\n\t    {\n\t      test: '\\.vue$',\n\t      loader: 'vue-loader',\n\t      options: {\n\t        cssModules: {\n\t          localIdentName: '[path][name]---[local]---[hash:base64:5]',\n\t          camelCase: true\n\t        }\n\t      }\n\t    }\n\t  ]\n\t}\n","source":"_posts/module替代scopet.md","raw":"---\ntitle: 使用css module替代scopet\ndate: 2018-04-08 20:26:53\ncategories: 前端\ntags:\n  - css\n  - css模块化\n---\n\n[toc]\n\n# 关于CSS Module\n\n- css modules是一种流行的模块化和组合CSS的系统。 vue-loader提供了与css modules的集成，作为scope CSS的替代方案。\n\n<!-- more -->\n\n## vue引入scopet，有缺陷的样式私有化\n最开始的时候，我们提倡并大量使用的是scoped这种技术\n在vue组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style标签上添加scoped属性，以表示它的只属于当下的模块，这是一个非常好的举措。\n\t<style scoped>\n\t  @media (min-width: 250px) {\n    .list-container:hover {\n      background: orange;\n    }\n\t}\n\t</style>\n\n    <!-- more -->\n\n这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域\n编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover\n\n- 但是，它并不能完全避免冲突\n\n如果用户在不同的父子级，定义了一个重复的类名，会影响到所有定义为errShow类名的组件的显示\n并且它会造成一种后果，每个样式的权重加重了：\n理论上我们要去修改这个样式，需要更高的权重去覆盖这个样式。\n这是增加复杂度的其中一个维度。\n\n### CSS modules则做的更好，它不是添加属性，而是直接改变类名\n\nSS Modules既不是官方标准，也不是浏览器的特性，而是在构建步骤中对CSS类名选择器限定作用域的一种方式（通过hash实现类似于命名空间的方法）。\n\n- 类名是动态生成的，唯一的，并准确对应到源文件中的各个类的样式。\n\n实际上，CSS Modules只是CSS模块化的一种方式。为什么我们需要CSS模块化呢？\n\nCSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。于是，亟待解决的就是样式冲突（污染）的问题。一般地，为了解决冲突，会把class命名写长一点，降低冲突几率；加上父元素的选择器，来限制范围等……\n\nCSS模块化就是来解决这个问题的，一般地，分为三类\n\n　　1、命名约定类\n\n　　该类CSS模块化方案主要用来规范CSS命名，最常见的是BEM，当然还有OOCSS等，在构建工具出现之前，大多数都是在CSS命名上做文章\n\n　　2、CSS in JS\n\n　　彻底抛弃CSS，用javascript来写CSS规则，常见的有styled-components\n\n　　3、使用JS来管理样式\n\n　　使用JS编译原生的CSS文件，使其具备模块化的能力，最常见的就是CSS Modules\n\n　　随着构建工具的兴起，越来越多的人开始使用后两者方案，书写CSS时，不用再特意地关心样式冲突问题。只需要使用约定的格式编写代码即可\n\n## VUE的CSS Module写法\n\n- 使用时需要进行添加`v-bind`，如样式绑定简写 `:class`\n\n① 在style标签中添加module属性，表示打开CSS-loader的模块模式\n\n\t<style module>\n\t.red {color: red;}\n\t</style>\n\n② 在模板中使用动态类绑定 `:class` ，并在类名前面加上 `$style.`\n\n\t<template>\n\t  <p :class=\"$style.red\">\n\t    This should be red\n\t  </p>\n\t</template>\n\n③ 如果类名包含中划线，则使用中括号语法\n\n\t<h4 :class=\"$style['header-tit']\">类别推荐</h4>\n\n④ 也可以使用数组或对象语法\n\n\t<p :class=\"{ [$style.red]: isRed }\">\n\t      Am I red?\n\t</p>\n\t<p :class=\"[$style.red, $style.bold]\">\n\t      Red and bold\n\t</p>\n\n⑤ 更复杂的对象语法\n\n\t    <ul\n\t　　　 :class=\"{\n\t        [$style.panelBox]:true,\n\t        [$style.transitionByPanelBox]:needTransition\n\t      }\"\n⑥ 更复杂的数组语法\n\n\t<li\n\t      :class=\"[\n\t        $style['aside-item'],\n\t        {[$style['aside-item_active']]:(i === index)}\n\t      ]\"\n\n\n## 配置\n\ncss-loader关于CSS modules的默认配置如下\n\n\t{\n\t  modules: true,\n\t  importLoaders: 1,\n\t  localIdentName: '[hash:base64]'\n\t}\n\n可以使用vue-loader的cssModules选项为css-loader进行自定义的配置\n\n\tmodule: {\n\t  rules: [\n\t    {\n\t      test: '\\.vue$',\n\t      loader: 'vue-loader',\n\t      options: {\n\t        cssModules: {\n\t          localIdentName: '[path][name]---[local]---[hash:base64:5]',\n\t          camelCase: true\n\t        }\n\t      }\n\t    }\n\t  ]\n\t}\n","slug":"module替代scopet","published":1,"updated":"2019-06-16T08:32:03.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhf9000n9kud4p7ml3tf","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h1 id=\"关于CSS-Module\"><a href=\"#关于CSS-Module\" class=\"headerlink\" title=\"关于CSS Module\"></a>关于CSS Module</h1><ul>\n<li>css modules是一种流行的模块化和组合CSS的系统。 vue-loader提供了与css modules的集成，作为scope CSS的替代方案。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"vue引入scopet，有缺陷的样式私有化\"><a href=\"#vue引入scopet，有缺陷的样式私有化\" class=\"headerlink\" title=\"vue引入scopet，有缺陷的样式私有化\"></a>vue引入scopet，有缺陷的样式私有化</h2><p>最开始的时候，我们提倡并大量使用的是scoped这种技术<br>在vue组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style标签上添加scoped属性，以表示它的只属于当下的模块，这是一个非常好的举措。<br>    <style scoped><br>      @media (min-width: 250px) {<br>    .list-container:hover {<br>      background: orange;<br>    }<br>    }<br>    </style></p>\n<pre><code>&lt;!-- more --&gt;\n</code></pre><p>这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域<br>编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover</p>\n<ul>\n<li>但是，它并不能完全避免冲突</li>\n</ul>\n<p>如果用户在不同的父子级，定义了一个重复的类名，会影响到所有定义为errShow类名的组件的显示<br>并且它会造成一种后果，每个样式的权重加重了：<br>理论上我们要去修改这个样式，需要更高的权重去覆盖这个样式。<br>这是增加复杂度的其中一个维度。</p>\n<h3 id=\"CSS-modules则做的更好，它不是添加属性，而是直接改变类名\"><a href=\"#CSS-modules则做的更好，它不是添加属性，而是直接改变类名\" class=\"headerlink\" title=\"CSS modules则做的更好，它不是添加属性，而是直接改变类名\"></a>CSS modules则做的更好，它不是添加属性，而是直接改变类名</h3><p>SS Modules既不是官方标准，也不是浏览器的特性，而是在构建步骤中对CSS类名选择器限定作用域的一种方式（通过hash实现类似于命名空间的方法）。</p>\n<ul>\n<li>类名是动态生成的，唯一的，并准确对应到源文件中的各个类的样式。</li>\n</ul>\n<p>实际上，CSS Modules只是CSS模块化的一种方式。为什么我们需要CSS模块化呢？</p>\n<p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。于是，亟待解决的就是样式冲突（污染）的问题。一般地，为了解决冲突，会把class命名写长一点，降低冲突几率；加上父元素的选择器，来限制范围等……</p>\n<p>CSS模块化就是来解决这个问题的，一般地，分为三类</p>\n<p>　　1、命名约定类</p>\n<p>　　该类CSS模块化方案主要用来规范CSS命名，最常见的是BEM，当然还有OOCSS等，在构建工具出现之前，大多数都是在CSS命名上做文章</p>\n<p>　　2、CSS in JS</p>\n<p>　　彻底抛弃CSS，用javascript来写CSS规则，常见的有styled-components</p>\n<p>　　3、使用JS来管理样式</p>\n<p>　　使用JS编译原生的CSS文件，使其具备模块化的能力，最常见的就是CSS Modules</p>\n<p>　　随着构建工具的兴起，越来越多的人开始使用后两者方案，书写CSS时，不用再特意地关心样式冲突问题。只需要使用约定的格式编写代码即可</p>\n<h2 id=\"VUE的CSS-Module写法\"><a href=\"#VUE的CSS-Module写法\" class=\"headerlink\" title=\"VUE的CSS Module写法\"></a>VUE的CSS Module写法</h2><ul>\n<li>使用时需要进行添加<code>v-bind</code>，如样式绑定简写 <code>:class</code></li>\n</ul>\n<p>① 在style标签中添加module属性，表示打开CSS-loader的模块模式</p>\n<pre><code>&lt;style module&gt;\n.red {color: red;}\n&lt;/style&gt;\n</code></pre><p>② 在模板中使用动态类绑定 <code>:class</code> ，并在类名前面加上 <code>$style.</code></p>\n<pre><code>&lt;template&gt;\n  &lt;p :class=&quot;$style.red&quot;&gt;\n    This should be red\n  &lt;/p&gt;\n&lt;/template&gt;\n</code></pre><p>③ 如果类名包含中划线，则使用中括号语法</p>\n<pre><code>&lt;h4 :class=&quot;$style[&apos;header-tit&apos;]&quot;&gt;类别推荐&lt;/h4&gt;\n</code></pre><p>④ 也可以使用数组或对象语法</p>\n<pre><code>&lt;p :class=&quot;{ [$style.red]: isRed }&quot;&gt;\n      Am I red?\n&lt;/p&gt;\n&lt;p :class=&quot;[$style.red, $style.bold]&quot;&gt;\n      Red and bold\n&lt;/p&gt;\n</code></pre><p>⑤ 更复杂的对象语法</p>\n<pre><code>&lt;ul\n　　　 :class=&quot;{\n    [$style.panelBox]:true,\n    [$style.transitionByPanelBox]:needTransition\n  }&quot;\n</code></pre><p>⑥ 更复杂的数组语法</p>\n<pre><code>&lt;li\n      :class=&quot;[\n        $style[&apos;aside-item&apos;],\n        {[$style[&apos;aside-item_active&apos;]]:(i === index)}\n      ]&quot;\n</code></pre><h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>css-loader关于CSS modules的默认配置如下</p>\n<pre><code>{\n  modules: true,\n  importLoaders: 1,\n  localIdentName: &apos;[hash:base64]&apos;\n}\n</code></pre><p>可以使用vue-loader的cssModules选项为css-loader进行自定义的配置</p>\n<pre><code>module: {\n  rules: [\n    {\n      test: &apos;\\.vue$&apos;,\n      loader: &apos;vue-loader&apos;,\n      options: {\n        cssModules: {\n          localIdentName: &apos;[path][name]---[local]---[hash:base64:5]&apos;,\n          camelCase: true\n        }\n      }\n    }\n  ]\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h1 id=\"关于CSS-Module\"><a href=\"#关于CSS-Module\" class=\"headerlink\" title=\"关于CSS Module\"></a>关于CSS Module</h1><ul>\n<li>css modules是一种流行的模块化和组合CSS的系统。 vue-loader提供了与css modules的集成，作为scope CSS的替代方案。</li>\n</ul>","more":"<h2 id=\"vue引入scopet，有缺陷的样式私有化\"><a href=\"#vue引入scopet，有缺陷的样式私有化\" class=\"headerlink\" title=\"vue引入scopet，有缺陷的样式私有化\"></a>vue引入scopet，有缺陷的样式私有化</h2><p>最开始的时候，我们提倡并大量使用的是scoped这种技术<br>在vue组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style标签上添加scoped属性，以表示它的只属于当下的模块，这是一个非常好的举措。<br>    <style scoped><br>      @media (min-width: 250px) {<br>    .list-container:hover {<br>      background: orange;<br>    }<br>    }<br>    </style></p>\n<pre><code>&lt;!-- more --&gt;\n</code></pre><p>这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域<br>编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover</p>\n<ul>\n<li>但是，它并不能完全避免冲突</li>\n</ul>\n<p>如果用户在不同的父子级，定义了一个重复的类名，会影响到所有定义为errShow类名的组件的显示<br>并且它会造成一种后果，每个样式的权重加重了：<br>理论上我们要去修改这个样式，需要更高的权重去覆盖这个样式。<br>这是增加复杂度的其中一个维度。</p>\n<h3 id=\"CSS-modules则做的更好，它不是添加属性，而是直接改变类名\"><a href=\"#CSS-modules则做的更好，它不是添加属性，而是直接改变类名\" class=\"headerlink\" title=\"CSS modules则做的更好，它不是添加属性，而是直接改变类名\"></a>CSS modules则做的更好，它不是添加属性，而是直接改变类名</h3><p>SS Modules既不是官方标准，也不是浏览器的特性，而是在构建步骤中对CSS类名选择器限定作用域的一种方式（通过hash实现类似于命名空间的方法）。</p>\n<ul>\n<li>类名是动态生成的，唯一的，并准确对应到源文件中的各个类的样式。</li>\n</ul>\n<p>实际上，CSS Modules只是CSS模块化的一种方式。为什么我们需要CSS模块化呢？</p>\n<p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。于是，亟待解决的就是样式冲突（污染）的问题。一般地，为了解决冲突，会把class命名写长一点，降低冲突几率；加上父元素的选择器，来限制范围等……</p>\n<p>CSS模块化就是来解决这个问题的，一般地，分为三类</p>\n<p>　　1、命名约定类</p>\n<p>　　该类CSS模块化方案主要用来规范CSS命名，最常见的是BEM，当然还有OOCSS等，在构建工具出现之前，大多数都是在CSS命名上做文章</p>\n<p>　　2、CSS in JS</p>\n<p>　　彻底抛弃CSS，用javascript来写CSS规则，常见的有styled-components</p>\n<p>　　3、使用JS来管理样式</p>\n<p>　　使用JS编译原生的CSS文件，使其具备模块化的能力，最常见的就是CSS Modules</p>\n<p>　　随着构建工具的兴起，越来越多的人开始使用后两者方案，书写CSS时，不用再特意地关心样式冲突问题。只需要使用约定的格式编写代码即可</p>\n<h2 id=\"VUE的CSS-Module写法\"><a href=\"#VUE的CSS-Module写法\" class=\"headerlink\" title=\"VUE的CSS Module写法\"></a>VUE的CSS Module写法</h2><ul>\n<li>使用时需要进行添加<code>v-bind</code>，如样式绑定简写 <code>:class</code></li>\n</ul>\n<p>① 在style标签中添加module属性，表示打开CSS-loader的模块模式</p>\n<pre><code>&lt;style module&gt;\n.red {color: red;}\n&lt;/style&gt;\n</code></pre><p>② 在模板中使用动态类绑定 <code>:class</code> ，并在类名前面加上 <code>$style.</code></p>\n<pre><code>&lt;template&gt;\n  &lt;p :class=&quot;$style.red&quot;&gt;\n    This should be red\n  &lt;/p&gt;\n&lt;/template&gt;\n</code></pre><p>③ 如果类名包含中划线，则使用中括号语法</p>\n<pre><code>&lt;h4 :class=&quot;$style[&apos;header-tit&apos;]&quot;&gt;类别推荐&lt;/h4&gt;\n</code></pre><p>④ 也可以使用数组或对象语法</p>\n<pre><code>&lt;p :class=&quot;{ [$style.red]: isRed }&quot;&gt;\n      Am I red?\n&lt;/p&gt;\n&lt;p :class=&quot;[$style.red, $style.bold]&quot;&gt;\n      Red and bold\n&lt;/p&gt;\n</code></pre><p>⑤ 更复杂的对象语法</p>\n<pre><code>&lt;ul\n　　　 :class=&quot;{\n    [$style.panelBox]:true,\n    [$style.transitionByPanelBox]:needTransition\n  }&quot;\n</code></pre><p>⑥ 更复杂的数组语法</p>\n<pre><code>&lt;li\n      :class=&quot;[\n        $style[&apos;aside-item&apos;],\n        {[$style[&apos;aside-item_active&apos;]]:(i === index)}\n      ]&quot;\n</code></pre><h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>css-loader关于CSS modules的默认配置如下</p>\n<pre><code>{\n  modules: true,\n  importLoaders: 1,\n  localIdentName: &apos;[hash:base64]&apos;\n}\n</code></pre><p>可以使用vue-loader的cssModules选项为css-loader进行自定义的配置</p>\n<pre><code>module: {\n  rules: [\n    {\n      test: &apos;\\.vue$&apos;,\n      loader: &apos;vue-loader&apos;,\n      options: {\n        cssModules: {\n          localIdentName: &apos;[path][name]---[local]---[hash:base64:5]&apos;,\n          camelCase: true\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"title":"node+mongoodb学习","date":"2019-04-07T12:26:53.000Z","_content":"\n[toc]\n\n#### 说明\n此系列将在一周内更新完，不记细节，只记基础知识点\n\n#### 1.服务器启动\nExpress 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。\n\n使用 Express 可以快速地搭建一个完整功能的网站。\n\n<!-- more -->\n\nExpress 框架核心特性：\n\n- 可以设置中间件来响应 HTTP 请求。\n- 定义了路由表用于执行不同的 HTTP 请求动作。\n- 可以通过向模板传递参数来动态渲染 HTML 页面。\n\n启动文件：server.js\n```javascript\nconst express = require(\"express\");const express = require(\"express\");\nconst app = express(); // 实例化\nconst port = process.env.PORT || 5000; // 端口号\n\napp.get(\"/\", (req, res) => {\n    res.send(\"hello world!\") // 默认输出\n})\napp.listen(port, () => { // 监听\n    console.log(`Server running on port ${port}`);\n})\n```\n此时推荐安装插件nodemon，它默认会监听当前目录，重启Express\n\n#### 2.mongodb创建数据库\n数据库：config/keys.js\n```javascript\nmodule.exports = {\n    // 本地写法，无需登录\n    mongoURI: \"mongodb://localhost:27017/testData\"\n}\n\nmodule.exports = {\n    // 远程写法\n    mongoURI: \"mongodb://名称:密码@远程 数据库地址/testData\"\n}\n```\n\n回到启动文件：server.js\n```javascript\nconst mongoose = require(\"mongoose\") // 引入mongo\n\n// DB config\nconst db = require(\"./config/keys\").mongoURI; // 引入数据库地址\n\n// connect to mongodb 链接mongodb\nmongoose.connect(db, {useNewUrlParser: true})\n        .then(() => console.log(\"MongoDB Connected 666\")\n        .catch(err => console.log(err))\n```\n\n访问mongodb成功后，node命令行会输出MongoDB Connected 666\n\n#### 3.创建接口\n\n接口目录:router/api/user.js\n以下为最简单的router接口访问，只能输出消息。\n```javascript\n// login & register\nconst express = require(\"express\");\nconst router = express.Router();\n\n\n// $route   GET api/users/test\n// @desc    返回的请求的json数据\n// @access  public\nrouter.get(\"/test\", (req, res) => {\n    res.json({msg: \"login works\"})\n})\n```\n如果需要实现更多功能，则需要编写逻辑，甚至安装更多插件配合。\n例：\n```javascript\nconst bcrypt = require(\"bcrypt\"); // 加密\nconst gravatar = require('gravatar'); // 全球公共头像\nconst jwt = require(\"jsonwebtoken\"); // 生成token\n```\n\n#### 4.为什么接口要用到Schema\n在数据库中，schema（模式）是数据库的组织和结构。\n也就是数据结构。\n\n1.在创建接口后，根据字段需要，创建schema（模式）。\n\n2.该接口在前后端的字段传值，必须符合schema（模式）的定义。\n\n例：\n```javascript\nconst mongoose = require(\"mongoose\")\nconst Schema = mongoose.Schema;\n\n// Create Schema 模型\nconst UserSchema = new Schema({\n    name: {\n        type: String,\n        required: true\n    },\n    email: {\n        type: String,\n        required: true\n    },\n    password: {\n        type: String,\n        required: true\n    },\n    avatar: {\n        type: String\n    },\n    date: {\n        type: Date,\n        default: Date.now\n    }\n})\n\nmodule.exports = User = mongoose.model(\"users\", UserSchema);\n```\n#### 5.接口调试工具：postman\n1.谷歌应用商店搜索postman，安装使用\n\n2.直接百度搜索，下载安装软件\n\n#### 5.1.Express中间件body-parser\n当express使用get以外的请求时，需要安装中间件body-parser处理不同类型的请求\n\nbody-parser实现的·要点如下：\n\n- 处理不同类型的请求体：`比如text、json、urlencoded等，对应的报文主体的格式不同`。\n- 处理不同的编码：`比如utf8、gbk等`。\n- 处理不同的压缩类型：`比如gzip、deflare等`。\n- 其他边界、异常的处理。\n","source":"_posts/node+mongoodb学习(一).md","raw":"---\ntitle: node+mongoodb学习\ndate: 2019-04-07 20:26:53\ncategories: 前端\ntags:\n  - node\n  - mongoodb\n  - 实战笔记\n---\n\n[toc]\n\n#### 说明\n此系列将在一周内更新完，不记细节，只记基础知识点\n\n#### 1.服务器启动\nExpress 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。\n\n使用 Express 可以快速地搭建一个完整功能的网站。\n\n<!-- more -->\n\nExpress 框架核心特性：\n\n- 可以设置中间件来响应 HTTP 请求。\n- 定义了路由表用于执行不同的 HTTP 请求动作。\n- 可以通过向模板传递参数来动态渲染 HTML 页面。\n\n启动文件：server.js\n```javascript\nconst express = require(\"express\");const express = require(\"express\");\nconst app = express(); // 实例化\nconst port = process.env.PORT || 5000; // 端口号\n\napp.get(\"/\", (req, res) => {\n    res.send(\"hello world!\") // 默认输出\n})\napp.listen(port, () => { // 监听\n    console.log(`Server running on port ${port}`);\n})\n```\n此时推荐安装插件nodemon，它默认会监听当前目录，重启Express\n\n#### 2.mongodb创建数据库\n数据库：config/keys.js\n```javascript\nmodule.exports = {\n    // 本地写法，无需登录\n    mongoURI: \"mongodb://localhost:27017/testData\"\n}\n\nmodule.exports = {\n    // 远程写法\n    mongoURI: \"mongodb://名称:密码@远程 数据库地址/testData\"\n}\n```\n\n回到启动文件：server.js\n```javascript\nconst mongoose = require(\"mongoose\") // 引入mongo\n\n// DB config\nconst db = require(\"./config/keys\").mongoURI; // 引入数据库地址\n\n// connect to mongodb 链接mongodb\nmongoose.connect(db, {useNewUrlParser: true})\n        .then(() => console.log(\"MongoDB Connected 666\")\n        .catch(err => console.log(err))\n```\n\n访问mongodb成功后，node命令行会输出MongoDB Connected 666\n\n#### 3.创建接口\n\n接口目录:router/api/user.js\n以下为最简单的router接口访问，只能输出消息。\n```javascript\n// login & register\nconst express = require(\"express\");\nconst router = express.Router();\n\n\n// $route   GET api/users/test\n// @desc    返回的请求的json数据\n// @access  public\nrouter.get(\"/test\", (req, res) => {\n    res.json({msg: \"login works\"})\n})\n```\n如果需要实现更多功能，则需要编写逻辑，甚至安装更多插件配合。\n例：\n```javascript\nconst bcrypt = require(\"bcrypt\"); // 加密\nconst gravatar = require('gravatar'); // 全球公共头像\nconst jwt = require(\"jsonwebtoken\"); // 生成token\n```\n\n#### 4.为什么接口要用到Schema\n在数据库中，schema（模式）是数据库的组织和结构。\n也就是数据结构。\n\n1.在创建接口后，根据字段需要，创建schema（模式）。\n\n2.该接口在前后端的字段传值，必须符合schema（模式）的定义。\n\n例：\n```javascript\nconst mongoose = require(\"mongoose\")\nconst Schema = mongoose.Schema;\n\n// Create Schema 模型\nconst UserSchema = new Schema({\n    name: {\n        type: String,\n        required: true\n    },\n    email: {\n        type: String,\n        required: true\n    },\n    password: {\n        type: String,\n        required: true\n    },\n    avatar: {\n        type: String\n    },\n    date: {\n        type: Date,\n        default: Date.now\n    }\n})\n\nmodule.exports = User = mongoose.model(\"users\", UserSchema);\n```\n#### 5.接口调试工具：postman\n1.谷歌应用商店搜索postman，安装使用\n\n2.直接百度搜索，下载安装软件\n\n#### 5.1.Express中间件body-parser\n当express使用get以外的请求时，需要安装中间件body-parser处理不同类型的请求\n\nbody-parser实现的·要点如下：\n\n- 处理不同类型的请求体：`比如text、json、urlencoded等，对应的报文主体的格式不同`。\n- 处理不同的编码：`比如utf8、gbk等`。\n- 处理不同的压缩类型：`比如gzip、deflare等`。\n- 其他边界、异常的处理。\n","slug":"node+mongoodb学习(一)","published":1,"updated":"2019-06-16T08:32:20.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhfb000q9kudrckl8gvt","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>此系列将在一周内更新完，不记细节，只记基础知识点</p>\n<h4 id=\"1-服务器启动\"><a href=\"#1-服务器启动\" class=\"headerlink\" title=\"1.服务器启动\"></a>1.服务器启动</h4><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p>\n<p>使用 Express 可以快速地搭建一个完整功能的网站。</p>\n<a id=\"more\"></a>\n<p>Express 框架核心特性：</p>\n<ul>\n<li>可以设置中间件来响应 HTTP 请求。</li>\n<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>\n<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>\n</ul>\n<p>启动文件：server.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);<span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express(); <span class=\"comment\">// 实例化</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> port = process.env.PORT || <span class=\"number\">5000</span>; <span class=\"comment\">// 端口号</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">\"/\"</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">\"hello world!\"</span>) <span class=\"comment\">// 默认输出</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.listen(port, () =&gt; &#123; <span class=\"comment\">// 监听</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Server running on port <span class=\"subst\">$&#123;port&#125;</span>`</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>此时推荐安装插件nodemon，它默认会监听当前目录，重启Express</p>\n<h4 id=\"2-mongodb创建数据库\"><a href=\"#2-mongodb创建数据库\" class=\"headerlink\" title=\"2.mongodb创建数据库\"></a>2.mongodb创建数据库</h4><p>数据库：config/keys.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 本地写法，无需登录</span></span><br><span class=\"line\">    mongoURI: <span class=\"string\">\"mongodb://localhost:27017/testData\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 远程写法</span></span><br><span class=\"line\">    mongoURI: <span class=\"string\">\"mongodb://名称:密码@远程 数据库地址/testData\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>回到启动文件：server.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">\"mongoose\"</span>) <span class=\"comment\">// 引入mongo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DB config</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"built_in\">require</span>(<span class=\"string\">\"./config/keys\"</span>).mongoURI; <span class=\"comment\">// 引入数据库地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// connect to mongodb 链接mongodb</span></span><br><span class=\"line\">mongoose.connect(db, &#123;<span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"MongoDB Connected 666\"</span>)</span><br><span class=\"line\">        .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(err))</span><br></pre></td></tr></table></figure></p>\n<p>访问mongodb成功后，node命令行会输出MongoDB Connected 666</p>\n<h4 id=\"3-创建接口\"><a href=\"#3-创建接口\" class=\"headerlink\" title=\"3.创建接口\"></a>3.创建接口</h4><p>接口目录:router/api/user.js<br>以下为最简单的router接口访问，只能输出消息。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// login &amp; register</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $route   GET api/users/test</span></span><br><span class=\"line\"><span class=\"comment\">// @desc    返回的请求的json数据</span></span><br><span class=\"line\"><span class=\"comment\">// @access  public</span></span><br><span class=\"line\">router.get(<span class=\"string\">\"/test\"</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">    res.json(&#123;<span class=\"attr\">msg</span>: <span class=\"string\">\"login works\"</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如果需要实现更多功能，则需要编写逻辑，甚至安装更多插件配合。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bcrypt = <span class=\"built_in\">require</span>(<span class=\"string\">\"bcrypt\"</span>); <span class=\"comment\">// 加密</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gravatar = <span class=\"built_in\">require</span>(<span class=\"string\">'gravatar'</span>); <span class=\"comment\">// 全球公共头像</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> jwt = <span class=\"built_in\">require</span>(<span class=\"string\">\"jsonwebtoken\"</span>); <span class=\"comment\">// 生成token</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-为什么接口要用到Schema\"><a href=\"#4-为什么接口要用到Schema\" class=\"headerlink\" title=\"4.为什么接口要用到Schema\"></a>4.为什么接口要用到Schema</h4><p>在数据库中，schema（模式）是数据库的组织和结构。<br>也就是数据结构。</p>\n<p>1.在创建接口后，根据字段需要，创建schema（模式）。</p>\n<p>2.该接口在前后端的字段传值，必须符合schema（模式）的定义。</p>\n<p>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">\"mongoose\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Schema = mongoose.Schema;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create Schema 模型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> UserSchema = <span class=\"keyword\">new</span> Schema(&#123;</span><br><span class=\"line\">    name: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">        required: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    email: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">        required: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    password: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">        required: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    avatar: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">String</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    date: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">Date</span>,</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"built_in\">Date</span>.now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = User = mongoose.model(<span class=\"string\">\"users\"</span>, UserSchema);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-接口调试工具：postman\"><a href=\"#5-接口调试工具：postman\" class=\"headerlink\" title=\"5.接口调试工具：postman\"></a>5.接口调试工具：postman</h4><p>1.谷歌应用商店搜索postman，安装使用</p>\n<p>2.直接百度搜索，下载安装软件</p>\n<h4 id=\"5-1-Express中间件body-parser\"><a href=\"#5-1-Express中间件body-parser\" class=\"headerlink\" title=\"5.1.Express中间件body-parser\"></a>5.1.Express中间件body-parser</h4><p>当express使用get以外的请求时，需要安装中间件body-parser处理不同类型的请求</p>\n<p>body-parser实现的·要点如下：</p>\n<ul>\n<li>处理不同类型的请求体：<code>比如text、json、urlencoded等，对应的报文主体的格式不同</code>。</li>\n<li>处理不同的编码：<code>比如utf8、gbk等</code>。</li>\n<li>处理不同的压缩类型：<code>比如gzip、deflare等</code>。</li>\n<li>其他边界、异常的处理。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>此系列将在一周内更新完，不记细节，只记基础知识点</p>\n<h4 id=\"1-服务器启动\"><a href=\"#1-服务器启动\" class=\"headerlink\" title=\"1.服务器启动\"></a>1.服务器启动</h4><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p>\n<p>使用 Express 可以快速地搭建一个完整功能的网站。</p>","more":"<p>Express 框架核心特性：</p>\n<ul>\n<li>可以设置中间件来响应 HTTP 请求。</li>\n<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>\n<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>\n</ul>\n<p>启动文件：server.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);<span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express(); <span class=\"comment\">// 实例化</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> port = process.env.PORT || <span class=\"number\">5000</span>; <span class=\"comment\">// 端口号</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">\"/\"</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">    res.send(<span class=\"string\">\"hello world!\"</span>) <span class=\"comment\">// 默认输出</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.listen(port, () =&gt; &#123; <span class=\"comment\">// 监听</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Server running on port <span class=\"subst\">$&#123;port&#125;</span>`</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>此时推荐安装插件nodemon，它默认会监听当前目录，重启Express</p>\n<h4 id=\"2-mongodb创建数据库\"><a href=\"#2-mongodb创建数据库\" class=\"headerlink\" title=\"2.mongodb创建数据库\"></a>2.mongodb创建数据库</h4><p>数据库：config/keys.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 本地写法，无需登录</span></span><br><span class=\"line\">    mongoURI: <span class=\"string\">\"mongodb://localhost:27017/testData\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 远程写法</span></span><br><span class=\"line\">    mongoURI: <span class=\"string\">\"mongodb://名称:密码@远程 数据库地址/testData\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>回到启动文件：server.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">\"mongoose\"</span>) <span class=\"comment\">// 引入mongo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DB config</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"built_in\">require</span>(<span class=\"string\">\"./config/keys\"</span>).mongoURI; <span class=\"comment\">// 引入数据库地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// connect to mongodb 链接mongodb</span></span><br><span class=\"line\">mongoose.connect(db, &#123;<span class=\"attr\">useNewUrlParser</span>: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"MongoDB Connected 666\"</span>)</span><br><span class=\"line\">        .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(err))</span><br></pre></td></tr></table></figure></p>\n<p>访问mongodb成功后，node命令行会输出MongoDB Connected 666</p>\n<h4 id=\"3-创建接口\"><a href=\"#3-创建接口\" class=\"headerlink\" title=\"3.创建接口\"></a>3.创建接口</h4><p>接口目录:router/api/user.js<br>以下为最简单的router接口访问，只能输出消息。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// login &amp; register</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">\"express\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $route   GET api/users/test</span></span><br><span class=\"line\"><span class=\"comment\">// @desc    返回的请求的json数据</span></span><br><span class=\"line\"><span class=\"comment\">// @access  public</span></span><br><span class=\"line\">router.get(<span class=\"string\">\"/test\"</span>, (req, res) =&gt; &#123;</span><br><span class=\"line\">    res.json(&#123;<span class=\"attr\">msg</span>: <span class=\"string\">\"login works\"</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如果需要实现更多功能，则需要编写逻辑，甚至安装更多插件配合。<br>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bcrypt = <span class=\"built_in\">require</span>(<span class=\"string\">\"bcrypt\"</span>); <span class=\"comment\">// 加密</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gravatar = <span class=\"built_in\">require</span>(<span class=\"string\">'gravatar'</span>); <span class=\"comment\">// 全球公共头像</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> jwt = <span class=\"built_in\">require</span>(<span class=\"string\">\"jsonwebtoken\"</span>); <span class=\"comment\">// 生成token</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-为什么接口要用到Schema\"><a href=\"#4-为什么接口要用到Schema\" class=\"headerlink\" title=\"4.为什么接口要用到Schema\"></a>4.为什么接口要用到Schema</h4><p>在数据库中，schema（模式）是数据库的组织和结构。<br>也就是数据结构。</p>\n<p>1.在创建接口后，根据字段需要，创建schema（模式）。</p>\n<p>2.该接口在前后端的字段传值，必须符合schema（模式）的定义。</p>\n<p>例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">\"mongoose\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Schema = mongoose.Schema;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create Schema 模型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> UserSchema = <span class=\"keyword\">new</span> Schema(&#123;</span><br><span class=\"line\">    name: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">        required: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    email: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">        required: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    password: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">        required: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    avatar: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">String</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    date: &#123;</span><br><span class=\"line\">        type: <span class=\"built_in\">Date</span>,</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"built_in\">Date</span>.now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = User = mongoose.model(<span class=\"string\">\"users\"</span>, UserSchema);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-接口调试工具：postman\"><a href=\"#5-接口调试工具：postman\" class=\"headerlink\" title=\"5.接口调试工具：postman\"></a>5.接口调试工具：postman</h4><p>1.谷歌应用商店搜索postman，安装使用</p>\n<p>2.直接百度搜索，下载安装软件</p>\n<h4 id=\"5-1-Express中间件body-parser\"><a href=\"#5-1-Express中间件body-parser\" class=\"headerlink\" title=\"5.1.Express中间件body-parser\"></a>5.1.Express中间件body-parser</h4><p>当express使用get以外的请求时，需要安装中间件body-parser处理不同类型的请求</p>\n<p>body-parser实现的·要点如下：</p>\n<ul>\n<li>处理不同类型的请求体：<code>比如text、json、urlencoded等，对应的报文主体的格式不同</code>。</li>\n<li>处理不同的编码：<code>比如utf8、gbk等</code>。</li>\n<li>处理不同的压缩类型：<code>比如gzip、deflare等</code>。</li>\n<li>其他边界、异常的处理。</li>\n</ul>"},{"title":"sass使用之mixin","date":"2018-04-08T12:21:14.000Z","_content":"目前仅用于最简单的实战，没有深入学习，以下介绍SASS常用方法\n\n## 定义mixin\n\n通过 `@mixin  名称` 的方式可以定义一个Mixins模块：在模块内你可以添加任何你想重复使用的样式。\n\n<!-- more -->\n\n示例（以下全文使用一个例子）：\n\n\t@mixin flex($direction:column,$inline:block) {\n\t    display: if($inline==block,flex,inline-flex);\n\t    flex-direction: $direction;\n\t    flex-wrap: wrap;\n\t}\n\n由于历史原因，连字符和下划线被认为是相同的，也就是说 @mixin button-large { } 和 @mixin button_large { } 是一样的。\n\nMixins能够包含任何在 CSS 和 Sass 中有效的内容。\n\n<!-- more -->\n\n## 调用Mixin\n\n你可以通过 `@include` 来调用具有相同名称的mixin模块。\n\n\t@mixin btn {\n\t\tdisplay:inline-block;\n\t}\n\t.btn {\n\t    @include btn;\n\t    //等于display:inline-block;\n\t}\n\n-  `@include` 也可以在mixin模块的定义中使用\n\n## 参数的使用\n\n使用`$`，Mixins可以接收和使用参数，这有点像less，但作用域不同\n\n\t@mixin btn($size:14px,$color:#fff,$bgcolor:#f04752,$padding:5px,$radius:5px) {\n\t    padding: $padding;\n\t    background-color: $bgcolor;\n\t    border-radius: $radius;\n\t    border: 1px solid $bgcolor;\n\t    font-size: $size;\n\t    color: $color;\n\t    text-align: center;\n\t    line-height: 1;\n\t    display: inline-block;\n\t}\n\n## 关键字参数\n\n为了帮助你的代码更加容易理解，你可以在传递值给mixin时将参数名称和参数值一并传递过去。\n\n\tbutton-green { @include button($background: green, $color: #fff); }\n\n关键字参数会额外增加一些代码，但是这会使得你的@include更加容易理解。\n上面的代码明确指出了green和#fff分别是什么。\n\n## 数量可变的参数\n\nMixins可以接收未知数量的参数。\n通过在变量名后增加三个点（...）来使mixin模块接收数量可变的参数。\n当你使用@include传递参数的时候，使用逗号将参数分开。\n\n\t@mixin box-shadows($shadow...) {\n\t          box-shadow: $shadow;\n\t}\n\n\t .container {\n\t         @include box-shadows(0px 1px 2px #333, 2px 3px 4px #ccc);  \n\t }\n\n编译为\n\n\t.container {\n\t         box-shadow: 0px 1px 2px #333,\n\t                     2px 3px 4px #ccc;\n\t         }\n","source":"_posts/sass使用之mixin.md","raw":"---\ntitle: sass使用之mixin\ndate: 2018-04-08 20:21:14\ncategories: 前端\ntags:\n  - CSS\n  - SASS\n---\n目前仅用于最简单的实战，没有深入学习，以下介绍SASS常用方法\n\n## 定义mixin\n\n通过 `@mixin  名称` 的方式可以定义一个Mixins模块：在模块内你可以添加任何你想重复使用的样式。\n\n<!-- more -->\n\n示例（以下全文使用一个例子）：\n\n\t@mixin flex($direction:column,$inline:block) {\n\t    display: if($inline==block,flex,inline-flex);\n\t    flex-direction: $direction;\n\t    flex-wrap: wrap;\n\t}\n\n由于历史原因，连字符和下划线被认为是相同的，也就是说 @mixin button-large { } 和 @mixin button_large { } 是一样的。\n\nMixins能够包含任何在 CSS 和 Sass 中有效的内容。\n\n<!-- more -->\n\n## 调用Mixin\n\n你可以通过 `@include` 来调用具有相同名称的mixin模块。\n\n\t@mixin btn {\n\t\tdisplay:inline-block;\n\t}\n\t.btn {\n\t    @include btn;\n\t    //等于display:inline-block;\n\t}\n\n-  `@include` 也可以在mixin模块的定义中使用\n\n## 参数的使用\n\n使用`$`，Mixins可以接收和使用参数，这有点像less，但作用域不同\n\n\t@mixin btn($size:14px,$color:#fff,$bgcolor:#f04752,$padding:5px,$radius:5px) {\n\t    padding: $padding;\n\t    background-color: $bgcolor;\n\t    border-radius: $radius;\n\t    border: 1px solid $bgcolor;\n\t    font-size: $size;\n\t    color: $color;\n\t    text-align: center;\n\t    line-height: 1;\n\t    display: inline-block;\n\t}\n\n## 关键字参数\n\n为了帮助你的代码更加容易理解，你可以在传递值给mixin时将参数名称和参数值一并传递过去。\n\n\tbutton-green { @include button($background: green, $color: #fff); }\n\n关键字参数会额外增加一些代码，但是这会使得你的@include更加容易理解。\n上面的代码明确指出了green和#fff分别是什么。\n\n## 数量可变的参数\n\nMixins可以接收未知数量的参数。\n通过在变量名后增加三个点（...）来使mixin模块接收数量可变的参数。\n当你使用@include传递参数的时候，使用逗号将参数分开。\n\n\t@mixin box-shadows($shadow...) {\n\t          box-shadow: $shadow;\n\t}\n\n\t .container {\n\t         @include box-shadows(0px 1px 2px #333, 2px 3px 4px #ccc);  \n\t }\n\n编译为\n\n\t.container {\n\t         box-shadow: 0px 1px 2px #333,\n\t                     2px 3px 4px #ccc;\n\t         }\n","slug":"sass使用之mixin","published":1,"updated":"2019-06-16T08:32:26.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhff000v9kudst6c80ls","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>目前仅用于最简单的实战，没有深入学习，以下介绍SASS常用方法</p>\n<h2 id=\"定义mixin\"><a href=\"#定义mixin\" class=\"headerlink\" title=\"定义mixin\"></a>定义mixin</h2><p>通过 <code>@mixin  名称</code> 的方式可以定义一个Mixins模块：在模块内你可以添加任何你想重复使用的样式。</p>\n<a id=\"more\"></a>\n<p>示例（以下全文使用一个例子）：</p>\n<pre><code>@mixin flex($direction:column,$inline:block) {\n    display: if($inline==block,flex,inline-flex);\n    flex-direction: $direction;\n    flex-wrap: wrap;\n}\n</code></pre><p>由于历史原因，连字符和下划线被认为是相同的，也就是说 @mixin button-large { } 和 @mixin button_large { } 是一样的。</p>\n<p>Mixins能够包含任何在 CSS 和 Sass 中有效的内容。</p>\n<!-- more -->\n<h2 id=\"调用Mixin\"><a href=\"#调用Mixin\" class=\"headerlink\" title=\"调用Mixin\"></a>调用Mixin</h2><p>你可以通过 <code>@include</code> 来调用具有相同名称的mixin模块。</p>\n<pre><code>@mixin btn {\n    display:inline-block;\n}\n.btn {\n    @include btn;\n    //等于display:inline-block;\n}\n</code></pre><ul>\n<li><code>@include</code> 也可以在mixin模块的定义中使用</li>\n</ul>\n<h2 id=\"参数的使用\"><a href=\"#参数的使用\" class=\"headerlink\" title=\"参数的使用\"></a>参数的使用</h2><p>使用<code>$</code>，Mixins可以接收和使用参数，这有点像less，但作用域不同</p>\n<pre><code>@mixin btn($size:14px,$color:#fff,$bgcolor:#f04752,$padding:5px,$radius:5px) {\n    padding: $padding;\n    background-color: $bgcolor;\n    border-radius: $radius;\n    border: 1px solid $bgcolor;\n    font-size: $size;\n    color: $color;\n    text-align: center;\n    line-height: 1;\n    display: inline-block;\n}\n</code></pre><h2 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h2><p>为了帮助你的代码更加容易理解，你可以在传递值给mixin时将参数名称和参数值一并传递过去。</p>\n<pre><code>button-green { @include button($background: green, $color: #fff); }\n</code></pre><p>关键字参数会额外增加一些代码，但是这会使得你的@include更加容易理解。<br>上面的代码明确指出了green和#fff分别是什么。</p>\n<h2 id=\"数量可变的参数\"><a href=\"#数量可变的参数\" class=\"headerlink\" title=\"数量可变的参数\"></a>数量可变的参数</h2><p>Mixins可以接收未知数量的参数。<br>通过在变量名后增加三个点（…）来使mixin模块接收数量可变的参数。<br>当你使用@include传递参数的时候，使用逗号将参数分开。</p>\n<pre><code>@mixin box-shadows($shadow...) {\n          box-shadow: $shadow;\n}\n\n .container {\n         @include box-shadows(0px 1px 2px #333, 2px 3px 4px #ccc);  \n }\n</code></pre><p>编译为</p>\n<pre><code>.container {\n         box-shadow: 0px 1px 2px #333,\n                     2px 3px 4px #ccc;\n         }\n</code></pre>","site":{"data":{}},"excerpt":"<p>目前仅用于最简单的实战，没有深入学习，以下介绍SASS常用方法</p>\n<h2 id=\"定义mixin\"><a href=\"#定义mixin\" class=\"headerlink\" title=\"定义mixin\"></a>定义mixin</h2><p>通过 <code>@mixin  名称</code> 的方式可以定义一个Mixins模块：在模块内你可以添加任何你想重复使用的样式。</p>","more":"<p>示例（以下全文使用一个例子）：</p>\n<pre><code>@mixin flex($direction:column,$inline:block) {\n    display: if($inline==block,flex,inline-flex);\n    flex-direction: $direction;\n    flex-wrap: wrap;\n}\n</code></pre><p>由于历史原因，连字符和下划线被认为是相同的，也就是说 @mixin button-large { } 和 @mixin button_large { } 是一样的。</p>\n<p>Mixins能够包含任何在 CSS 和 Sass 中有效的内容。</p>\n<!-- more -->\n<h2 id=\"调用Mixin\"><a href=\"#调用Mixin\" class=\"headerlink\" title=\"调用Mixin\"></a>调用Mixin</h2><p>你可以通过 <code>@include</code> 来调用具有相同名称的mixin模块。</p>\n<pre><code>@mixin btn {\n    display:inline-block;\n}\n.btn {\n    @include btn;\n    //等于display:inline-block;\n}\n</code></pre><ul>\n<li><code>@include</code> 也可以在mixin模块的定义中使用</li>\n</ul>\n<h2 id=\"参数的使用\"><a href=\"#参数的使用\" class=\"headerlink\" title=\"参数的使用\"></a>参数的使用</h2><p>使用<code>$</code>，Mixins可以接收和使用参数，这有点像less，但作用域不同</p>\n<pre><code>@mixin btn($size:14px,$color:#fff,$bgcolor:#f04752,$padding:5px,$radius:5px) {\n    padding: $padding;\n    background-color: $bgcolor;\n    border-radius: $radius;\n    border: 1px solid $bgcolor;\n    font-size: $size;\n    color: $color;\n    text-align: center;\n    line-height: 1;\n    display: inline-block;\n}\n</code></pre><h2 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h2><p>为了帮助你的代码更加容易理解，你可以在传递值给mixin时将参数名称和参数值一并传递过去。</p>\n<pre><code>button-green { @include button($background: green, $color: #fff); }\n</code></pre><p>关键字参数会额外增加一些代码，但是这会使得你的@include更加容易理解。<br>上面的代码明确指出了green和#fff分别是什么。</p>\n<h2 id=\"数量可变的参数\"><a href=\"#数量可变的参数\" class=\"headerlink\" title=\"数量可变的参数\"></a>数量可变的参数</h2><p>Mixins可以接收未知数量的参数。<br>通过在变量名后增加三个点（…）来使mixin模块接收数量可变的参数。<br>当你使用@include传递参数的时候，使用逗号将参数分开。</p>\n<pre><code>@mixin box-shadows($shadow...) {\n          box-shadow: $shadow;\n}\n\n .container {\n         @include box-shadows(0px 1px 2px #333, 2px 3px 4px #ccc);  \n }\n</code></pre><p>编译为</p>\n<pre><code>.container {\n         box-shadow: 0px 1px 2px #333,\n                     2px 3px 4px #ccc;\n         }\n</code></pre>"},{"title":"test","date":"2020-04-14T18:40:01.195Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: test\ncategories: test\ntags:\n---\n","slug":"test","published":1,"updated":"2020-04-14T18:40:17.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhfj000y9kudv64tzfrl","content":"<script src=\"/assets/js/APlayer.min.js\"> </script>","site":{"data":{}},"excerpt":"","more":""},{"title":"vue动画","date":"2018-05-01T14:32:07.000Z","_content":"\n## 单元素/组件的过渡\n\nVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡\n- 条件渲染 (使用 v-if)\n- 条件展示 (使用 v-show)\n- 动态组件\n- 组件根节点\n\nvue的动画也是使用css3实现的。\n只是写法有些不一样，我们需要将代码嵌套在<transition>中\n\n<!--more-->\n\n## 过渡的类名\n\n而与css动画最大的区别，我们需要使用vue自带的模板语法\n通过Vue自带的类名，我们可以定义css动画的触发时机\n\n在进入/离开的过渡中，会有 6 个 class 切换。\n\n- v-enter：定义进入过渡的开始状态。\n  - 在元素被插入之前生效，在元素被插入之后的下一帧移除。\n\n- v-enter-active：定义进入过渡生效时的状态。\n  - 在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n\n- v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。\n  - 在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。\n\n- v-leave: 定义离开过渡的开始状态。\n  - 在离开过渡被触发时立刻生效，下一帧被移除。\n\n- v-leave-active：定义离开过渡生效时的状态。\n  - 在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n\n- v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。\n  - 在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。\n\n```\n\n.fade-enter-active,.fade-leave-active{\n\t\t\ttransition:all 3s ease;\n\t\t}\n\t\t.fade-enter-active{\n\t\t\topacity:1;// 动画开始状态\n\t\t\twidth:300px;\n\t\t\theight:300px;\n\t\t}\n\t\t.fade-leave-active{\n\t\t\topacity:0;\n\t\t\twidth:50px;\n\t\t\theight:50px;\n\t\t}\n\t\t/* .fade-enter需要放在.fade-enter-active的后面 */\n\t\t.fade-enter{\n\t\t\topacity:0; /*初始状态（css重叠样式表，属性覆盖，必须放后面）*/\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t}\n```\n\n## javaScript 钩子\n\n可以在属性中声明 JavaScript 钩子\n\n```\n<transition name=\"fade\" \n\t\t\t@before-enter=\"beforeEnter\"// 动画进入之前\n\t\t\t@enter=\"enter\"// 动画进入\n\t\t\t@after-enter=\"afterEnter\"// 动画进入之后\n\n\t\t\t@before-leave=\"beforeLeave\"// 动画即将离开之前\n\t\t\t@leave=\"leave\"// 动画离开\n\t\t\t@after-leave=\"afterLeave\"// 动画离开之后\n\t\t>\n\t\t\t<p v-show=\"flag\">网博</p>\n\t\t</transition>\n```\n\n钩子函数的触发时机\n```\nmethods:{\n\t\t\t\tbeforeEnter(el){\n\t\t\t\t\t// alert('动画进入之前');\n\t\t\t\t},\n\t\t\t\tenter(){\n\t\t\t\t\t// alert('动画进入');\n\t\t\t\t},\n\t\t\t\tafterEnter(el){\n\t\t\t\t\t// alert('动画进入之后');\n\t\t\t\t\tel.style.background='blue';\n\t\t\t\t},\n\n\t\t\t\tbeforeLeave(){\n\t\t\t\t\t// alert('动画即将之前');\n\t\t\t\t},\n\t\t\t\tleave(){\n\t\t\t\t\t// alert('动画离开');\n\t\t\t\t},\n\t\t\t\tafterLeave(el){\n\t\t\t\t\t// alert('动画离开之后');\n\t\t\t\t\tel.style.background='red';\n\t\t\t\t}\n\t\t\t}\n```\n\n这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。\n\n>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。\n>否则，它们会被同步调用，过渡会立即完成。\n\n>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=\"false\"，Vue 会跳过 CSS 的检测。\n>这也可以避免过渡过程中 CSS 的影响。\n\n# 在vue中使用animations.css动画库\n\n只需要引入animations.css，然后写法如下，在标签中直接定义开始动画和离开动画即可\n\n```\n<transition enter-active-class=\"animated fadeInLeft\" leave-active-class=\"animated fadeOutRight\">\n\t\t\t<p v-show=\"flag\">网博</p>\n\t\t</transition>\n```\n\n## 多元素动画\n\n对于原生标签可以使用 v-if/v-else 。\n\n当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。\n即使在技术上没有必要，给在 `<transition>` 组件中的多个元素设置 key 也是一个更好的实践。\n```\n<transition enter-active-class=\"animated bounceInLeft\" leave-active-class=\"animated bounceOutRight\">\n\t\t\t<p v-show=\"flag\" :key=\"1\">itany</p>\n\t\t\t<p v-show=\"flag\" :key=\"2\">网博</p>\n</transition>\n```\n\n我们也可以通过给同一个元素的 key 特性设置不同的状态\n来代替 v-if 和 v-else\n\n```\n<transition>\n  <button v-bind:key=\"isEditing\">\n    {{ isEditing ? 'Save' : 'Edit' }}\n  </button>\n</transition>\n```\n\n或者使用多个if\n\n## 列表过渡\n\n同时渲染整个列表`<transition-group>`\n\n- 不同于 <transition>，它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。\n- 内部元素 总是需要 提供唯一的 key 属性值\n\n```\n<div id=\"itany\">\n\t\t<input type=\"text\" v-model=\"name\">\n\t\t\n\t\t<transition-group enter-active-class=\"animated bounceInLeft\" leave-active-class=\"animated bounceOutRight\">\n\t\t\t<p v-for=\"(v,k) in arr2\" :key=\"k\" v-show=\"flag\">\n\t\t\t\t{{v}}\n\t\t\t</p>\n\t\t</transition-group>\n\t</div>\n\n\t<script>\n\t\tvar vm=new Vue({\n\t\t\tel:'#itany',\n\t\t\tdata:{\n\t\t\t\tflag:true,\n\t\t\t\tarr:['tom','jack','mike','alice','alex','mark'],\n\t\t\t\tname:''\n\t\t\t},\n\t\t\tcomputed:{\n\t\t\t\tarr2:function(){\n\t\t\t\t\tvar temp=[];\n\t\t\t\t\tthis.arr.forEach(val => {\n\t\t\t\t\t\t// Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。\n\t\t\t\t\t\tif(val.includes(this.name)){ // 判断是否存在传入字符，存在则push元素\n\t\t\t\t\t\t\ttemp.push(val);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn temp;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t</script>\n```\n\n检测元素数组元素是否存在：\nArray.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。","source":"_posts/vue动画与animations动画库.md","raw":"---\ntitle: vue动画\ndate: 2018-05-01 22:32:07\ncategories:\n  - vue\ntags:\n  - vue\n---\n\n## 单元素/组件的过渡\n\nVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡\n- 条件渲染 (使用 v-if)\n- 条件展示 (使用 v-show)\n- 动态组件\n- 组件根节点\n\nvue的动画也是使用css3实现的。\n只是写法有些不一样，我们需要将代码嵌套在<transition>中\n\n<!--more-->\n\n## 过渡的类名\n\n而与css动画最大的区别，我们需要使用vue自带的模板语法\n通过Vue自带的类名，我们可以定义css动画的触发时机\n\n在进入/离开的过渡中，会有 6 个 class 切换。\n\n- v-enter：定义进入过渡的开始状态。\n  - 在元素被插入之前生效，在元素被插入之后的下一帧移除。\n\n- v-enter-active：定义进入过渡生效时的状态。\n  - 在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n\n- v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。\n  - 在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。\n\n- v-leave: 定义离开过渡的开始状态。\n  - 在离开过渡被触发时立刻生效，下一帧被移除。\n\n- v-leave-active：定义离开过渡生效时的状态。\n  - 在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n\n- v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。\n  - 在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。\n\n```\n\n.fade-enter-active,.fade-leave-active{\n\t\t\ttransition:all 3s ease;\n\t\t}\n\t\t.fade-enter-active{\n\t\t\topacity:1;// 动画开始状态\n\t\t\twidth:300px;\n\t\t\theight:300px;\n\t\t}\n\t\t.fade-leave-active{\n\t\t\topacity:0;\n\t\t\twidth:50px;\n\t\t\theight:50px;\n\t\t}\n\t\t/* .fade-enter需要放在.fade-enter-active的后面 */\n\t\t.fade-enter{\n\t\t\topacity:0; /*初始状态（css重叠样式表，属性覆盖，必须放后面）*/\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t}\n```\n\n## javaScript 钩子\n\n可以在属性中声明 JavaScript 钩子\n\n```\n<transition name=\"fade\" \n\t\t\t@before-enter=\"beforeEnter\"// 动画进入之前\n\t\t\t@enter=\"enter\"// 动画进入\n\t\t\t@after-enter=\"afterEnter\"// 动画进入之后\n\n\t\t\t@before-leave=\"beforeLeave\"// 动画即将离开之前\n\t\t\t@leave=\"leave\"// 动画离开\n\t\t\t@after-leave=\"afterLeave\"// 动画离开之后\n\t\t>\n\t\t\t<p v-show=\"flag\">网博</p>\n\t\t</transition>\n```\n\n钩子函数的触发时机\n```\nmethods:{\n\t\t\t\tbeforeEnter(el){\n\t\t\t\t\t// alert('动画进入之前');\n\t\t\t\t},\n\t\t\t\tenter(){\n\t\t\t\t\t// alert('动画进入');\n\t\t\t\t},\n\t\t\t\tafterEnter(el){\n\t\t\t\t\t// alert('动画进入之后');\n\t\t\t\t\tel.style.background='blue';\n\t\t\t\t},\n\n\t\t\t\tbeforeLeave(){\n\t\t\t\t\t// alert('动画即将之前');\n\t\t\t\t},\n\t\t\t\tleave(){\n\t\t\t\t\t// alert('动画离开');\n\t\t\t\t},\n\t\t\t\tafterLeave(el){\n\t\t\t\t\t// alert('动画离开之后');\n\t\t\t\t\tel.style.background='red';\n\t\t\t\t}\n\t\t\t}\n```\n\n这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。\n\n>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。\n>否则，它们会被同步调用，过渡会立即完成。\n\n>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=\"false\"，Vue 会跳过 CSS 的检测。\n>这也可以避免过渡过程中 CSS 的影响。\n\n# 在vue中使用animations.css动画库\n\n只需要引入animations.css，然后写法如下，在标签中直接定义开始动画和离开动画即可\n\n```\n<transition enter-active-class=\"animated fadeInLeft\" leave-active-class=\"animated fadeOutRight\">\n\t\t\t<p v-show=\"flag\">网博</p>\n\t\t</transition>\n```\n\n## 多元素动画\n\n对于原生标签可以使用 v-if/v-else 。\n\n当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。\n即使在技术上没有必要，给在 `<transition>` 组件中的多个元素设置 key 也是一个更好的实践。\n```\n<transition enter-active-class=\"animated bounceInLeft\" leave-active-class=\"animated bounceOutRight\">\n\t\t\t<p v-show=\"flag\" :key=\"1\">itany</p>\n\t\t\t<p v-show=\"flag\" :key=\"2\">网博</p>\n</transition>\n```\n\n我们也可以通过给同一个元素的 key 特性设置不同的状态\n来代替 v-if 和 v-else\n\n```\n<transition>\n  <button v-bind:key=\"isEditing\">\n    {{ isEditing ? 'Save' : 'Edit' }}\n  </button>\n</transition>\n```\n\n或者使用多个if\n\n## 列表过渡\n\n同时渲染整个列表`<transition-group>`\n\n- 不同于 <transition>，它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。\n- 内部元素 总是需要 提供唯一的 key 属性值\n\n```\n<div id=\"itany\">\n\t\t<input type=\"text\" v-model=\"name\">\n\t\t\n\t\t<transition-group enter-active-class=\"animated bounceInLeft\" leave-active-class=\"animated bounceOutRight\">\n\t\t\t<p v-for=\"(v,k) in arr2\" :key=\"k\" v-show=\"flag\">\n\t\t\t\t{{v}}\n\t\t\t</p>\n\t\t</transition-group>\n\t</div>\n\n\t<script>\n\t\tvar vm=new Vue({\n\t\t\tel:'#itany',\n\t\t\tdata:{\n\t\t\t\tflag:true,\n\t\t\t\tarr:['tom','jack','mike','alice','alex','mark'],\n\t\t\t\tname:''\n\t\t\t},\n\t\t\tcomputed:{\n\t\t\t\tarr2:function(){\n\t\t\t\t\tvar temp=[];\n\t\t\t\t\tthis.arr.forEach(val => {\n\t\t\t\t\t\t// Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。\n\t\t\t\t\t\tif(val.includes(this.name)){ // 判断是否存在传入字符，存在则push元素\n\t\t\t\t\t\t\ttemp.push(val);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn temp;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t</script>\n```\n\n检测元素数组元素是否存在：\nArray.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。","slug":"vue动画与animations动画库","published":1,"updated":"2019-04-07T14:56:55.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhfm00109kudbgh1oyhw","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"单元素-组件的过渡\"><a href=\"#单元素-组件的过渡\" class=\"headerlink\" title=\"单元素/组件的过渡\"></a>单元素/组件的过渡</h2><p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p>\n<ul>\n<li>条件渲染 (使用 v-if)</li>\n<li>条件展示 (使用 v-show)</li>\n<li>动态组件</li>\n<li>组件根节点</li>\n</ul>\n<p>vue的动画也是使用css3实现的。<br>只是写法有些不一样，我们需要将代码嵌套在<transition>中</transition></p>\n<a id=\"more\"></a>\n<h2 id=\"过渡的类名\"><a href=\"#过渡的类名\" class=\"headerlink\" title=\"过渡的类名\"></a>过渡的类名</h2><p>而与css动画最大的区别，我们需要使用vue自带的模板语法<br>通过Vue自带的类名，我们可以定义css动画的触发时机</p>\n<p>在进入/离开的过渡中，会有 6 个 class 切换。</p>\n<ul>\n<li><p>v-enter：定义进入过渡的开始状态。</p>\n<ul>\n<li>在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>\n</ul>\n</li>\n<li><p>v-enter-active：定义进入过渡生效时的状态。</p>\n<ul>\n<li>在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>\n</ul>\n</li>\n<li><p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。</p>\n<ul>\n<li>在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li>\n</ul>\n</li>\n<li><p>v-leave: 定义离开过渡的开始状态。</p>\n<ul>\n<li>在离开过渡被触发时立刻生效，下一帧被移除。</li>\n</ul>\n</li>\n<li><p>v-leave-active：定义离开过渡生效时的状态。</p>\n<ul>\n<li>在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>\n</ul>\n</li>\n<li><p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。</p>\n<ul>\n<li>在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.fade-enter-active,.fade-leave-active&#123;</span><br><span class=\"line\">\t\t\ttransition:all 3s ease;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t.fade-enter-active&#123;</span><br><span class=\"line\">\t\t\topacity:1;// 动画开始状态</span><br><span class=\"line\">\t\t\twidth:300px;</span><br><span class=\"line\">\t\t\theight:300px;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t.fade-leave-active&#123;</span><br><span class=\"line\">\t\t\topacity:0;</span><br><span class=\"line\">\t\t\twidth:50px;</span><br><span class=\"line\">\t\t\theight:50px;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t/* .fade-enter需要放在.fade-enter-active的后面 */</span><br><span class=\"line\">\t\t.fade-enter&#123;</span><br><span class=\"line\">\t\t\topacity:0; /*初始状态（css重叠样式表，属性覆盖，必须放后面）*/</span><br><span class=\"line\">\t\t\twidth: 100px;</span><br><span class=\"line\">\t\t\theight: 100px;</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"javaScript-钩子\"><a href=\"#javaScript-钩子\" class=\"headerlink\" title=\"javaScript 钩子\"></a>javaScript 钩子</h2><p>可以在属性中声明 JavaScript 钩子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;fade&quot; </span><br><span class=\"line\">\t\t\t@before-enter=&quot;beforeEnter&quot;// 动画进入之前</span><br><span class=\"line\">\t\t\t@enter=&quot;enter&quot;// 动画进入</span><br><span class=\"line\">\t\t\t@after-enter=&quot;afterEnter&quot;// 动画进入之后</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t@before-leave=&quot;beforeLeave&quot;// 动画即将离开之前</span><br><span class=\"line\">\t\t\t@leave=&quot;leave&quot;// 动画离开</span><br><span class=\"line\">\t\t\t@after-leave=&quot;afterLeave&quot;// 动画离开之后</span><br><span class=\"line\">\t\t&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt;</span><br><span class=\"line\">\t\t&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n<p>钩子函数的触发时机<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">\t\t\t\tbeforeEnter(el)&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画进入之前&apos;);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tenter()&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画进入&apos;);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tafterEnter(el)&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画进入之后&apos;);</span><br><span class=\"line\">\t\t\t\t\tel.style.background=&apos;blue&apos;;</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tbeforeLeave()&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画即将之前&apos;);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tleave()&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画离开&apos;);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tafterLeave(el)&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画离开之后&apos;);</span><br><span class=\"line\">\t\t\t\t\tel.style.background=&apos;red&apos;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。</p>\n<blockquote>\n<p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。<br>否则，它们会被同步调用，过渡会立即完成。</p>\n</blockquote>\n<blockquote>\n<p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。<br>这也可以避免过渡过程中 CSS 的影响。</p>\n</blockquote>\n<h1 id=\"在vue中使用animations-css动画库\"><a href=\"#在vue中使用animations-css动画库\" class=\"headerlink\" title=\"在vue中使用animations.css动画库\"></a>在vue中使用animations.css动画库</h1><p>只需要引入animations.css，然后写法如下，在标签中直接定义开始动画和离开动画即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition enter-active-class=&quot;animated fadeInLeft&quot; leave-active-class=&quot;animated fadeOutRight&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt;</span><br><span class=\"line\">\t\t&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多元素动画\"><a href=\"#多元素动画\" class=\"headerlink\" title=\"多元素动画\"></a>多元素动画</h2><p>对于原生标签可以使用 v-if/v-else 。</p>\n<p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。<br>即使在技术上没有必要，给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key 也是一个更好的实践。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-show=&quot;flag&quot; :key=&quot;1&quot;&gt;itany&lt;/p&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-show=&quot;flag&quot; :key=&quot;2&quot;&gt;网博&lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p>\n<p>我们也可以通过给同一个元素的 key 特性设置不同的状态<br>来代替 v-if 和 v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition&gt;</span><br><span class=\"line\">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125;</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n<p>或者使用多个if</p>\n<h2 id=\"列表过渡\"><a href=\"#列表过渡\" class=\"headerlink\" title=\"列表过渡\"></a>列表过渡</h2><p>同时渲染整个列表<code>&lt;transition-group&gt;</code></p>\n<ul>\n<li>不同于 <transition>，它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。</span></transition></li>\n<li>内部元素 总是需要 提供唯一的 key 属性值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;itany&quot;&gt;</span><br><span class=\"line\">\t\t&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;transition-group enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-for=&quot;(v,k) in arr2&quot; :key=&quot;k&quot; v-show=&quot;flag&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&#123;&#123;v&#125;&#125;</span><br><span class=\"line\">\t\t\t&lt;/p&gt;</span><br><span class=\"line\">\t\t&lt;/transition-group&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;script&gt;</span><br><span class=\"line\">\t\tvar vm=new Vue(&#123;</span><br><span class=\"line\">\t\t\tel:&apos;#itany&apos;,</span><br><span class=\"line\">\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\tflag:true,</span><br><span class=\"line\">\t\t\t\tarr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;,&apos;alice&apos;,&apos;alex&apos;,&apos;mark&apos;],</span><br><span class=\"line\">\t\t\t\tname:&apos;&apos;</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tcomputed:&#123;</span><br><span class=\"line\">\t\t\t\tarr2:function()&#123;</span><br><span class=\"line\">\t\t\t\t\tvar temp=[];</span><br><span class=\"line\">\t\t\t\t\tthis.arr.forEach(val =&gt; &#123;</span><br><span class=\"line\">\t\t\t\t\t\t// Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</span><br><span class=\"line\">\t\t\t\t\t\tif(val.includes(this.name))&#123; // 判断是否存在传入字符，存在则push元素</span><br><span class=\"line\">\t\t\t\t\t\t\ttemp.push(val);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\treturn temp;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>检测元素数组元素是否存在：<br>Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"单元素-组件的过渡\"><a href=\"#单元素-组件的过渡\" class=\"headerlink\" title=\"单元素/组件的过渡\"></a>单元素/组件的过渡</h2><p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p>\n<ul>\n<li>条件渲染 (使用 v-if)</li>\n<li>条件展示 (使用 v-show)</li>\n<li>动态组件</li>\n<li>组件根节点</li>\n</ul>\n<p>vue的动画也是使用css3实现的。<br>只是写法有些不一样，我们需要将代码嵌套在<transition>中</transition></p>","more":"<h2 id=\"过渡的类名\"><a href=\"#过渡的类名\" class=\"headerlink\" title=\"过渡的类名\"></a>过渡的类名</h2><p>而与css动画最大的区别，我们需要使用vue自带的模板语法<br>通过Vue自带的类名，我们可以定义css动画的触发时机</p>\n<p>在进入/离开的过渡中，会有 6 个 class 切换。</p>\n<ul>\n<li><p>v-enter：定义进入过渡的开始状态。</p>\n<ul>\n<li>在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>\n</ul>\n</li>\n<li><p>v-enter-active：定义进入过渡生效时的状态。</p>\n<ul>\n<li>在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>\n</ul>\n</li>\n<li><p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。</p>\n<ul>\n<li>在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li>\n</ul>\n</li>\n<li><p>v-leave: 定义离开过渡的开始状态。</p>\n<ul>\n<li>在离开过渡被触发时立刻生效，下一帧被移除。</li>\n</ul>\n</li>\n<li><p>v-leave-active：定义离开过渡生效时的状态。</p>\n<ul>\n<li>在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>\n</ul>\n</li>\n<li><p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。</p>\n<ul>\n<li>在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.fade-enter-active,.fade-leave-active&#123;</span><br><span class=\"line\">\t\t\ttransition:all 3s ease;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t.fade-enter-active&#123;</span><br><span class=\"line\">\t\t\topacity:1;// 动画开始状态</span><br><span class=\"line\">\t\t\twidth:300px;</span><br><span class=\"line\">\t\t\theight:300px;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t.fade-leave-active&#123;</span><br><span class=\"line\">\t\t\topacity:0;</span><br><span class=\"line\">\t\t\twidth:50px;</span><br><span class=\"line\">\t\t\theight:50px;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t/* .fade-enter需要放在.fade-enter-active的后面 */</span><br><span class=\"line\">\t\t.fade-enter&#123;</span><br><span class=\"line\">\t\t\topacity:0; /*初始状态（css重叠样式表，属性覆盖，必须放后面）*/</span><br><span class=\"line\">\t\t\twidth: 100px;</span><br><span class=\"line\">\t\t\theight: 100px;</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"javaScript-钩子\"><a href=\"#javaScript-钩子\" class=\"headerlink\" title=\"javaScript 钩子\"></a>javaScript 钩子</h2><p>可以在属性中声明 JavaScript 钩子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition name=&quot;fade&quot; </span><br><span class=\"line\">\t\t\t@before-enter=&quot;beforeEnter&quot;// 动画进入之前</span><br><span class=\"line\">\t\t\t@enter=&quot;enter&quot;// 动画进入</span><br><span class=\"line\">\t\t\t@after-enter=&quot;afterEnter&quot;// 动画进入之后</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t@before-leave=&quot;beforeLeave&quot;// 动画即将离开之前</span><br><span class=\"line\">\t\t\t@leave=&quot;leave&quot;// 动画离开</span><br><span class=\"line\">\t\t\t@after-leave=&quot;afterLeave&quot;// 动画离开之后</span><br><span class=\"line\">\t\t&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt;</span><br><span class=\"line\">\t\t&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n<p>钩子函数的触发时机<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">\t\t\t\tbeforeEnter(el)&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画进入之前&apos;);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tenter()&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画进入&apos;);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tafterEnter(el)&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画进入之后&apos;);</span><br><span class=\"line\">\t\t\t\t\tel.style.background=&apos;blue&apos;;</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tbeforeLeave()&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画即将之前&apos;);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tleave()&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画离开&apos;);</span><br><span class=\"line\">\t\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t\tafterLeave(el)&#123;</span><br><span class=\"line\">\t\t\t\t\t// alert(&apos;动画离开之后&apos;);</span><br><span class=\"line\">\t\t\t\t\tel.style.background=&apos;red&apos;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。</p>\n<blockquote>\n<p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。<br>否则，它们会被同步调用，过渡会立即完成。</p>\n</blockquote>\n<blockquote>\n<p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。<br>这也可以避免过渡过程中 CSS 的影响。</p>\n</blockquote>\n<h1 id=\"在vue中使用animations-css动画库\"><a href=\"#在vue中使用animations-css动画库\" class=\"headerlink\" title=\"在vue中使用animations.css动画库\"></a>在vue中使用animations.css动画库</h1><p>只需要引入animations.css，然后写法如下，在标签中直接定义开始动画和离开动画即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition enter-active-class=&quot;animated fadeInLeft&quot; leave-active-class=&quot;animated fadeOutRight&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt;</span><br><span class=\"line\">\t\t&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多元素动画\"><a href=\"#多元素动画\" class=\"headerlink\" title=\"多元素动画\"></a>多元素动画</h2><p>对于原生标签可以使用 v-if/v-else 。</p>\n<p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。<br>即使在技术上没有必要，给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key 也是一个更好的实践。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-show=&quot;flag&quot; :key=&quot;1&quot;&gt;itany&lt;/p&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-show=&quot;flag&quot; :key=&quot;2&quot;&gt;网博&lt;/p&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p>\n<p>我们也可以通过给同一个元素的 key 特性设置不同的状态<br>来代替 v-if 和 v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;transition&gt;</span><br><span class=\"line\">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</span><br><span class=\"line\">    &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125;</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>\n<p>或者使用多个if</p>\n<h2 id=\"列表过渡\"><a href=\"#列表过渡\" class=\"headerlink\" title=\"列表过渡\"></a>列表过渡</h2><p>同时渲染整个列表<code>&lt;transition-group&gt;</code></p>\n<ul>\n<li>不同于 <transition>，它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。</span></transition></li>\n<li>内部元素 总是需要 提供唯一的 key 属性值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;itany&quot;&gt;</span><br><span class=\"line\">\t\t&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t&lt;transition-group enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;p v-for=&quot;(v,k) in arr2&quot; :key=&quot;k&quot; v-show=&quot;flag&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&#123;&#123;v&#125;&#125;</span><br><span class=\"line\">\t\t\t&lt;/p&gt;</span><br><span class=\"line\">\t\t&lt;/transition-group&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;script&gt;</span><br><span class=\"line\">\t\tvar vm=new Vue(&#123;</span><br><span class=\"line\">\t\t\tel:&apos;#itany&apos;,</span><br><span class=\"line\">\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\tflag:true,</span><br><span class=\"line\">\t\t\t\tarr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;,&apos;alice&apos;,&apos;alex&apos;,&apos;mark&apos;],</span><br><span class=\"line\">\t\t\t\tname:&apos;&apos;</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tcomputed:&#123;</span><br><span class=\"line\">\t\t\t\tarr2:function()&#123;</span><br><span class=\"line\">\t\t\t\t\tvar temp=[];</span><br><span class=\"line\">\t\t\t\t\tthis.arr.forEach(val =&gt; &#123;</span><br><span class=\"line\">\t\t\t\t\t\t// Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</span><br><span class=\"line\">\t\t\t\t\t\tif(val.includes(this.name))&#123; // 判断是否存在传入字符，存在则push元素</span><br><span class=\"line\">\t\t\t\t\t\t\ttemp.push(val);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t\treturn temp;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>检测元素数组元素是否存在：<br>Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>"},{"title":"vue生命周期和计算属性","date":"2018-05-01T14:30:52.000Z","_content":"\n# 生命周期\n\n## vue有八个生命周期，但只有两个是常用的\n\n新手阶段只需要掌握created()和mounted()即可\n\n<!-- more -->\n\n#### created(): 实例已经创建完成，并且已经进行数据观测和事件配置\n\n此时可用于添加数据、配置事件\n\n#### mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示\n\n此时可用于操作html和dom元素\n\n<!-- more -->\n\n```\nbeforeCreate(){\n\talert('组件实例刚刚创建，还未进行数据观测和事件配置');\n},\ncreated(){  //常用！！！\n\talert('实例已经创建完成，并且已经进行数据观测和事件配置');\n},\nbeforeMount(){\n\talert('模板编译之前，还没挂载');\n},\nmounted(){ //常用！！！\n\talert('模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示');\n},\nbeforeUpdate(){\n\talert('组件更新之前');\n},\nupdated(){\n\talert('组件更新之后');\n},\nbeforeDestroy(){\n\talert('组件销毁之前');\n},\ndestroyed(){\n\talert('组件销毁之后');\n}\n```\n\n# 计算属性 `computed`\n\n`computed`：对于两个以上操作的复杂逻辑，应当使用计算属性（不建议仅有一个操作的简单逻辑）。\n\n\n一个简单实例-反转字符串\nhtml代码\n```\n<p>{{ reversedMessage }}</p> 这里会输出olleh \n```\njs代码\n```\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello' // 绑定的字符串\n  },\n  computed: {\n    // 计算属性的 getter\n    reversedMessage: function () {\n      // `this` 指向 vm 实例\n      return this.message.split('').reverse().join('')\n      // split('')把每个字符分割，形成数组\n      // reverse()反转数组\n      // join('')拼接数组元素，返回字符串\n    }\n  }\n})\n```\n\n通过上面的实例，我们看到在计算属性中，当我们定义方法时，是使用了计算属性的一个getter。\n但是getter和setter往往是一对的，分别是只读只写。\n所以这个实例，是不是漏了什么呢？\n\n没错，它还不足以讲解计算属性，\n这里只是说明了它可以通过调用使用。\n\n另外，我们可以像绑定普通属性一样在模板中绑定计算属性。\n```\nconsole.log(vm.reversedMessage) // => 'olleH'\nvm.message = 'Goodbye'\nconsole.log(vm.reversedMessage) // => 'eybdooG'\n```\n\n## 计算属性缓存 vs 方法\n\n我们可以将同一函数定义为一个方法而不是一个计算属性。\n两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。\n\n#### `computed计算属性` 必须有计算 \n\n#### `methods方法` 一般用于处理事件、改变状态。\n\n#### 计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。\n\n这就意味着只要`数据`还没有发生改变，即便多次访问`方法`，计算属性也会立即返回之前的计算结果，而不必再次执行函数。\n这也意味着计算属性将不再更新。\n\n## 计算属性 vs 侦听属性\n\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。\n当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch\n\n然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。\n\n## 计算属性的 setter\n\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter。\n通过给set传值，可以间接改变该计算属性的值。\n#### （绝对不能直接给计算属性赋值）\n\n```\ndata:{ //普通属性\n\tnum1:8\n},\ncomputed:{ //计算属性\n\tnum2:{\n\t\tget:function(){\n\t\t\tconsole.log('num2：'+new Date());\n\t\t\treturn this.num1-1;\n\t\t},\n\t\tset:function(val){ // val=111\n\t\t\t// console.log('修改num2值');\n\t\t\t// this.num2=val; 不能直接赋值num2，那不是计算,会死循环溢出\n\t\t\tthis.num1=val;// 赋值修改num1\n\t\t}\n\t}\n},\nmethods:{\n\tchange(){\n\t\t// this.msg='i love you';\n\t\tthis.num1=666;// 赋值修改num1\n\t},\n\tgetNum2(){\n\t\tconsole.log(new Date());\n\t\treturn this.num1-1;\n\t},\n\tchange2(){\n\t\tthis.num2=111; //传入set\n\t}\n}\n```\n\n## 侦听器\n\n一旦发生改变，就会运行，watch中可以自定义函数\n```\ndata: {\n    obj: '',\n    answer: '请输入!'\n  },\nwatch: {\n    // 如果 `obj` 发生改变，这个函数就会运行\n    obj: function (新的值, 旧的值) {\n      this.answer = '每次监听到getAnswer()发生变化，就把这句话赋值给answer，反正还是会被getAnswer()覆盖'\n      this.getAnswer()// 还在methods方法里自定义要监听调用的函数。\n    }\n  },\n```","source":"_posts/vue生命周期和计算属性.md","raw":"---\ntitle: vue生命周期和计算属性\ndate: 2018-05-01 22:30:52\ncategories: 前端 vue\ntags:\n  - vue\n  - 生命周期 计算属性 \n---\n\n# 生命周期\n\n## vue有八个生命周期，但只有两个是常用的\n\n新手阶段只需要掌握created()和mounted()即可\n\n<!-- more -->\n\n#### created(): 实例已经创建完成，并且已经进行数据观测和事件配置\n\n此时可用于添加数据、配置事件\n\n#### mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示\n\n此时可用于操作html和dom元素\n\n<!-- more -->\n\n```\nbeforeCreate(){\n\talert('组件实例刚刚创建，还未进行数据观测和事件配置');\n},\ncreated(){  //常用！！！\n\talert('实例已经创建完成，并且已经进行数据观测和事件配置');\n},\nbeforeMount(){\n\talert('模板编译之前，还没挂载');\n},\nmounted(){ //常用！！！\n\talert('模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示');\n},\nbeforeUpdate(){\n\talert('组件更新之前');\n},\nupdated(){\n\talert('组件更新之后');\n},\nbeforeDestroy(){\n\talert('组件销毁之前');\n},\ndestroyed(){\n\talert('组件销毁之后');\n}\n```\n\n# 计算属性 `computed`\n\n`computed`：对于两个以上操作的复杂逻辑，应当使用计算属性（不建议仅有一个操作的简单逻辑）。\n\n\n一个简单实例-反转字符串\nhtml代码\n```\n<p>{{ reversedMessage }}</p> 这里会输出olleh \n```\njs代码\n```\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello' // 绑定的字符串\n  },\n  computed: {\n    // 计算属性的 getter\n    reversedMessage: function () {\n      // `this` 指向 vm 实例\n      return this.message.split('').reverse().join('')\n      // split('')把每个字符分割，形成数组\n      // reverse()反转数组\n      // join('')拼接数组元素，返回字符串\n    }\n  }\n})\n```\n\n通过上面的实例，我们看到在计算属性中，当我们定义方法时，是使用了计算属性的一个getter。\n但是getter和setter往往是一对的，分别是只读只写。\n所以这个实例，是不是漏了什么呢？\n\n没错，它还不足以讲解计算属性，\n这里只是说明了它可以通过调用使用。\n\n另外，我们可以像绑定普通属性一样在模板中绑定计算属性。\n```\nconsole.log(vm.reversedMessage) // => 'olleH'\nvm.message = 'Goodbye'\nconsole.log(vm.reversedMessage) // => 'eybdooG'\n```\n\n## 计算属性缓存 vs 方法\n\n我们可以将同一函数定义为一个方法而不是一个计算属性。\n两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。\n\n#### `computed计算属性` 必须有计算 \n\n#### `methods方法` 一般用于处理事件、改变状态。\n\n#### 计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。\n\n这就意味着只要`数据`还没有发生改变，即便多次访问`方法`，计算属性也会立即返回之前的计算结果，而不必再次执行函数。\n这也意味着计算属性将不再更新。\n\n## 计算属性 vs 侦听属性\n\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。\n当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch\n\n然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。\n\n## 计算属性的 setter\n\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter。\n通过给set传值，可以间接改变该计算属性的值。\n#### （绝对不能直接给计算属性赋值）\n\n```\ndata:{ //普通属性\n\tnum1:8\n},\ncomputed:{ //计算属性\n\tnum2:{\n\t\tget:function(){\n\t\t\tconsole.log('num2：'+new Date());\n\t\t\treturn this.num1-1;\n\t\t},\n\t\tset:function(val){ // val=111\n\t\t\t// console.log('修改num2值');\n\t\t\t// this.num2=val; 不能直接赋值num2，那不是计算,会死循环溢出\n\t\t\tthis.num1=val;// 赋值修改num1\n\t\t}\n\t}\n},\nmethods:{\n\tchange(){\n\t\t// this.msg='i love you';\n\t\tthis.num1=666;// 赋值修改num1\n\t},\n\tgetNum2(){\n\t\tconsole.log(new Date());\n\t\treturn this.num1-1;\n\t},\n\tchange2(){\n\t\tthis.num2=111; //传入set\n\t}\n}\n```\n\n## 侦听器\n\n一旦发生改变，就会运行，watch中可以自定义函数\n```\ndata: {\n    obj: '',\n    answer: '请输入!'\n  },\nwatch: {\n    // 如果 `obj` 发生改变，这个函数就会运行\n    obj: function (新的值, 旧的值) {\n      this.answer = '每次监听到getAnswer()发生变化，就把这句话赋值给answer，反正还是会被getAnswer()覆盖'\n      this.getAnswer()// 还在methods方法里自定义要监听调用的函数。\n    }\n  },\n```","slug":"vue生命周期和计算属性","published":1,"updated":"2019-06-16T08:32:35.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhfq00159kud8i2ouezy","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h1><h2 id=\"vue有八个生命周期，但只有两个是常用的\"><a href=\"#vue有八个生命周期，但只有两个是常用的\" class=\"headerlink\" title=\"vue有八个生命周期，但只有两个是常用的\"></a>vue有八个生命周期，但只有两个是常用的</h2><p>新手阶段只需要掌握created()和mounted()即可</p>\n<a id=\"more\"></a>\n<h4 id=\"created-实例已经创建完成，并且已经进行数据观测和事件配置\"><a href=\"#created-实例已经创建完成，并且已经进行数据观测和事件配置\" class=\"headerlink\" title=\"created(): 实例已经创建完成，并且已经进行数据观测和事件配置\"></a>created(): 实例已经创建完成，并且已经进行数据观测和事件配置</h4><p>此时可用于添加数据、配置事件</p>\n<h4 id=\"mounted-模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示\"><a href=\"#mounted-模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示\" class=\"headerlink\" title=\"mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示\"></a>mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示</h4><p>此时可用于操作html和dom元素</p>\n<!-- more -->\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate()&#123;</span><br><span class=\"line\">\talert(&apos;组件实例刚刚创建，还未进行数据观测和事件配置&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">created()&#123;  //常用！！！</span><br><span class=\"line\">\talert(&apos;实例已经创建完成，并且已经进行数据观测和事件配置&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeMount()&#123;</span><br><span class=\"line\">\talert(&apos;模板编译之前，还没挂载&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mounted()&#123; //常用！！！</span><br><span class=\"line\">\talert(&apos;模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeUpdate()&#123;</span><br><span class=\"line\">\talert(&apos;组件更新之前&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">updated()&#123;</span><br><span class=\"line\">\talert(&apos;组件更新之后&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy()&#123;</span><br><span class=\"line\">\talert(&apos;组件销毁之前&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">destroyed()&#123;</span><br><span class=\"line\">\talert(&apos;组件销毁之后&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"计算属性-computed\"><a href=\"#计算属性-computed\" class=\"headerlink\" title=\"计算属性 computed\"></a>计算属性 <code>computed</code></h1><p><code>computed</code>：对于两个以上操作的复杂逻辑，应当使用计算属性（不建议仅有一个操作的简单逻辑）。</p>\n<p>一个简单实例-反转字符串<br>html代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt; 这里会输出olleh</span><br></pre></td></tr></table></figure></p>\n<p>js代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &apos;Hello&apos; // 绑定的字符串</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    // 计算属性的 getter</span><br><span class=\"line\">    reversedMessage: function () &#123;</span><br><span class=\"line\">      // `this` 指向 vm 实例</span><br><span class=\"line\">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class=\"line\">      // split(&apos;&apos;)把每个字符分割，形成数组</span><br><span class=\"line\">      // reverse()反转数组</span><br><span class=\"line\">      // join(&apos;&apos;)拼接数组元素，返回字符串</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的实例，我们看到在计算属性中，当我们定义方法时，是使用了计算属性的一个getter。<br>但是getter和setter往往是一对的，分别是只读只写。<br>所以这个实例，是不是漏了什么呢？</p>\n<p>没错，它还不足以讲解计算属性，<br>这里只是说明了它可以通过调用使用。</p>\n<p>另外，我们可以像绑定普通属性一样在模板中绑定计算属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(vm.reversedMessage) // =&gt; &apos;olleH&apos;</span><br><span class=\"line\">vm.message = &apos;Goodbye&apos;</span><br><span class=\"line\">console.log(vm.reversedMessage) // =&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h2><p>我们可以将同一函数定义为一个方法而不是一个计算属性。<br>两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。</p>\n<h4 id=\"computed计算属性-必须有计算\"><a href=\"#computed计算属性-必须有计算\" class=\"headerlink\" title=\"computed计算属性 必须有计算\"></a><code>computed计算属性</code> 必须有计算</h4><h4 id=\"methods方法-一般用于处理事件、改变状态。\"><a href=\"#methods方法-一般用于处理事件、改变状态。\" class=\"headerlink\" title=\"methods方法 一般用于处理事件、改变状态。\"></a><code>methods方法</code> 一般用于处理事件、改变状态。</h4><h4 id=\"计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。\"><a href=\"#计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。\" class=\"headerlink\" title=\"计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。\"></a>计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。</h4><p>这就意味着只要<code>数据</code>还没有发生改变，即便多次访问<code>方法</code>，计算属性也会立即返回之前的计算结果，而不必再次执行函数。<br>这也意味着计算属性将不再更新。</p>\n<h2 id=\"计算属性-vs-侦听属性\"><a href=\"#计算属性-vs-侦听属性\" class=\"headerlink\" title=\"计算属性 vs 侦听属性\"></a>计算属性 vs 侦听属性</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。<br>当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch</p>\n<p>然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p>\n<h2 id=\"计算属性的-setter\"><a href=\"#计算属性的-setter\" class=\"headerlink\" title=\"计算属性的 setter\"></a>计算属性的 setter</h2><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter。<br>通过给set传值，可以间接改变该计算属性的值。</p>\n<h4 id=\"（绝对不能直接给计算属性赋值）\"><a href=\"#（绝对不能直接给计算属性赋值）\" class=\"headerlink\" title=\"（绝对不能直接给计算属性赋值）\"></a>（绝对不能直接给计算属性赋值）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:&#123; //普通属性</span><br><span class=\"line\">\tnum1:8</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">computed:&#123; //计算属性</span><br><span class=\"line\">\tnum2:&#123;</span><br><span class=\"line\">\t\tget:function()&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&apos;num2：&apos;+new Date());</span><br><span class=\"line\">\t\t\treturn this.num1-1;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tset:function(val)&#123; // val=111</span><br><span class=\"line\">\t\t\t// console.log(&apos;修改num2值&apos;);</span><br><span class=\"line\">\t\t\t// this.num2=val; 不能直接赋值num2，那不是计算,会死循环溢出</span><br><span class=\"line\">\t\t\tthis.num1=val;// 赋值修改num1</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">\tchange()&#123;</span><br><span class=\"line\">\t\t// this.msg=&apos;i love you&apos;;</span><br><span class=\"line\">\t\tthis.num1=666;// 赋值修改num1</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tgetNum2()&#123;</span><br><span class=\"line\">\t\tconsole.log(new Date());</span><br><span class=\"line\">\t\treturn this.num1-1;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tchange2()&#123;</span><br><span class=\"line\">\t\tthis.num2=111; //传入set</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h2><p>一旦发生改变，就会运行，watch中可以自定义函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: &#123;</span><br><span class=\"line\">    obj: &apos;&apos;,</span><br><span class=\"line\">    answer: &apos;请输入!&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">watch: &#123;</span><br><span class=\"line\">    // 如果 `obj` 发生改变，这个函数就会运行</span><br><span class=\"line\">    obj: function (新的值, 旧的值) &#123;</span><br><span class=\"line\">      this.answer = &apos;每次监听到getAnswer()发生变化，就把这句话赋值给answer，反正还是会被getAnswer()覆盖&apos;</span><br><span class=\"line\">      this.getAnswer()// 还在methods方法里自定义要监听调用的函数。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h1><h2 id=\"vue有八个生命周期，但只有两个是常用的\"><a href=\"#vue有八个生命周期，但只有两个是常用的\" class=\"headerlink\" title=\"vue有八个生命周期，但只有两个是常用的\"></a>vue有八个生命周期，但只有两个是常用的</h2><p>新手阶段只需要掌握created()和mounted()即可</p>","more":"<h4 id=\"created-实例已经创建完成，并且已经进行数据观测和事件配置\"><a href=\"#created-实例已经创建完成，并且已经进行数据观测和事件配置\" class=\"headerlink\" title=\"created(): 实例已经创建完成，并且已经进行数据观测和事件配置\"></a>created(): 实例已经创建完成，并且已经进行数据观测和事件配置</h4><p>此时可用于添加数据、配置事件</p>\n<h4 id=\"mounted-模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示\"><a href=\"#mounted-模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示\" class=\"headerlink\" title=\"mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示\"></a>mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示</h4><p>此时可用于操作html和dom元素</p>\n<!-- more -->\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate()&#123;</span><br><span class=\"line\">\talert(&apos;组件实例刚刚创建，还未进行数据观测和事件配置&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">created()&#123;  //常用！！！</span><br><span class=\"line\">\talert(&apos;实例已经创建完成，并且已经进行数据观测和事件配置&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeMount()&#123;</span><br><span class=\"line\">\talert(&apos;模板编译之前，还没挂载&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mounted()&#123; //常用！！！</span><br><span class=\"line\">\talert(&apos;模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeUpdate()&#123;</span><br><span class=\"line\">\talert(&apos;组件更新之前&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">updated()&#123;</span><br><span class=\"line\">\talert(&apos;组件更新之后&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy()&#123;</span><br><span class=\"line\">\talert(&apos;组件销毁之前&apos;);</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">destroyed()&#123;</span><br><span class=\"line\">\talert(&apos;组件销毁之后&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"计算属性-computed\"><a href=\"#计算属性-computed\" class=\"headerlink\" title=\"计算属性 computed\"></a>计算属性 <code>computed</code></h1><p><code>computed</code>：对于两个以上操作的复杂逻辑，应当使用计算属性（不建议仅有一个操作的简单逻辑）。</p>\n<p>一个简单实例-反转字符串<br>html代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt; 这里会输出olleh</span><br></pre></td></tr></table></figure></p>\n<p>js代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &apos;Hello&apos; // 绑定的字符串</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    // 计算属性的 getter</span><br><span class=\"line\">    reversedMessage: function () &#123;</span><br><span class=\"line\">      // `this` 指向 vm 实例</span><br><span class=\"line\">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class=\"line\">      // split(&apos;&apos;)把每个字符分割，形成数组</span><br><span class=\"line\">      // reverse()反转数组</span><br><span class=\"line\">      // join(&apos;&apos;)拼接数组元素，返回字符串</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的实例，我们看到在计算属性中，当我们定义方法时，是使用了计算属性的一个getter。<br>但是getter和setter往往是一对的，分别是只读只写。<br>所以这个实例，是不是漏了什么呢？</p>\n<p>没错，它还不足以讲解计算属性，<br>这里只是说明了它可以通过调用使用。</p>\n<p>另外，我们可以像绑定普通属性一样在模板中绑定计算属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(vm.reversedMessage) // =&gt; &apos;olleH&apos;</span><br><span class=\"line\">vm.message = &apos;Goodbye&apos;</span><br><span class=\"line\">console.log(vm.reversedMessage) // =&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"计算属性缓存-vs-方法\"><a href=\"#计算属性缓存-vs-方法\" class=\"headerlink\" title=\"计算属性缓存 vs 方法\"></a>计算属性缓存 vs 方法</h2><p>我们可以将同一函数定义为一个方法而不是一个计算属性。<br>两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。</p>\n<h4 id=\"computed计算属性-必须有计算\"><a href=\"#computed计算属性-必须有计算\" class=\"headerlink\" title=\"computed计算属性 必须有计算\"></a><code>computed计算属性</code> 必须有计算</h4><h4 id=\"methods方法-一般用于处理事件、改变状态。\"><a href=\"#methods方法-一般用于处理事件、改变状态。\" class=\"headerlink\" title=\"methods方法 一般用于处理事件、改变状态。\"></a><code>methods方法</code> 一般用于处理事件、改变状态。</h4><h4 id=\"计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。\"><a href=\"#计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。\" class=\"headerlink\" title=\"计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。\"></a>计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。</h4><p>这就意味着只要<code>数据</code>还没有发生改变，即便多次访问<code>方法</code>，计算属性也会立即返回之前的计算结果，而不必再次执行函数。<br>这也意味着计算属性将不再更新。</p>\n<h2 id=\"计算属性-vs-侦听属性\"><a href=\"#计算属性-vs-侦听属性\" class=\"headerlink\" title=\"计算属性 vs 侦听属性\"></a>计算属性 vs 侦听属性</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。<br>当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch</p>\n<p>然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p>\n<h2 id=\"计算属性的-setter\"><a href=\"#计算属性的-setter\" class=\"headerlink\" title=\"计算属性的 setter\"></a>计算属性的 setter</h2><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter。<br>通过给set传值，可以间接改变该计算属性的值。</p>\n<h4 id=\"（绝对不能直接给计算属性赋值）\"><a href=\"#（绝对不能直接给计算属性赋值）\" class=\"headerlink\" title=\"（绝对不能直接给计算属性赋值）\"></a>（绝对不能直接给计算属性赋值）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:&#123; //普通属性</span><br><span class=\"line\">\tnum1:8</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">computed:&#123; //计算属性</span><br><span class=\"line\">\tnum2:&#123;</span><br><span class=\"line\">\t\tget:function()&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&apos;num2：&apos;+new Date());</span><br><span class=\"line\">\t\t\treturn this.num1-1;</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\tset:function(val)&#123; // val=111</span><br><span class=\"line\">\t\t\t// console.log(&apos;修改num2值&apos;);</span><br><span class=\"line\">\t\t\t// this.num2=val; 不能直接赋值num2，那不是计算,会死循环溢出</span><br><span class=\"line\">\t\t\tthis.num1=val;// 赋值修改num1</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">\tchange()&#123;</span><br><span class=\"line\">\t\t// this.msg=&apos;i love you&apos;;</span><br><span class=\"line\">\t\tthis.num1=666;// 赋值修改num1</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tgetNum2()&#123;</span><br><span class=\"line\">\t\tconsole.log(new Date());</span><br><span class=\"line\">\t\treturn this.num1-1;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tchange2()&#123;</span><br><span class=\"line\">\t\tthis.num2=111; //传入set</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"侦听器\"><a href=\"#侦听器\" class=\"headerlink\" title=\"侦听器\"></a>侦听器</h2><p>一旦发生改变，就会运行，watch中可以自定义函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data: &#123;</span><br><span class=\"line\">    obj: &apos;&apos;,</span><br><span class=\"line\">    answer: &apos;请输入!&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">watch: &#123;</span><br><span class=\"line\">    // 如果 `obj` 发生改变，这个函数就会运行</span><br><span class=\"line\">    obj: function (新的值, 旧的值) &#123;</span><br><span class=\"line\">      this.answer = &apos;每次监听到getAnswer()发生变化，就把这句话赋值给answer，反正还是会被getAnswer()覆盖&apos;</span><br><span class=\"line\">      this.getAnswer()// 还在methods方法里自定义要监听调用的函数。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure></p>"},{"title":"vue的实例属性和方法","date":"2018-05-01T14:31:14.000Z","_content":"\n[TOC]\n\n# vue实例的属性和方法\n仅记录部分\n大部分时候是随学随用，但是学到了就来记录。\n\n>实例属性和方法 == 组件实例和方法 != 全局属性和方法\n\n- 另外，在组件实例的`methods方法`中不能使用全局Vue方法\n\n<!-- more -->\n\n## 属性\n\n#### vm.属性名 获取data中的属性\n```\n//console.log(vm.msg);\n```\n\n#### vm.$el 获取vue实例关联的元素\n```\n// console.log(vm.$el); //DOM对象\n// vm.$el.style.color='red';\n```\n\n#### vm.$data 获取数据对象data\n```\n// console.log(vm.$data);\n// console.log(vm.$data.msg);\n```\n\n#### vm.$options 获取自定义属性\n```\n// console.log(vm.$options.name);\n// console.log(vm.$options.age);\n// vm.$options.show();\n```\n\n#### vm.$refs 获取所有添加ref属性的元素\n```\n// console.log(vm.$refs);\n// console.log(vm.$refs.hello); //DOM对象\n// vm.$refs.hello.style.color='blue';\n```\n\n## 方法\n\n\n#### vm.$mount()  手动挂载vue实例\n\n\t\t// vm.$mount('#itany');\n\t\tvar vm=new Vue({\n\t\t\tdata:{\n\t\t\t\tmsg:'欢迎来到南京网博',\n\t\t\t\tname:'tom'\n\t\t\t}\n\t\t}).$mount('#itany');\n\n#### vm.$destroy() 销毁实例\n这个列出来只是了解一下，官方也建议使用`v-if`或`v-for`以数据驱动的方式控制子组件和生命周期\n\n\t\t// vm.$destroy();\n\n#### vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM\n\n\t\t//修改数据\n\t\tvm.name='汤姆';\n\t\t//DOM还没更新完，Vue实现响应式并不是数据发生改变之后DOM立即变化，需要按一定的策略进行DOM更新，需要时间！！\n\t\t// console.log(vm.$refs.title.textContent);\n\t\tvm.$nextTick(function(){\n\t\t\t//DOM更新完成，更新完成后再执行此代码\n\t\t\tconsole.log(vm.$refs.title.textContent);\n\t\t});\n\n#### vm.$set(target,key,value) 添加对象的属性和值\n\n[关于dom](https://github.com/stone0090/javascript-lessons/tree/master/2.2-DOM)\n\n// vm.$set(this.food, 'count', 1);\n// 注意：在`methods方法`中不能使用`Vue.set`\n// 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新\n// Tip:Vue.set()在methods中可以写成this.$set()\n\n#### vm.$delete(target,key) 删除对象的属性\n\n// vm.$delete(this.food, 'count');\n// 注意：在`methods方法`中不能使用`Vue.delete`\n\n#### vm.$watch( expOrFn, callback, [options] ) 观察者模式\n\n参数：监听对象，回调方法，选项（deep/immediate）\n\n观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。\n表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。\n\n实例使用方法\n```\n//方式1：使用vue实例提供的$watch()方法\n\t\tvm.$watch('name',function(newValue,oldValue){\n\t\t\tconsole.log('name被修改啦，原值：'+oldValue+'，新值：'+newValue);\n\t\t});\n```\nvue提供的选项方法\n```\nwatch:{ //方式2：使用vue实例提供的watch选项\n\tage:(newValue,oldValue) => {\n\t\tconsole.log('age被修改啦，原值：'+oldValue+'，新值：'+newValue);\n\t},\n    // 对对象监视，需要使用深度监视\n\tuser:{\n\t\thandler:(newValue,oldValue) => {\n\t\tconsole.log('user被修改啦，原值：'+oldValue.name+'，新值：'+newValue.name);\n\t},\n\tdeep:true //深度监视，当对象中的属性发生变化时也会监视\n\t}\n}\n```\n\n#### vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。\n","source":"_posts/vue的实例属性和方法.md","raw":"---\ntitle: vue的实例属性和方法\ndate: 2018-05-01 22:31:14\ncategories: 前端 vue\ntags:\n  - vue\n  - vue实例属性 计算属性 \n---\n\n[TOC]\n\n# vue实例的属性和方法\n仅记录部分\n大部分时候是随学随用，但是学到了就来记录。\n\n>实例属性和方法 == 组件实例和方法 != 全局属性和方法\n\n- 另外，在组件实例的`methods方法`中不能使用全局Vue方法\n\n<!-- more -->\n\n## 属性\n\n#### vm.属性名 获取data中的属性\n```\n//console.log(vm.msg);\n```\n\n#### vm.$el 获取vue实例关联的元素\n```\n// console.log(vm.$el); //DOM对象\n// vm.$el.style.color='red';\n```\n\n#### vm.$data 获取数据对象data\n```\n// console.log(vm.$data);\n// console.log(vm.$data.msg);\n```\n\n#### vm.$options 获取自定义属性\n```\n// console.log(vm.$options.name);\n// console.log(vm.$options.age);\n// vm.$options.show();\n```\n\n#### vm.$refs 获取所有添加ref属性的元素\n```\n// console.log(vm.$refs);\n// console.log(vm.$refs.hello); //DOM对象\n// vm.$refs.hello.style.color='blue';\n```\n\n## 方法\n\n\n#### vm.$mount()  手动挂载vue实例\n\n\t\t// vm.$mount('#itany');\n\t\tvar vm=new Vue({\n\t\t\tdata:{\n\t\t\t\tmsg:'欢迎来到南京网博',\n\t\t\t\tname:'tom'\n\t\t\t}\n\t\t}).$mount('#itany');\n\n#### vm.$destroy() 销毁实例\n这个列出来只是了解一下，官方也建议使用`v-if`或`v-for`以数据驱动的方式控制子组件和生命周期\n\n\t\t// vm.$destroy();\n\n#### vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM\n\n\t\t//修改数据\n\t\tvm.name='汤姆';\n\t\t//DOM还没更新完，Vue实现响应式并不是数据发生改变之后DOM立即变化，需要按一定的策略进行DOM更新，需要时间！！\n\t\t// console.log(vm.$refs.title.textContent);\n\t\tvm.$nextTick(function(){\n\t\t\t//DOM更新完成，更新完成后再执行此代码\n\t\t\tconsole.log(vm.$refs.title.textContent);\n\t\t});\n\n#### vm.$set(target,key,value) 添加对象的属性和值\n\n[关于dom](https://github.com/stone0090/javascript-lessons/tree/master/2.2-DOM)\n\n// vm.$set(this.food, 'count', 1);\n// 注意：在`methods方法`中不能使用`Vue.set`\n// 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新\n// Tip:Vue.set()在methods中可以写成this.$set()\n\n#### vm.$delete(target,key) 删除对象的属性\n\n// vm.$delete(this.food, 'count');\n// 注意：在`methods方法`中不能使用`Vue.delete`\n\n#### vm.$watch( expOrFn, callback, [options] ) 观察者模式\n\n参数：监听对象，回调方法，选项（deep/immediate）\n\n观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。\n表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。\n\n实例使用方法\n```\n//方式1：使用vue实例提供的$watch()方法\n\t\tvm.$watch('name',function(newValue,oldValue){\n\t\t\tconsole.log('name被修改啦，原值：'+oldValue+'，新值：'+newValue);\n\t\t});\n```\nvue提供的选项方法\n```\nwatch:{ //方式2：使用vue实例提供的watch选项\n\tage:(newValue,oldValue) => {\n\t\tconsole.log('age被修改啦，原值：'+oldValue+'，新值：'+newValue);\n\t},\n    // 对对象监视，需要使用深度监视\n\tuser:{\n\t\thandler:(newValue,oldValue) => {\n\t\tconsole.log('user被修改啦，原值：'+oldValue.name+'，新值：'+newValue.name);\n\t},\n\tdeep:true //深度监视，当对象中的属性发生变化时也会监视\n\t}\n}\n```\n\n#### vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。\n","slug":"vue的实例属性和方法","published":1,"updated":"2019-06-16T08:32:49.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhfs00179kudtjb761pr","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[TOC]</p>\n<h1 id=\"vue实例的属性和方法\"><a href=\"#vue实例的属性和方法\" class=\"headerlink\" title=\"vue实例的属性和方法\"></a>vue实例的属性和方法</h1><p>仅记录部分<br>大部分时候是随学随用，但是学到了就来记录。</p>\n<blockquote>\n<p>实例属性和方法 == 组件实例和方法 != 全局属性和方法</p>\n</blockquote>\n<ul>\n<li>另外，在组件实例的<code>methods方法</code>中不能使用全局Vue方法</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h4 id=\"vm-属性名-获取data中的属性\"><a href=\"#vm-属性名-获取data中的属性\" class=\"headerlink\" title=\"vm.属性名 获取data中的属性\"></a>vm.属性名 获取data中的属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//console.log(vm.msg);</span><br></pre></td></tr></table></figure>\n<h4 id=\"vm-el-获取vue实例关联的元素\"><a href=\"#vm-el-获取vue实例关联的元素\" class=\"headerlink\" title=\"vm.$el 获取vue实例关联的元素\"></a>vm.$el 获取vue实例关联的元素</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// console.log(vm.$el); //DOM对象</span><br><span class=\"line\">// vm.$el.style.color=&apos;red&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"vm-data-获取数据对象data\"><a href=\"#vm-data-获取数据对象data\" class=\"headerlink\" title=\"vm.$data 获取数据对象data\"></a>vm.$data 获取数据对象data</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// console.log(vm.$data);</span><br><span class=\"line\">// console.log(vm.$data.msg);</span><br></pre></td></tr></table></figure>\n<h4 id=\"vm-options-获取自定义属性\"><a href=\"#vm-options-获取自定义属性\" class=\"headerlink\" title=\"vm.$options 获取自定义属性\"></a>vm.$options 获取自定义属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// console.log(vm.$options.name);</span><br><span class=\"line\">// console.log(vm.$options.age);</span><br><span class=\"line\">// vm.$options.show();</span><br></pre></td></tr></table></figure>\n<h4 id=\"vm-refs-获取所有添加ref属性的元素\"><a href=\"#vm-refs-获取所有添加ref属性的元素\" class=\"headerlink\" title=\"vm.$refs 获取所有添加ref属性的元素\"></a>vm.$refs 获取所有添加ref属性的元素</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// console.log(vm.$refs);</span><br><span class=\"line\">// console.log(vm.$refs.hello); //DOM对象</span><br><span class=\"line\">// vm.$refs.hello.style.color=&apos;blue&apos;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h4 id=\"vm-mount-手动挂载vue实例\"><a href=\"#vm-mount-手动挂载vue实例\" class=\"headerlink\" title=\"vm.$mount()  手动挂载vue实例\"></a>vm.$mount()  手动挂载vue实例</h4><pre><code>// vm.$mount(&apos;#itany&apos;);\nvar vm=new Vue({\n    data:{\n        msg:&apos;欢迎来到南京网博&apos;,\n        name:&apos;tom&apos;\n    }\n}).$mount(&apos;#itany&apos;);\n</code></pre><h4 id=\"vm-destroy-销毁实例\"><a href=\"#vm-destroy-销毁实例\" class=\"headerlink\" title=\"vm.$destroy() 销毁实例\"></a>vm.$destroy() 销毁实例</h4><p>这个列出来只是了解一下，官方也建议使用<code>v-if</code>或<code>v-for</code>以数据驱动的方式控制子组件和生命周期</p>\n<pre><code>// vm.$destroy();\n</code></pre><h4 id=\"vm-nextTick-callback-在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM\"><a href=\"#vm-nextTick-callback-在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM\" class=\"headerlink\" title=\"vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM\"></a>vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM</h4><pre><code>//修改数据\nvm.name=&apos;汤姆&apos;;\n//DOM还没更新完，Vue实现响应式并不是数据发生改变之后DOM立即变化，需要按一定的策略进行DOM更新，需要时间！！\n// console.log(vm.$refs.title.textContent);\nvm.$nextTick(function(){\n    //DOM更新完成，更新完成后再执行此代码\n    console.log(vm.$refs.title.textContent);\n});\n</code></pre><h4 id=\"vm-set-target-key-value-添加对象的属性和值\"><a href=\"#vm-set-target-key-value-添加对象的属性和值\" class=\"headerlink\" title=\"vm.$set(target,key,value) 添加对象的属性和值\"></a>vm.$set(target,key,value) 添加对象的属性和值</h4><p><a href=\"https://github.com/stone0090/javascript-lessons/tree/master/2.2-DOM\" target=\"_blank\" rel=\"noopener\">关于dom</a></p>\n<p>// vm.$set(this.food, ‘count’, 1);<br>// 注意：在<code>methods方法</code>中不能使用<code>Vue.set</code><br>// 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新<br>// Tip:Vue.set()在methods中可以写成this.$set()</p>\n<h4 id=\"vm-delete-target-key-删除对象的属性\"><a href=\"#vm-delete-target-key-删除对象的属性\" class=\"headerlink\" title=\"vm.$delete(target,key) 删除对象的属性\"></a>vm.$delete(target,key) 删除对象的属性</h4><p>// vm.$delete(this.food, ‘count’);<br>// 注意：在<code>methods方法</code>中不能使用<code>Vue.delete</code></p>\n<h4 id=\"vm-watch-expOrFn-callback-options-观察者模式\"><a href=\"#vm-watch-expOrFn-callback-options-观察者模式\" class=\"headerlink\" title=\"vm.$watch( expOrFn, callback, [options] ) 观察者模式\"></a>vm.$watch( expOrFn, callback, [options] ) 观察者模式</h4><p>参数：监听对象，回调方法，选项（deep/immediate）</p>\n<p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。<br>表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p>\n<p>实例使用方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式1：使用vue实例提供的$watch()方法</span><br><span class=\"line\">\t\tvm.$watch(&apos;name&apos;,function(newValue,oldValue)&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&apos;name被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue);</span><br><span class=\"line\">\t\t&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>vue提供的选项方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch:&#123; //方式2：使用vue实例提供的watch选项</span><br><span class=\"line\">\tage:(newValue,oldValue) =&gt; &#123;</span><br><span class=\"line\">\t\tconsole.log(&apos;age被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">    // 对对象监视，需要使用深度监视</span><br><span class=\"line\">\tuser:&#123;</span><br><span class=\"line\">\t\thandler:(newValue,oldValue) =&gt; &#123;</span><br><span class=\"line\">\t\tconsole.log(&apos;user被修改啦，原值：&apos;+oldValue.name+&apos;，新值：&apos;+newValue.name);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tdeep:true //深度监视，当对象中的属性发生变化时也会监视</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"vm-emit-event-…args-触发当前实例上的事件。附加参数都会传给监听器回调。\"><a href=\"#vm-emit-event-…args-触发当前实例上的事件。附加参数都会传给监听器回调。\" class=\"headerlink\" title=\"vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。\"></a>vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。</h4>","site":{"data":{}},"excerpt":"<p>[TOC]</p>\n<h1 id=\"vue实例的属性和方法\"><a href=\"#vue实例的属性和方法\" class=\"headerlink\" title=\"vue实例的属性和方法\"></a>vue实例的属性和方法</h1><p>仅记录部分<br>大部分时候是随学随用，但是学到了就来记录。</p>\n<blockquote>\n<p>实例属性和方法 == 组件实例和方法 != 全局属性和方法</p>\n</blockquote>\n<ul>\n<li>另外，在组件实例的<code>methods方法</code>中不能使用全局Vue方法</li>\n</ul>","more":"<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><h4 id=\"vm-属性名-获取data中的属性\"><a href=\"#vm-属性名-获取data中的属性\" class=\"headerlink\" title=\"vm.属性名 获取data中的属性\"></a>vm.属性名 获取data中的属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//console.log(vm.msg);</span><br></pre></td></tr></table></figure>\n<h4 id=\"vm-el-获取vue实例关联的元素\"><a href=\"#vm-el-获取vue实例关联的元素\" class=\"headerlink\" title=\"vm.$el 获取vue实例关联的元素\"></a>vm.$el 获取vue实例关联的元素</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// console.log(vm.$el); //DOM对象</span><br><span class=\"line\">// vm.$el.style.color=&apos;red&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"vm-data-获取数据对象data\"><a href=\"#vm-data-获取数据对象data\" class=\"headerlink\" title=\"vm.$data 获取数据对象data\"></a>vm.$data 获取数据对象data</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// console.log(vm.$data);</span><br><span class=\"line\">// console.log(vm.$data.msg);</span><br></pre></td></tr></table></figure>\n<h4 id=\"vm-options-获取自定义属性\"><a href=\"#vm-options-获取自定义属性\" class=\"headerlink\" title=\"vm.$options 获取自定义属性\"></a>vm.$options 获取自定义属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// console.log(vm.$options.name);</span><br><span class=\"line\">// console.log(vm.$options.age);</span><br><span class=\"line\">// vm.$options.show();</span><br></pre></td></tr></table></figure>\n<h4 id=\"vm-refs-获取所有添加ref属性的元素\"><a href=\"#vm-refs-获取所有添加ref属性的元素\" class=\"headerlink\" title=\"vm.$refs 获取所有添加ref属性的元素\"></a>vm.$refs 获取所有添加ref属性的元素</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// console.log(vm.$refs);</span><br><span class=\"line\">// console.log(vm.$refs.hello); //DOM对象</span><br><span class=\"line\">// vm.$refs.hello.style.color=&apos;blue&apos;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h4 id=\"vm-mount-手动挂载vue实例\"><a href=\"#vm-mount-手动挂载vue实例\" class=\"headerlink\" title=\"vm.$mount()  手动挂载vue实例\"></a>vm.$mount()  手动挂载vue实例</h4><pre><code>// vm.$mount(&apos;#itany&apos;);\nvar vm=new Vue({\n    data:{\n        msg:&apos;欢迎来到南京网博&apos;,\n        name:&apos;tom&apos;\n    }\n}).$mount(&apos;#itany&apos;);\n</code></pre><h4 id=\"vm-destroy-销毁实例\"><a href=\"#vm-destroy-销毁实例\" class=\"headerlink\" title=\"vm.$destroy() 销毁实例\"></a>vm.$destroy() 销毁实例</h4><p>这个列出来只是了解一下，官方也建议使用<code>v-if</code>或<code>v-for</code>以数据驱动的方式控制子组件和生命周期</p>\n<pre><code>// vm.$destroy();\n</code></pre><h4 id=\"vm-nextTick-callback-在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM\"><a href=\"#vm-nextTick-callback-在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM\" class=\"headerlink\" title=\"vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM\"></a>vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM</h4><pre><code>//修改数据\nvm.name=&apos;汤姆&apos;;\n//DOM还没更新完，Vue实现响应式并不是数据发生改变之后DOM立即变化，需要按一定的策略进行DOM更新，需要时间！！\n// console.log(vm.$refs.title.textContent);\nvm.$nextTick(function(){\n    //DOM更新完成，更新完成后再执行此代码\n    console.log(vm.$refs.title.textContent);\n});\n</code></pre><h4 id=\"vm-set-target-key-value-添加对象的属性和值\"><a href=\"#vm-set-target-key-value-添加对象的属性和值\" class=\"headerlink\" title=\"vm.$set(target,key,value) 添加对象的属性和值\"></a>vm.$set(target,key,value) 添加对象的属性和值</h4><p><a href=\"https://github.com/stone0090/javascript-lessons/tree/master/2.2-DOM\" target=\"_blank\" rel=\"noopener\">关于dom</a></p>\n<p>// vm.$set(this.food, ‘count’, 1);<br>// 注意：在<code>methods方法</code>中不能使用<code>Vue.set</code><br>// 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新<br>// Tip:Vue.set()在methods中可以写成this.$set()</p>\n<h4 id=\"vm-delete-target-key-删除对象的属性\"><a href=\"#vm-delete-target-key-删除对象的属性\" class=\"headerlink\" title=\"vm.$delete(target,key) 删除对象的属性\"></a>vm.$delete(target,key) 删除对象的属性</h4><p>// vm.$delete(this.food, ‘count’);<br>// 注意：在<code>methods方法</code>中不能使用<code>Vue.delete</code></p>\n<h4 id=\"vm-watch-expOrFn-callback-options-观察者模式\"><a href=\"#vm-watch-expOrFn-callback-options-观察者模式\" class=\"headerlink\" title=\"vm.$watch( expOrFn, callback, [options] ) 观察者模式\"></a>vm.$watch( expOrFn, callback, [options] ) 观察者模式</h4><p>参数：监听对象，回调方法，选项（deep/immediate）</p>\n<p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。<br>表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p>\n<p>实例使用方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式1：使用vue实例提供的$watch()方法</span><br><span class=\"line\">\t\tvm.$watch(&apos;name&apos;,function(newValue,oldValue)&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&apos;name被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue);</span><br><span class=\"line\">\t\t&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>vue提供的选项方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch:&#123; //方式2：使用vue实例提供的watch选项</span><br><span class=\"line\">\tage:(newValue,oldValue) =&gt; &#123;</span><br><span class=\"line\">\t\tconsole.log(&apos;age被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">    // 对对象监视，需要使用深度监视</span><br><span class=\"line\">\tuser:&#123;</span><br><span class=\"line\">\t\thandler:(newValue,oldValue) =&gt; &#123;</span><br><span class=\"line\">\t\tconsole.log(&apos;user被修改啦，原值：&apos;+oldValue.name+&apos;，新值：&apos;+newValue.name);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tdeep:true //深度监视，当对象中的属性发生变化时也会监视</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"vm-emit-event-…args-触发当前实例上的事件。附加参数都会传给监听器回调。\"><a href=\"#vm-emit-event-…args-触发当前实例上的事件。附加参数都会传给监听器回调。\" class=\"headerlink\" title=\"vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。\"></a>vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。</h4>"},{"title":"vue自定义指定","date":"2018-05-01T14:31:39.000Z","_content":"\n[TOC]\n\n# 自定义属性\n\n/**\n* 自定义全局指令\n* 注：使用指令时必须在指名名称前加前缀v-，即v-指令名称\n*/\n\n<!--more-->\n```\n\t\tVue.directive('hello',{\n\t\t\tbind(){ //常用！！\n\t\t\t\talert('指令第一次绑定到元素上时调用，只调用一次，可执行初始化操作');\n\t\t\t},\n\t\t\tinserted(){\n\t\t\t\talert('被绑定元素插入到DOM中时调用');\n\t\t\t},\n\t\t\tupdate(){\n\t\t\t\talert('被绑定元素所在模板更新时调用');\n\t\t\t},\n\t\t\tcomponentUpdated(){\n\t\t\t\talert('被绑定元素所在模板完成一次更新周期时调用');\n\t\t\t},\n\t\t\tunbind(){\n\t\t\t\talert('指令与元素解绑时调用，只调用一次');\n\t\t\t}\n\t\t});\n```\n\n\n\n#### 全局注册自定义指令\n\n```\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时调用\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n\n#### 局部注册\n\n```\ndirectives: {\n// 自定义指令名\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n\n#### 在模板中使用\n```\n<input v-focus>\n```\n\n## 钩子函数参数\n\n- 常用参数为`el`和`binding`\n\n钩子函数        参数1  参数2   参数3\nbind: function (el, binding, vnode)\n\n\n指令钩子函数会被传入以下参数：\n- el：指令所绑定的元素，可以用来直接操作 DOM 。可以为它绑定事件、也可以直接修改dom属性。\n- binding：一个对象。包含以下属性：\n    - name：指令名，不包括 v- 前缀。\n    - value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n    - oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n    - expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n    - arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n    - modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n- vnode：Vue 编译生成的虚拟节点。\n- oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n```\nVue.directive('demo', {// demo为指令名\n  bind: function (el, binding, vnode) {\n    \n  }\n})\n```","source":"_posts/vue自定义指定.md","raw":"---\ntitle: vue自定义指定\ndate: 2018-05-01 22:31:39\ncategories: vue\ntags:\n  - vue \n---\n\n[TOC]\n\n# 自定义属性\n\n/**\n* 自定义全局指令\n* 注：使用指令时必须在指名名称前加前缀v-，即v-指令名称\n*/\n\n<!--more-->\n```\n\t\tVue.directive('hello',{\n\t\t\tbind(){ //常用！！\n\t\t\t\talert('指令第一次绑定到元素上时调用，只调用一次，可执行初始化操作');\n\t\t\t},\n\t\t\tinserted(){\n\t\t\t\talert('被绑定元素插入到DOM中时调用');\n\t\t\t},\n\t\t\tupdate(){\n\t\t\t\talert('被绑定元素所在模板更新时调用');\n\t\t\t},\n\t\t\tcomponentUpdated(){\n\t\t\t\talert('被绑定元素所在模板完成一次更新周期时调用');\n\t\t\t},\n\t\t\tunbind(){\n\t\t\t\talert('指令与元素解绑时调用，只调用一次');\n\t\t\t}\n\t\t});\n```\n\n\n\n#### 全局注册自定义指令\n\n```\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时调用\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n\n#### 局部注册\n\n```\ndirectives: {\n// 自定义指令名\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n\n#### 在模板中使用\n```\n<input v-focus>\n```\n\n## 钩子函数参数\n\n- 常用参数为`el`和`binding`\n\n钩子函数        参数1  参数2   参数3\nbind: function (el, binding, vnode)\n\n\n指令钩子函数会被传入以下参数：\n- el：指令所绑定的元素，可以用来直接操作 DOM 。可以为它绑定事件、也可以直接修改dom属性。\n- binding：一个对象。包含以下属性：\n    - name：指令名，不包括 v- 前缀。\n    - value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n    - oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n    - expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n    - arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n    - modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n- vnode：Vue 编译生成的虚拟节点。\n- oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n```\nVue.directive('demo', {// demo为指令名\n  bind: function (el, binding, vnode) {\n    \n  }\n})\n```","slug":"vue自定义指定","published":1,"updated":"2019-06-16T08:32:57.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhfv001b9kud6de4vobx","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[TOC]</p>\n<h1 id=\"自定义属性\"><a href=\"#自定义属性\" class=\"headerlink\" title=\"自定义属性\"></a>自定义属性</h1><p>/**</p>\n<ul>\n<li>自定义全局指令</li>\n<li>注：使用指令时必须在指名名称前加前缀v-，即v-指令名称<br>*/</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(&apos;hello&apos;,&#123;</span><br><span class=\"line\">\tbind()&#123; //常用！！</span><br><span class=\"line\">\t\talert(&apos;指令第一次绑定到元素上时调用，只调用一次，可执行初始化操作&apos;);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tinserted()&#123;</span><br><span class=\"line\">\t\talert(&apos;被绑定元素插入到DOM中时调用&apos;);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tupdate()&#123;</span><br><span class=\"line\">\t\talert(&apos;被绑定元素所在模板更新时调用&apos;);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcomponentUpdated()&#123;</span><br><span class=\"line\">\t\talert(&apos;被绑定元素所在模板完成一次更新周期时调用&apos;);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tunbind()&#123;</span><br><span class=\"line\">\t\talert(&apos;指令与元素解绑时调用，只调用一次&apos;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"全局注册自定义指令\"><a href=\"#全局注册自定义指令\" class=\"headerlink\" title=\"全局注册自定义指令\"></a>全局注册自定义指令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注册一个全局自定义指令 `v-focus`</span><br><span class=\"line\">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class=\"line\">  // 当被绑定的元素插入到 DOM 中时调用</span><br><span class=\"line\">  inserted: function (el) &#123;</span><br><span class=\"line\">    // 聚焦元素</span><br><span class=\"line\">    el.focus()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">directives: &#123;</span><br><span class=\"line\">// 自定义指令名</span><br><span class=\"line\">  focus: &#123;</span><br><span class=\"line\">    // 指令的定义</span><br><span class=\"line\">    inserted: function (el) &#123;</span><br><span class=\"line\">      el.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在模板中使用\"><a href=\"#在模板中使用\" class=\"headerlink\" title=\"在模板中使用\"></a>在模板中使用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"钩子函数参数\"><a href=\"#钩子函数参数\" class=\"headerlink\" title=\"钩子函数参数\"></a>钩子函数参数</h2><ul>\n<li>常用参数为<code>el</code>和<code>binding</code></li>\n</ul>\n<p>钩子函数        参数1  参数2   参数3<br>bind: function (el, binding, vnode)</p>\n<p>指令钩子函数会被传入以下参数：</p>\n<ul>\n<li>el：指令所绑定的元素，可以用来直接操作 DOM 。可以为它绑定事件、也可以直接修改dom属性。</li>\n<li>binding：一个对象。包含以下属性：<ul>\n<li>name：指令名，不包括 v- 前缀。</li>\n<li>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li>\n<li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>\n<li>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li>\n<li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li>\n<li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li>\n</ul>\n</li>\n<li>vnode：Vue 编译生成的虚拟节点。</li>\n<li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(&apos;demo&apos;, &#123;// demo为指令名</span><br><span class=\"line\">  bind: function (el, binding, vnode) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>[TOC]</p>\n<h1 id=\"自定义属性\"><a href=\"#自定义属性\" class=\"headerlink\" title=\"自定义属性\"></a>自定义属性</h1><p>/**</p>\n<ul>\n<li>自定义全局指令</li>\n<li>注：使用指令时必须在指名名称前加前缀v-，即v-指令名称<br>*/</li>\n</ul>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(&apos;hello&apos;,&#123;</span><br><span class=\"line\">\tbind()&#123; //常用！！</span><br><span class=\"line\">\t\talert(&apos;指令第一次绑定到元素上时调用，只调用一次，可执行初始化操作&apos;);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tinserted()&#123;</span><br><span class=\"line\">\t\talert(&apos;被绑定元素插入到DOM中时调用&apos;);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tupdate()&#123;</span><br><span class=\"line\">\t\talert(&apos;被绑定元素所在模板更新时调用&apos;);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tcomponentUpdated()&#123;</span><br><span class=\"line\">\t\talert(&apos;被绑定元素所在模板完成一次更新周期时调用&apos;);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tunbind()&#123;</span><br><span class=\"line\">\t\talert(&apos;指令与元素解绑时调用，只调用一次&apos;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"全局注册自定义指令\"><a href=\"#全局注册自定义指令\" class=\"headerlink\" title=\"全局注册自定义指令\"></a>全局注册自定义指令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 注册一个全局自定义指令 `v-focus`</span><br><span class=\"line\">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class=\"line\">  // 当被绑定的元素插入到 DOM 中时调用</span><br><span class=\"line\">  inserted: function (el) &#123;</span><br><span class=\"line\">    // 聚焦元素</span><br><span class=\"line\">    el.focus()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"局部注册\"><a href=\"#局部注册\" class=\"headerlink\" title=\"局部注册\"></a>局部注册</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">directives: &#123;</span><br><span class=\"line\">// 自定义指令名</span><br><span class=\"line\">  focus: &#123;</span><br><span class=\"line\">    // 指令的定义</span><br><span class=\"line\">    inserted: function (el) &#123;</span><br><span class=\"line\">      el.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在模板中使用\"><a href=\"#在模板中使用\" class=\"headerlink\" title=\"在模板中使用\"></a>在模板中使用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"钩子函数参数\"><a href=\"#钩子函数参数\" class=\"headerlink\" title=\"钩子函数参数\"></a>钩子函数参数</h2><ul>\n<li>常用参数为<code>el</code>和<code>binding</code></li>\n</ul>\n<p>钩子函数        参数1  参数2   参数3<br>bind: function (el, binding, vnode)</p>\n<p>指令钩子函数会被传入以下参数：</p>\n<ul>\n<li>el：指令所绑定的元素，可以用来直接操作 DOM 。可以为它绑定事件、也可以直接修改dom属性。</li>\n<li>binding：一个对象。包含以下属性：<ul>\n<li>name：指令名，不包括 v- 前缀。</li>\n<li>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li>\n<li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>\n<li>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li>\n<li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li>\n<li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li>\n</ul>\n</li>\n<li>vnode：Vue 编译生成的虚拟节点。</li>\n<li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(&apos;demo&apos;, &#123;// demo为指令名</span><br><span class=\"line\">  bind: function (el, binding, vnode) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"【HEXO】hexo部署到阿里云","date":"2020-05-05T13:02:54.000Z","_content":"\n从零搭建 Hexo 博客并部署阿里云服务器（奶妈级教学）\\_运维\\_Object 的博客-CSDN 博客 https://blog.csdn.net/NoCortY/article/details/99631249\n\n有一个修改文件权限的坑，不了解 linux，卡了几小时。\n\n如果遇到了，参考下面这篇文章，chmod 这一步改成 777 即可\n\nchmod 修改文件权限 777 和 754\\_运维\\_pythonw 的博客-CSDN 博客 https://blog.csdn.net/pythonw/article/details/80263428\n","source":"_posts/【HEXO】hexo部署到阿里云.md","raw":"---\ntitle: 【HEXO】hexo部署到阿里云\ndate: 2020-05-05 21:02:54\ntags:\n---\n\n从零搭建 Hexo 博客并部署阿里云服务器（奶妈级教学）\\_运维\\_Object 的博客-CSDN 博客 https://blog.csdn.net/NoCortY/article/details/99631249\n\n有一个修改文件权限的坑，不了解 linux，卡了几小时。\n\n如果遇到了，参考下面这篇文章，chmod 这一步改成 777 即可\n\nchmod 修改文件权限 777 和 754\\_运维\\_pythonw 的博客-CSDN 博客 https://blog.csdn.net/pythonw/article/details/80263428\n","slug":"【HEXO】hexo部署到阿里云","published":1,"updated":"2020-05-05T14:26:22.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhfx001d9kud9ulm6w4k","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>从零搭建 Hexo 博客并部署阿里云服务器（奶妈级教学）_运维_Object 的博客-CSDN 博客 <a href=\"https://blog.csdn.net/NoCortY/article/details/99631249\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/NoCortY/article/details/99631249</a></p>\n<p>有一个修改文件权限的坑，不了解 linux，卡了几小时。</p>\n<p>如果遇到了，参考下面这篇文章，chmod 这一步改成 777 即可</p>\n<p>chmod 修改文件权限 777 和 754_运维_pythonw 的博客-CSDN 博客 <a href=\"https://blog.csdn.net/pythonw/article/details/80263428\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pythonw/article/details/80263428</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>从零搭建 Hexo 博客并部署阿里云服务器（奶妈级教学）_运维_Object 的博客-CSDN 博客 <a href=\"https://blog.csdn.net/NoCortY/article/details/99631249\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/NoCortY/article/details/99631249</a></p>\n<p>有一个修改文件权限的坑，不了解 linux，卡了几小时。</p>\n<p>如果遇到了，参考下面这篇文章，chmod 这一步改成 777 即可</p>\n<p>chmod 修改文件权限 777 和 754_运维_pythonw 的博客-CSDN 博客 <a href=\"https://blog.csdn.net/pythonw/article/details/80263428\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pythonw/article/details/80263428</a></p>\n"},{"title":"【HTML】参考博客","date":"2020-05-05T13:10:39.000Z","_content":"\n[toc]\n\n## 一、 网页排版\n\n排版标签：\n\n- `<h1>`\n\n- `<p>`\n\n- `<hr />` 水平分割线标签\n\n- `<br />` 换行标签\n\n- `<div>`\n\n- `<span>`\n\n- `<pre>` 预定义标签：原样输出内容\n\n原文地址： [HTML 标签：排版标签](https://github.com/qianguyihao/Web/blob/master/01-HTML/04-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E6%8E%92%E7%89%88%E6%A0%87%E7%AD%BE.md)\n\n## 二、字体与锚点链接\n\n个人简要笔记：\n\n### 2-1.字体\n\n```\n// b s u i 都是已经废弃的，现在用左边更语义化的标签\nstrong == b // strong 粗体标签 语义: 定义重要性强调的文字\ndel == s // del 中划线/删除线 语义(deleted): 定义被删除的文字\nins == u // ins 下划线 语义(inseted): 定义插入的文字\nem == i // em 斜体 语义(emphasized): 定义强调的文字\n```\n\n### 2-2.锚点链接\n\n锚点链接即是通过给元素设置 id（设置标记），实现浏览器可以在链接访问网页的时候，在根据链接地址后面的`#id`参数，来自动定位到网页文档的对应位置。\n\n> 锚链接的作用是在本页面或者其他页面的的不同位置进行跳转。\n\n比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就可以利用锚链接。\n\n不过锚链接没有动画，是立即跳转到对应位置。所以实际使用中，往往需要依赖别人封装好的插件。\n\n例如`navScroll.ja`\n\n参考原文地址： [HTML 标签：字体标签和超链接](https://github.com/qianguyihao/Web/blob/master/01-HTML/05-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%AD%97%E4%BD%93%E6%A0%87%E7%AD%BE%E5%92%8C%E8%B6%85%E9%93%BE%E6%8E%A5.md)\n\n## 三、图片标签\n\n主要注意 align 属性\n\n图片的 align 属性：图片和周围文字的相对位置。\n\n属性取值可以是：bottom（默认）、center、top、left、right。\n\n如果想实现图文混排的效果，请使用 align 属性，取值为 left 或 right。\n\n我们来分别看一下这 align 属性的这几个属性值的区别。\n\n1、align=\"\"，图片和文字低端对齐。即默认情况下的显示效果\n\n2、align=\"center\"：图片和文字水平方向上居中对齐。 3、align=\"top\"：图片与文字顶端对齐。\n\n4、align=\"left\"：图片在文字的左边。\n\n5、align=\"right\"：图片在文字的右边。\n\n原文地址： [HTML 标签：图片标签](https://github.com/qianguyihao/Web/blob/master/01-HTML/06-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE.md)\n","source":"_posts/【HTML】参考博客.md","raw":"---\ntitle: 【HTML】参考博客\ndate: 2020-05-05 21:10:39\ntags:\n  - html\n  - 网页排版\n  - 他人博客\n---\n\n[toc]\n\n## 一、 网页排版\n\n排版标签：\n\n- `<h1>`\n\n- `<p>`\n\n- `<hr />` 水平分割线标签\n\n- `<br />` 换行标签\n\n- `<div>`\n\n- `<span>`\n\n- `<pre>` 预定义标签：原样输出内容\n\n原文地址： [HTML 标签：排版标签](https://github.com/qianguyihao/Web/blob/master/01-HTML/04-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E6%8E%92%E7%89%88%E6%A0%87%E7%AD%BE.md)\n\n## 二、字体与锚点链接\n\n个人简要笔记：\n\n### 2-1.字体\n\n```\n// b s u i 都是已经废弃的，现在用左边更语义化的标签\nstrong == b // strong 粗体标签 语义: 定义重要性强调的文字\ndel == s // del 中划线/删除线 语义(deleted): 定义被删除的文字\nins == u // ins 下划线 语义(inseted): 定义插入的文字\nem == i // em 斜体 语义(emphasized): 定义强调的文字\n```\n\n### 2-2.锚点链接\n\n锚点链接即是通过给元素设置 id（设置标记），实现浏览器可以在链接访问网页的时候，在根据链接地址后面的`#id`参数，来自动定位到网页文档的对应位置。\n\n> 锚链接的作用是在本页面或者其他页面的的不同位置进行跳转。\n\n比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就可以利用锚链接。\n\n不过锚链接没有动画，是立即跳转到对应位置。所以实际使用中，往往需要依赖别人封装好的插件。\n\n例如`navScroll.ja`\n\n参考原文地址： [HTML 标签：字体标签和超链接](https://github.com/qianguyihao/Web/blob/master/01-HTML/05-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%AD%97%E4%BD%93%E6%A0%87%E7%AD%BE%E5%92%8C%E8%B6%85%E9%93%BE%E6%8E%A5.md)\n\n## 三、图片标签\n\n主要注意 align 属性\n\n图片的 align 属性：图片和周围文字的相对位置。\n\n属性取值可以是：bottom（默认）、center、top、left、right。\n\n如果想实现图文混排的效果，请使用 align 属性，取值为 left 或 right。\n\n我们来分别看一下这 align 属性的这几个属性值的区别。\n\n1、align=\"\"，图片和文字低端对齐。即默认情况下的显示效果\n\n2、align=\"center\"：图片和文字水平方向上居中对齐。 3、align=\"top\"：图片与文字顶端对齐。\n\n4、align=\"left\"：图片在文字的左边。\n\n5、align=\"right\"：图片在文字的右边。\n\n原文地址： [HTML 标签：图片标签](https://github.com/qianguyihao/Web/blob/master/01-HTML/06-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE.md)\n","slug":"【HTML】参考博客","published":1,"updated":"2020-05-05T13:52:38.838Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhg0001h9kud8ha2ls3k","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h2 id=\"一、-网页排版\"><a href=\"#一、-网页排版\" class=\"headerlink\" title=\"一、 网页排版\"></a>一、 网页排版</h2><p>排版标签：</p>\n<ul>\n<li><p><code>&lt;h1&gt;</code></p>\n</li>\n<li><p><code>&lt;p&gt;</code></p>\n</li>\n<li><p><code>&lt;hr /&gt;</code> 水平分割线标签</p>\n</li>\n<li><p><code>&lt;br /&gt;</code> 换行标签</p>\n</li>\n<li><p><code>&lt;div&gt;</code></p>\n</li>\n<li><p><code>&lt;span&gt;</code></p>\n</li>\n<li><p><code>&lt;pre&gt;</code> 预定义标签：原样输出内容</p>\n</li>\n</ul>\n<p>原文地址： <a href=\"https://github.com/qianguyihao/Web/blob/master/01-HTML/04-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E6%8E%92%E7%89%88%E6%A0%87%E7%AD%BE.md\" target=\"_blank\" rel=\"noopener\">HTML 标签：排版标签</a></p>\n<h2 id=\"二、字体与锚点链接\"><a href=\"#二、字体与锚点链接\" class=\"headerlink\" title=\"二、字体与锚点链接\"></a>二、字体与锚点链接</h2><p>个人简要笔记：</p>\n<h3 id=\"2-1-字体\"><a href=\"#2-1-字体\" class=\"headerlink\" title=\"2-1.字体\"></a>2-1.字体</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b s u i 都是已经废弃的，现在用左边更语义化的标签</span><br><span class=\"line\">strong == b // strong 粗体标签 语义: 定义重要性强调的文字</span><br><span class=\"line\">del == s // del 中划线/删除线 语义(deleted): 定义被删除的文字</span><br><span class=\"line\">ins == u // ins 下划线 语义(inseted): 定义插入的文字</span><br><span class=\"line\">em == i // em 斜体 语义(emphasized): 定义强调的文字</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-锚点链接\"><a href=\"#2-2-锚点链接\" class=\"headerlink\" title=\"2-2.锚点链接\"></a>2-2.锚点链接</h3><p>锚点链接即是通过给元素设置 id（设置标记），实现浏览器可以在链接访问网页的时候，在根据链接地址后面的<code>#id</code>参数，来自动定位到网页文档的对应位置。</p>\n<blockquote>\n<p>锚链接的作用是在本页面或者其他页面的的不同位置进行跳转。</p>\n</blockquote>\n<p>比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就可以利用锚链接。</p>\n<p>不过锚链接没有动画，是立即跳转到对应位置。所以实际使用中，往往需要依赖别人封装好的插件。</p>\n<p>例如<code>navScroll.ja</code></p>\n<p>参考原文地址： <a href=\"https://github.com/qianguyihao/Web/blob/master/01-HTML/05-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%AD%97%E4%BD%93%E6%A0%87%E7%AD%BE%E5%92%8C%E8%B6%85%E9%93%BE%E6%8E%A5.md\" target=\"_blank\" rel=\"noopener\">HTML 标签：字体标签和超链接</a></p>\n<h2 id=\"三、图片标签\"><a href=\"#三、图片标签\" class=\"headerlink\" title=\"三、图片标签\"></a>三、图片标签</h2><p>主要注意 align 属性</p>\n<p>图片的 align 属性：图片和周围文字的相对位置。</p>\n<p>属性取值可以是：bottom（默认）、center、top、left、right。</p>\n<p>如果想实现图文混排的效果，请使用 align 属性，取值为 left 或 right。</p>\n<p>我们来分别看一下这 align 属性的这几个属性值的区别。</p>\n<p>1、align=””，图片和文字低端对齐。即默认情况下的显示效果</p>\n<p>2、align=”center”：图片和文字水平方向上居中对齐。 3、align=”top”：图片与文字顶端对齐。</p>\n<p>4、align=”left”：图片在文字的左边。</p>\n<p>5、align=”right”：图片在文字的右边。</p>\n<p>原文地址： <a href=\"https://github.com/qianguyihao/Web/blob/master/01-HTML/06-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE.md\" target=\"_blank\" rel=\"noopener\">HTML 标签：图片标签</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h2 id=\"一、-网页排版\"><a href=\"#一、-网页排版\" class=\"headerlink\" title=\"一、 网页排版\"></a>一、 网页排版</h2><p>排版标签：</p>\n<ul>\n<li><p><code>&lt;h1&gt;</code></p>\n</li>\n<li><p><code>&lt;p&gt;</code></p>\n</li>\n<li><p><code>&lt;hr /&gt;</code> 水平分割线标签</p>\n</li>\n<li><p><code>&lt;br /&gt;</code> 换行标签</p>\n</li>\n<li><p><code>&lt;div&gt;</code></p>\n</li>\n<li><p><code>&lt;span&gt;</code></p>\n</li>\n<li><p><code>&lt;pre&gt;</code> 预定义标签：原样输出内容</p>\n</li>\n</ul>\n<p>原文地址： <a href=\"https://github.com/qianguyihao/Web/blob/master/01-HTML/04-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E6%8E%92%E7%89%88%E6%A0%87%E7%AD%BE.md\" target=\"_blank\" rel=\"noopener\">HTML 标签：排版标签</a></p>\n<h2 id=\"二、字体与锚点链接\"><a href=\"#二、字体与锚点链接\" class=\"headerlink\" title=\"二、字体与锚点链接\"></a>二、字体与锚点链接</h2><p>个人简要笔记：</p>\n<h3 id=\"2-1-字体\"><a href=\"#2-1-字体\" class=\"headerlink\" title=\"2-1.字体\"></a>2-1.字体</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// b s u i 都是已经废弃的，现在用左边更语义化的标签</span><br><span class=\"line\">strong == b // strong 粗体标签 语义: 定义重要性强调的文字</span><br><span class=\"line\">del == s // del 中划线/删除线 语义(deleted): 定义被删除的文字</span><br><span class=\"line\">ins == u // ins 下划线 语义(inseted): 定义插入的文字</span><br><span class=\"line\">em == i // em 斜体 语义(emphasized): 定义强调的文字</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-锚点链接\"><a href=\"#2-2-锚点链接\" class=\"headerlink\" title=\"2-2.锚点链接\"></a>2-2.锚点链接</h3><p>锚点链接即是通过给元素设置 id（设置标记），实现浏览器可以在链接访问网页的时候，在根据链接地址后面的<code>#id</code>参数，来自动定位到网页文档的对应位置。</p>\n<blockquote>\n<p>锚链接的作用是在本页面或者其他页面的的不同位置进行跳转。</p>\n</blockquote>\n<p>比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就可以利用锚链接。</p>\n<p>不过锚链接没有动画，是立即跳转到对应位置。所以实际使用中，往往需要依赖别人封装好的插件。</p>\n<p>例如<code>navScroll.ja</code></p>\n<p>参考原文地址： <a href=\"https://github.com/qianguyihao/Web/blob/master/01-HTML/05-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%AD%97%E4%BD%93%E6%A0%87%E7%AD%BE%E5%92%8C%E8%B6%85%E9%93%BE%E6%8E%A5.md\" target=\"_blank\" rel=\"noopener\">HTML 标签：字体标签和超链接</a></p>\n<h2 id=\"三、图片标签\"><a href=\"#三、图片标签\" class=\"headerlink\" title=\"三、图片标签\"></a>三、图片标签</h2><p>主要注意 align 属性</p>\n<p>图片的 align 属性：图片和周围文字的相对位置。</p>\n<p>属性取值可以是：bottom（默认）、center、top、left、right。</p>\n<p>如果想实现图文混排的效果，请使用 align 属性，取值为 left 或 right。</p>\n<p>我们来分别看一下这 align 属性的这几个属性值的区别。</p>\n<p>1、align=””，图片和文字低端对齐。即默认情况下的显示效果</p>\n<p>2、align=”center”：图片和文字水平方向上居中对齐。 3、align=”top”：图片与文字顶端对齐。</p>\n<p>4、align=”left”：图片在文字的左边。</p>\n<p>5、align=”right”：图片在文字的右边。</p>\n<p>原文地址： <a href=\"https://github.com/qianguyihao/Web/blob/master/01-HTML/06-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE.md\" target=\"_blank\" rel=\"noopener\">HTML 标签：图片标签</a></p>\n"},{"title":"【HTTPS】记一次阿里云配置https","date":"2020-05-05T13:02:03.000Z","_content":"\n[TOC]\n\n给阿里云配置 https 很简单，只需要申请证书、然后安装到云服务器内的 web 服务器中，配置一下即可。\n\n阿里云有官方案例，这里选择 nginx\n\nhttps://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO\n\n## nginx 安装步骤\n\n我的 nginx 是使用 yum 安装的，所以安装目录在`/etc/nginx`\n\n> yum install -y nginx\n\n强烈推荐使用这种方式安装，非常方便\n\n### 第一步：上传密钥到 nginx 目录下\n\n在 nginx 目录下运行\n\n> mkdir cert\n\n创建密钥文件夹，把密钥文件都上传到该文件夹下。\n\n### 第二步：配置 nginx\n\n我们使用 nginx 不应该任何时候都直接改动 `nginx.conf`，这里我有一个`vhost/blog.conf`的文件夹，里面配置了一个代理的网站。参考配置\n\n```nginx\nserver {\n  listen 80;\n  root /home/www/blog-website;\n  server_name www.lzwlook.fun lzwlook.fun;\n  rewrite ^/(.*)$ https://www.lzwlook.fun/$1 permanent;\n  location / {\n  }\n}\nserver {\n  listen 443 ssl;\n  root /home/www/blog-website;\n  server_name www.lzwlook.fun lzwlook.fun;\n\n  ssl_certificate /etc/nginx/cert/3847437_www.lzwlook.fun.pem;\n  ssl_certificate_key /etc/nginx/cert/3847437_www.lzwlook.fun.key;\n  ssl_session_cache shared:SSL:1m;\n  ssl_session_timeout  10m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   #使用该协议进行配置。\n  ssl_prefer_server_ciphers on;\n  location / {\n  }\n}\n```\n\n### 三、重启 nginx\n\n```\nnginx -s reload\n```\n\n### 补充：使用 include 管理项目\n\n目前对于 nginx 不够了解，仅仅是文抄公。\n\n这里再补一下，创建 vhost 文件夹后，nginx 中怎么生效。\n\n我们还需要在 nginx.conf 中通过`include`，进行引入\n\n```nginx\nhttp {\n    include /etc/nginx/conf.d/*.conf; # 这个是自带的\n    include /etc/nginx/vhost/*.conf; # 这是我们的配置\n}\n```\n\n在 nginx.conf 文件中使用 include 引入文件夹和配置，会让项目的管理方便很多，这样只要给每个新增项目建一个 `\\*\\*.conf` 文件就好了。\n","source":"_posts/【HTTPS】阿里云配置https.md","raw":"---\ntitle: 【HTTPS】记一次阿里云配置https\ndate: 2020-05-05 21:02:03\ncategories:\n  - 云服务器\ntags:\n  - https\n  - nginx\n---\n\n[TOC]\n\n给阿里云配置 https 很简单，只需要申请证书、然后安装到云服务器内的 web 服务器中，配置一下即可。\n\n阿里云有官方案例，这里选择 nginx\n\nhttps://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO\n\n## nginx 安装步骤\n\n我的 nginx 是使用 yum 安装的，所以安装目录在`/etc/nginx`\n\n> yum install -y nginx\n\n强烈推荐使用这种方式安装，非常方便\n\n### 第一步：上传密钥到 nginx 目录下\n\n在 nginx 目录下运行\n\n> mkdir cert\n\n创建密钥文件夹，把密钥文件都上传到该文件夹下。\n\n### 第二步：配置 nginx\n\n我们使用 nginx 不应该任何时候都直接改动 `nginx.conf`，这里我有一个`vhost/blog.conf`的文件夹，里面配置了一个代理的网站。参考配置\n\n```nginx\nserver {\n  listen 80;\n  root /home/www/blog-website;\n  server_name www.lzwlook.fun lzwlook.fun;\n  rewrite ^/(.*)$ https://www.lzwlook.fun/$1 permanent;\n  location / {\n  }\n}\nserver {\n  listen 443 ssl;\n  root /home/www/blog-website;\n  server_name www.lzwlook.fun lzwlook.fun;\n\n  ssl_certificate /etc/nginx/cert/3847437_www.lzwlook.fun.pem;\n  ssl_certificate_key /etc/nginx/cert/3847437_www.lzwlook.fun.key;\n  ssl_session_cache shared:SSL:1m;\n  ssl_session_timeout  10m;\n  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。\n  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   #使用该协议进行配置。\n  ssl_prefer_server_ciphers on;\n  location / {\n  }\n}\n```\n\n### 三、重启 nginx\n\n```\nnginx -s reload\n```\n\n### 补充：使用 include 管理项目\n\n目前对于 nginx 不够了解，仅仅是文抄公。\n\n这里再补一下，创建 vhost 文件夹后，nginx 中怎么生效。\n\n我们还需要在 nginx.conf 中通过`include`，进行引入\n\n```nginx\nhttp {\n    include /etc/nginx/conf.d/*.conf; # 这个是自带的\n    include /etc/nginx/vhost/*.conf; # 这是我们的配置\n}\n```\n\n在 nginx.conf 文件中使用 include 引入文件夹和配置，会让项目的管理方便很多，这样只要给每个新增项目建一个 `\\*\\*.conf` 文件就好了。\n","slug":"【HTTPS】阿里云配置https","published":1,"updated":"2020-05-05T14:20:00.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhg2001j9kudkl9h5xl8","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[TOC]</p>\n<p>给阿里云配置 https 很简单，只需要申请证书、然后安装到云服务器内的 web 服务器中，配置一下即可。</p>\n<p>阿里云有官方案例，这里选择 nginx</p>\n<p><a href=\"https://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO\" target=\"_blank\" rel=\"noopener\">https://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO</a></p>\n<h2 id=\"nginx-安装步骤\"><a href=\"#nginx-安装步骤\" class=\"headerlink\" title=\"nginx 安装步骤\"></a>nginx 安装步骤</h2><p>我的 nginx 是使用 yum 安装的，所以安装目录在<code>/etc/nginx</code></p>\n<blockquote>\n<p>yum install -y nginx</p>\n</blockquote>\n<p>强烈推荐使用这种方式安装，非常方便</p>\n<h3 id=\"第一步：上传密钥到-nginx-目录下\"><a href=\"#第一步：上传密钥到-nginx-目录下\" class=\"headerlink\" title=\"第一步：上传密钥到 nginx 目录下\"></a>第一步：上传密钥到 nginx 目录下</h3><p>在 nginx 目录下运行</p>\n<blockquote>\n<p>mkdir cert</p>\n</blockquote>\n<p>创建密钥文件夹，把密钥文件都上传到该文件夹下。</p>\n<h3 id=\"第二步：配置-nginx\"><a href=\"#第二步：配置-nginx\" class=\"headerlink\" title=\"第二步：配置 nginx\"></a>第二步：配置 nginx</h3><p>我们使用 nginx 不应该任何时候都直接改动 <code>nginx.conf</code>，这里我有一个<code>vhost/blog.conf</code>的文件夹，里面配置了一个代理的网站。参考配置</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">root</span> /home/www/blog-website;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> www.lzwlook.fun lzwlook.fun;</span><br><span class=\"line\">  <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/(.*)$</span> https://www.lzwlook.fun/<span class=\"variable\">$1</span> <span class=\"literal\">permanent</span>;</span><br><span class=\"line\">  <span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">  <span class=\"attribute\">root</span> /home/www/blog-website;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> www.lzwlook.fun lzwlook.fun;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attribute\">ssl_certificate</span> /etc/nginx/cert/3847437_www.lzwlook.fun.pem;</span><br><span class=\"line\">  <span class=\"attribute\">ssl_certificate_key</span> /etc/nginx/cert/3847437_www.lzwlook.fun.key;</span><br><span class=\"line\">  <span class=\"attribute\">ssl_session_cache</span> shared:SSL:<span class=\"number\">1m</span>;</span><br><span class=\"line\">  <span class=\"attribute\">ssl_session_timeout</span>  <span class=\"number\">10m</span>;</span><br><span class=\"line\">  <span class=\"attribute\">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  <span class=\"comment\">#使用此加密套件。</span></span><br><span class=\"line\">  <span class=\"attribute\">ssl_protocols</span> TLSv1 TLSv1.<span class=\"number\">1</span> TLSv1.<span class=\"number\">2</span>;   <span class=\"comment\">#使用该协议进行配置。</span></span><br><span class=\"line\">  <span class=\"attribute\">ssl_prefer_server_ciphers</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">  <span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、重启-nginx\"><a href=\"#三、重启-nginx\" class=\"headerlink\" title=\"三、重启 nginx\"></a>三、重启 nginx</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充：使用-include-管理项目\"><a href=\"#补充：使用-include-管理项目\" class=\"headerlink\" title=\"补充：使用 include 管理项目\"></a>补充：使用 include 管理项目</h3><p>目前对于 nginx 不够了解，仅仅是文抄公。</p>\n<p>这里再补一下，创建 vhost 文件夹后，nginx 中怎么生效。</p>\n<p>我们还需要在 nginx.conf 中通过<code>include</code>，进行引入</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">include</span> /etc/nginx/conf.d/<span class=\"regexp\">*.conf</span>; <span class=\"comment\"># 这个是自带的</span></span><br><span class=\"line\">    <span class=\"attribute\">include</span> /etc/nginx/vhost/<span class=\"regexp\">*.conf</span>; <span class=\"comment\"># 这是我们的配置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 nginx.conf 文件中使用 include 引入文件夹和配置，会让项目的管理方便很多，这样只要给每个新增项目建一个 <code>\\*\\*.conf</code> 文件就好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<p>给阿里云配置 https 很简单，只需要申请证书、然后安装到云服务器内的 web 服务器中，配置一下即可。</p>\n<p>阿里云有官方案例，这里选择 nginx</p>\n<p><a href=\"https://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO\" target=\"_blank\" rel=\"noopener\">https://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO</a></p>\n<h2 id=\"nginx-安装步骤\"><a href=\"#nginx-安装步骤\" class=\"headerlink\" title=\"nginx 安装步骤\"></a>nginx 安装步骤</h2><p>我的 nginx 是使用 yum 安装的，所以安装目录在<code>/etc/nginx</code></p>\n<blockquote>\n<p>yum install -y nginx</p>\n</blockquote>\n<p>强烈推荐使用这种方式安装，非常方便</p>\n<h3 id=\"第一步：上传密钥到-nginx-目录下\"><a href=\"#第一步：上传密钥到-nginx-目录下\" class=\"headerlink\" title=\"第一步：上传密钥到 nginx 目录下\"></a>第一步：上传密钥到 nginx 目录下</h3><p>在 nginx 目录下运行</p>\n<blockquote>\n<p>mkdir cert</p>\n</blockquote>\n<p>创建密钥文件夹，把密钥文件都上传到该文件夹下。</p>\n<h3 id=\"第二步：配置-nginx\"><a href=\"#第二步：配置-nginx\" class=\"headerlink\" title=\"第二步：配置 nginx\"></a>第二步：配置 nginx</h3><p>我们使用 nginx 不应该任何时候都直接改动 <code>nginx.conf</code>，这里我有一个<code>vhost/blog.conf</code>的文件夹，里面配置了一个代理的网站。参考配置</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">root</span> /home/www/blog-website;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> www.lzwlook.fun lzwlook.fun;</span><br><span class=\"line\">  <span class=\"attribute\">rewrite</span><span class=\"regexp\"> ^/(.*)$</span> https://www.lzwlook.fun/<span class=\"variable\">$1</span> <span class=\"literal\">permanent</span>;</span><br><span class=\"line\">  <span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span> <span class=\"number\">443</span> ssl;</span><br><span class=\"line\">  <span class=\"attribute\">root</span> /home/www/blog-website;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> www.lzwlook.fun lzwlook.fun;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attribute\">ssl_certificate</span> /etc/nginx/cert/3847437_www.lzwlook.fun.pem;</span><br><span class=\"line\">  <span class=\"attribute\">ssl_certificate_key</span> /etc/nginx/cert/3847437_www.lzwlook.fun.key;</span><br><span class=\"line\">  <span class=\"attribute\">ssl_session_cache</span> shared:SSL:<span class=\"number\">1m</span>;</span><br><span class=\"line\">  <span class=\"attribute\">ssl_session_timeout</span>  <span class=\"number\">10m</span>;</span><br><span class=\"line\">  <span class=\"attribute\">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  <span class=\"comment\">#使用此加密套件。</span></span><br><span class=\"line\">  <span class=\"attribute\">ssl_protocols</span> TLSv1 TLSv1.<span class=\"number\">1</span> TLSv1.<span class=\"number\">2</span>;   <span class=\"comment\">#使用该协议进行配置。</span></span><br><span class=\"line\">  <span class=\"attribute\">ssl_prefer_server_ciphers</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">  <span class=\"attribute\">location</span> / &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、重启-nginx\"><a href=\"#三、重启-nginx\" class=\"headerlink\" title=\"三、重启 nginx\"></a>三、重启 nginx</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>\n<h3 id=\"补充：使用-include-管理项目\"><a href=\"#补充：使用-include-管理项目\" class=\"headerlink\" title=\"补充：使用 include 管理项目\"></a>补充：使用 include 管理项目</h3><p>目前对于 nginx 不够了解，仅仅是文抄公。</p>\n<p>这里再补一下，创建 vhost 文件夹后，nginx 中怎么生效。</p>\n<p>我们还需要在 nginx.conf 中通过<code>include</code>，进行引入</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">include</span> /etc/nginx/conf.d/<span class=\"regexp\">*.conf</span>; <span class=\"comment\"># 这个是自带的</span></span><br><span class=\"line\">    <span class=\"attribute\">include</span> /etc/nginx/vhost/<span class=\"regexp\">*.conf</span>; <span class=\"comment\"># 这是我们的配置</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 nginx.conf 文件中使用 include 引入文件夹和配置，会让项目的管理方便很多，这样只要给每个新增项目建一个 <code>\\*\\*.conf</code> 文件就好了。</p>\n"},{"title":"函数内部的特殊对象","date":"2018-04-28T16:28:25.000Z","_content":"","source":"_posts/函数内部的特殊对象.md","raw":"---\ntitle: 函数内部的特殊对象\ndate: 2018-04-29 00:28:25\ntags:\n---\n","slug":"函数内部的特殊对象","published":1,"updated":"2019-04-07T14:56:55.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhg5001n9kudmeacirr1","content":"<script src=\"/assets/js/APlayer.min.js\"> </script>","site":{"data":{}},"excerpt":"","more":""},{"title":"基本包装类型","date":"2018-04-30T10:16:23.000Z","_content":"\n## 基本包装类型\n\n为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：Boolean、Number 和 String。\n实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。\n来看下面的例子。\n\n<!-- more -->\n\n```\nvar s1 = \"some text\";\nvar s2 = s1.substring(2);\n```\n这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。\n而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。\n我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。\n\n<!-- more -->\n\n其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。\n当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。\n而在读取模式中访问字符串时，后台都会自动完成下列处理。\n\n1. 创建 String 类型的一个实例；\n2. 在实例上调用指定的方法；\n3. 销毁这个实例。\n4. 可以将以上三个步骤想象成是执行了下列 JavaScript 代码。\n\n```\nvar s1 = new String(\"some text\");\nvar s2 = s1.substring(2);\ns1 = null;\n```\n\n经过此番处理，基本的字符串值就变得跟对象一样了。\n而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。\n\n- 引用类型与基本包装类型的主要区别就是对象的生存期。\n\n使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。\n而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。\n\n（使用 new 操作符创建的String引用类型的实例，优于自动创建的基本包装类型）\n\n这意味着我们不能在运行时为基本类型值添加属性和方法。\n\n----\n\n以下为简略概括，关于基本包装类型\n\n## Boolean类型\n任何时候，我们都不建议直接实例化Boolean类型。\n它虽然是与布尔值对应的引用类型，但是他无法用作布尔值判断，意义不明。\n\n## Number类型\n大多数时候，我们不建议直接实例化Number类型，原因和Boolean类型一样，影响类型判断。\nNumber类型是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。\n\n例子：var numberObject = new Number(10)  // 十进制\n\n关于Number类型，我们可以进行数制转换、字符转换。\n\n但一般不建议使用，我们应该尽量使用Number对象及其方法。（需要用到时，百度即可）\n（Number类型和Number对象是不一样的，Number对象是基本类型的实例）\n（Number类型是与`数字值`对应的引用类型，它只是基本类型的数值的实例。）\n\n## String类型\n\nString 类型是字符串的`对象包装类型`，可以像下面这样使用 String 构造函数来创建。\n\n>var stringObject = new String(\"hello world\");\n\nString 对象的方法也可以在所有基本的字符串值中访问到。\n其中，继承的 valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。\n\n>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。\n\n来看下面的例子。\n```\nvar stringValue = \"hello world\";\nconsole.log(stringValue.length);     // 11\n```\n应该注意的是，即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。\n例如：\n\n```\nvar stringValue = \"大家好\";\nconsole.log(stringValue.length);     // 3\n```\n\nString 类型提供了很多方法，用于辅助完成对 JavaScript 中字符串的解析和操作。\n\n[方法](https://github.com/stone0090/javascript-lessons/tree/master/1.11-PrimitiveWrapperObjects)\n\n#### 字符方法\n\n##### 访问字符串中特定位置的字符：charAt() 和 charCodeAt()\n\n这两个方法都接收一个参数，即基于0的字符位置。\n\n```\nvar stringValue = \"hello world\";\nconsole.log(stringValue.charAt(1));  // \"e\"\n```\ncharAt(): 以单字符字符串的形式返回给定位置的那个字符\ncharCodeAt(): 返回字符编码\n\nECMAScript 5 还定义了另一个访问个别字符的方法。\n在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。\n```\nvar stringValue = \"hello world\";\nconsole.log(stringValue[1]);   // \"e\"\n```\n\n#### 字符串操作方法\n\n##### `concat()` 用于将一或多个字符串拼接起来\n\n```\nvar stringValue = \"hello \";\nvar result = stringValue.concat(\"world\", \"!\");\n\nconsole.log(result);        // \"hello world!\"\nconsole.log(stringValue);   // \"hello\"\n```\n\n\n基于子字符串创建新字符串的方法：slice()、substr() 和 substring()\nslice(start,end) 从已有的`数组`中返回选定的元素。\nsubstr(start,length) 在`字符串`中抽取从 start 下标开始的指定数目的字符。\nsubstring(start,stop) 提取`字符串`中介于两个指定下标之间的字符。\n\n#### 字符串位置方法\n\n从字符串中查找子字符串的方法：indexOf() 和 lastIndexOf()\n这两个方法都接收两个参数：要`查找的项`和（可选的）`查找起点位置的索引`\n\nindexOf() 返回某个指定的字符串值在字符串中首次出现的位置。\nlastIndexOf() 返回一个指定的字符串值最后出现的位置。\n\n前面学过，indexOf()查找时会判断是否全等，详情氪查看js循环的笔记。\n\n>它们在比较第一个参数与数组中的每一项时，会使用全等操作符；\n\n#### trim() 方法--清除前后空格\n\n这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。\n\n#### 字符串大小写转换方法\n\ntoLowerCase() 和 toUpperCase()\n\n小写和大写\n\n#### 字符串的模式匹配方法\n\n`replace()` 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n```\nvar str=\"a blue and a blue car\";\nvar n=str.replace(/blue/g,\"red\"); // a red and a red car\n```\n\n`split()` 用于把一个字符串分割成字符串数组。\n```\n\"2:3:4:5\".split(\":\")\t//将返回[\"2\", \"3\", \"4\", \"5\"]\n\"|a|b|c\".split(\"|\")\t    //将返回[\"\", \"a\", \"b\", \"c\"]\n```\n\n#### localeCompare() 方法--比较两个字符串\n\n#### fromCharCode() 方法--接收一或多个字符编码，然后将它们转换成一个字符串。\n","source":"_posts/基本包装类型.md","raw":"---\ntitle: 基本包装类型\ndate: 2018-04-30 18:16:23\ncategories:\n  - JS学习笔记\ntags:\n  - 基本包装类型 js\n---\n\n## 基本包装类型\n\n为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：Boolean、Number 和 String。\n实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。\n来看下面的例子。\n\n<!-- more -->\n\n```\nvar s1 = \"some text\";\nvar s2 = s1.substring(2);\n```\n这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。\n而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。\n我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。\n\n<!-- more -->\n\n其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。\n当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。\n而在读取模式中访问字符串时，后台都会自动完成下列处理。\n\n1. 创建 String 类型的一个实例；\n2. 在实例上调用指定的方法；\n3. 销毁这个实例。\n4. 可以将以上三个步骤想象成是执行了下列 JavaScript 代码。\n\n```\nvar s1 = new String(\"some text\");\nvar s2 = s1.substring(2);\ns1 = null;\n```\n\n经过此番处理，基本的字符串值就变得跟对象一样了。\n而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。\n\n- 引用类型与基本包装类型的主要区别就是对象的生存期。\n\n使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。\n而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。\n\n（使用 new 操作符创建的String引用类型的实例，优于自动创建的基本包装类型）\n\n这意味着我们不能在运行时为基本类型值添加属性和方法。\n\n----\n\n以下为简略概括，关于基本包装类型\n\n## Boolean类型\n任何时候，我们都不建议直接实例化Boolean类型。\n它虽然是与布尔值对应的引用类型，但是他无法用作布尔值判断，意义不明。\n\n## Number类型\n大多数时候，我们不建议直接实例化Number类型，原因和Boolean类型一样，影响类型判断。\nNumber类型是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。\n\n例子：var numberObject = new Number(10)  // 十进制\n\n关于Number类型，我们可以进行数制转换、字符转换。\n\n但一般不建议使用，我们应该尽量使用Number对象及其方法。（需要用到时，百度即可）\n（Number类型和Number对象是不一样的，Number对象是基本类型的实例）\n（Number类型是与`数字值`对应的引用类型，它只是基本类型的数值的实例。）\n\n## String类型\n\nString 类型是字符串的`对象包装类型`，可以像下面这样使用 String 构造函数来创建。\n\n>var stringObject = new String(\"hello world\");\n\nString 对象的方法也可以在所有基本的字符串值中访问到。\n其中，继承的 valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。\n\n>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。\n\n来看下面的例子。\n```\nvar stringValue = \"hello world\";\nconsole.log(stringValue.length);     // 11\n```\n应该注意的是，即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。\n例如：\n\n```\nvar stringValue = \"大家好\";\nconsole.log(stringValue.length);     // 3\n```\n\nString 类型提供了很多方法，用于辅助完成对 JavaScript 中字符串的解析和操作。\n\n[方法](https://github.com/stone0090/javascript-lessons/tree/master/1.11-PrimitiveWrapperObjects)\n\n#### 字符方法\n\n##### 访问字符串中特定位置的字符：charAt() 和 charCodeAt()\n\n这两个方法都接收一个参数，即基于0的字符位置。\n\n```\nvar stringValue = \"hello world\";\nconsole.log(stringValue.charAt(1));  // \"e\"\n```\ncharAt(): 以单字符字符串的形式返回给定位置的那个字符\ncharCodeAt(): 返回字符编码\n\nECMAScript 5 还定义了另一个访问个别字符的方法。\n在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。\n```\nvar stringValue = \"hello world\";\nconsole.log(stringValue[1]);   // \"e\"\n```\n\n#### 字符串操作方法\n\n##### `concat()` 用于将一或多个字符串拼接起来\n\n```\nvar stringValue = \"hello \";\nvar result = stringValue.concat(\"world\", \"!\");\n\nconsole.log(result);        // \"hello world!\"\nconsole.log(stringValue);   // \"hello\"\n```\n\n\n基于子字符串创建新字符串的方法：slice()、substr() 和 substring()\nslice(start,end) 从已有的`数组`中返回选定的元素。\nsubstr(start,length) 在`字符串`中抽取从 start 下标开始的指定数目的字符。\nsubstring(start,stop) 提取`字符串`中介于两个指定下标之间的字符。\n\n#### 字符串位置方法\n\n从字符串中查找子字符串的方法：indexOf() 和 lastIndexOf()\n这两个方法都接收两个参数：要`查找的项`和（可选的）`查找起点位置的索引`\n\nindexOf() 返回某个指定的字符串值在字符串中首次出现的位置。\nlastIndexOf() 返回一个指定的字符串值最后出现的位置。\n\n前面学过，indexOf()查找时会判断是否全等，详情氪查看js循环的笔记。\n\n>它们在比较第一个参数与数组中的每一项时，会使用全等操作符；\n\n#### trim() 方法--清除前后空格\n\n这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。\n\n#### 字符串大小写转换方法\n\ntoLowerCase() 和 toUpperCase()\n\n小写和大写\n\n#### 字符串的模式匹配方法\n\n`replace()` 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n```\nvar str=\"a blue and a blue car\";\nvar n=str.replace(/blue/g,\"red\"); // a red and a red car\n```\n\n`split()` 用于把一个字符串分割成字符串数组。\n```\n\"2:3:4:5\".split(\":\")\t//将返回[\"2\", \"3\", \"4\", \"5\"]\n\"|a|b|c\".split(\"|\")\t    //将返回[\"\", \"a\", \"b\", \"c\"]\n```\n\n#### localeCompare() 方法--比较两个字符串\n\n#### fromCharCode() 方法--接收一或多个字符编码，然后将它们转换成一个字符串。\n","slug":"基本包装类型","published":1,"updated":"2019-06-16T08:33:32.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhg7001p9kuds8gep29e","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h2 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h2><p>为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：Boolean、Number 和 String。<br>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。<br>来看下面的例子。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 = &quot;some text&quot;;</span><br><span class=\"line\">var s2 = s1.substring(2);</span><br></pre></td></tr></table></figure>\n<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。<br>而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。<br>我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。</p>\n<!-- more -->\n<p>其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。<br>当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。<br>而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>\n<ol>\n<li>创建 String 类型的一个实例；</li>\n<li>在实例上调用指定的方法；</li>\n<li>销毁这个实例。</li>\n<li>可以将以上三个步骤想象成是执行了下列 JavaScript 代码。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 = new String(&quot;some text&quot;);</span><br><span class=\"line\">var s2 = s1.substring(2);</span><br><span class=\"line\">s1 = null;</span><br></pre></td></tr></table></figure>\n<p>经过此番处理，基本的字符串值就变得跟对象一样了。<br>而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。</p>\n<ul>\n<li>引用类型与基本包装类型的主要区别就是对象的生存期。</li>\n</ul>\n<p>使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。<br>而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</p>\n<p>（使用 new 操作符创建的String引用类型的实例，优于自动创建的基本包装类型）</p>\n<p>这意味着我们不能在运行时为基本类型值添加属性和方法。</p>\n<hr>\n<p>以下为简略概括，关于基本包装类型</p>\n<h2 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h2><p>任何时候，我们都不建议直接实例化Boolean类型。<br>它虽然是与布尔值对应的引用类型，但是他无法用作布尔值判断，意义不明。</p>\n<h2 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h2><p>大多数时候，我们不建议直接实例化Number类型，原因和Boolean类型一样，影响类型判断。<br>Number类型是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。</p>\n<p>例子：var numberObject = new Number(10)  // 十进制</p>\n<p>关于Number类型，我们可以进行数制转换、字符转换。</p>\n<p>但一般不建议使用，我们应该尽量使用Number对象及其方法。（需要用到时，百度即可）<br>（Number类型和Number对象是不一样的，Number对象是基本类型的实例）<br>（Number类型是与<code>数字值</code>对应的引用类型，它只是基本类型的数值的实例。）</p>\n<h2 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h2><p>String 类型是字符串的<code>对象包装类型</code>，可以像下面这样使用 String 构造函数来创建。</p>\n<blockquote>\n<p>var stringObject = new String(“hello world”);</p>\n</blockquote>\n<p>String 对象的方法也可以在所有基本的字符串值中访问到。<br>其中，继承的 valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。</p>\n<blockquote>\n<p>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。</p>\n</blockquote>\n<p>来看下面的例子。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;hello world&quot;;</span><br><span class=\"line\">console.log(stringValue.length);     // 11</span><br></pre></td></tr></table></figure></p>\n<p>应该注意的是，即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;大家好&quot;;</span><br><span class=\"line\">console.log(stringValue.length);     // 3</span><br></pre></td></tr></table></figure>\n<p>String 类型提供了很多方法，用于辅助完成对 JavaScript 中字符串的解析和操作。</p>\n<p><a href=\"https://github.com/stone0090/javascript-lessons/tree/master/1.11-PrimitiveWrapperObjects\" target=\"_blank\" rel=\"noopener\">方法</a></p>\n<h4 id=\"字符方法\"><a href=\"#字符方法\" class=\"headerlink\" title=\"字符方法\"></a>字符方法</h4><h5 id=\"访问字符串中特定位置的字符：charAt-和-charCodeAt\"><a href=\"#访问字符串中特定位置的字符：charAt-和-charCodeAt\" class=\"headerlink\" title=\"访问字符串中特定位置的字符：charAt() 和 charCodeAt()\"></a>访问字符串中特定位置的字符：charAt() 和 charCodeAt()</h5><p>这两个方法都接收一个参数，即基于0的字符位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;hello world&quot;;</span><br><span class=\"line\">console.log(stringValue.charAt(1));  // &quot;e&quot;</span><br></pre></td></tr></table></figure>\n<p>charAt(): 以单字符字符串的形式返回给定位置的那个字符<br>charCodeAt(): 返回字符编码</p>\n<p>ECMAScript 5 还定义了另一个访问个别字符的方法。<br>在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;hello world&quot;;</span><br><span class=\"line\">console.log(stringValue[1]);   // &quot;e&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"字符串操作方法\"><a href=\"#字符串操作方法\" class=\"headerlink\" title=\"字符串操作方法\"></a>字符串操作方法</h4><h5 id=\"concat-用于将一或多个字符串拼接起来\"><a href=\"#concat-用于将一或多个字符串拼接起来\" class=\"headerlink\" title=\"concat() 用于将一或多个字符串拼接起来\"></a><code>concat()</code> 用于将一或多个字符串拼接起来</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;hello &quot;;</span><br><span class=\"line\">var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(result);        // &quot;hello world!&quot;</span><br><span class=\"line\">console.log(stringValue);   // &quot;hello&quot;</span><br></pre></td></tr></table></figure>\n<p>基于子字符串创建新字符串的方法：slice()、substr() 和 substring()<br>slice(start,end) 从已有的<code>数组</code>中返回选定的元素。<br>substr(start,length) 在<code>字符串</code>中抽取从 start 下标开始的指定数目的字符。<br>substring(start,stop) 提取<code>字符串</code>中介于两个指定下标之间的字符。</p>\n<h4 id=\"字符串位置方法\"><a href=\"#字符串位置方法\" class=\"headerlink\" title=\"字符串位置方法\"></a>字符串位置方法</h4><p>从字符串中查找子字符串的方法：indexOf() 和 lastIndexOf()<br>这两个方法都接收两个参数：要<code>查找的项</code>和（可选的）<code>查找起点位置的索引</code></p>\n<p>indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。<br>lastIndexOf() 返回一个指定的字符串值最后出现的位置。</p>\n<p>前面学过，indexOf()查找时会判断是否全等，详情氪查看js循环的笔记。</p>\n<blockquote>\n<p>它们在比较第一个参数与数组中的每一项时，会使用全等操作符；</p>\n</blockquote>\n<h4 id=\"trim-方法–清除前后空格\"><a href=\"#trim-方法–清除前后空格\" class=\"headerlink\" title=\"trim() 方法–清除前后空格\"></a>trim() 方法–清除前后空格</h4><p>这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>\n<h4 id=\"字符串大小写转换方法\"><a href=\"#字符串大小写转换方法\" class=\"headerlink\" title=\"字符串大小写转换方法\"></a>字符串大小写转换方法</h4><p>toLowerCase() 和 toUpperCase()</p>\n<p>小写和大写</p>\n<h4 id=\"字符串的模式匹配方法\"><a href=\"#字符串的模式匹配方法\" class=\"headerlink\" title=\"字符串的模式匹配方法\"></a>字符串的模式匹配方法</h4><p><code>replace()</code> 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;a blue and a blue car&quot;;</span><br><span class=\"line\">var n=str.replace(/blue/g,&quot;red&quot;); // a red and a red car</span><br></pre></td></tr></table></figure></p>\n<p><code>split()</code> 用于把一个字符串分割成字符串数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;2:3:4:5&quot;.split(&quot;:&quot;)\t//将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class=\"line\">&quot;|a|b|c&quot;.split(&quot;|&quot;)\t    //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"localeCompare-方法–比较两个字符串\"><a href=\"#localeCompare-方法–比较两个字符串\" class=\"headerlink\" title=\"localeCompare() 方法–比较两个字符串\"></a>localeCompare() 方法–比较两个字符串</h4><h4 id=\"fromCharCode-方法–接收一或多个字符编码，然后将它们转换成一个字符串。\"><a href=\"#fromCharCode-方法–接收一或多个字符编码，然后将它们转换成一个字符串。\" class=\"headerlink\" title=\"fromCharCode() 方法–接收一或多个字符编码，然后将它们转换成一个字符串。\"></a>fromCharCode() 方法–接收一或多个字符编码，然后将它们转换成一个字符串。</h4>","site":{"data":{}},"excerpt":"<h2 id=\"基本包装类型\"><a href=\"#基本包装类型\" class=\"headerlink\" title=\"基本包装类型\"></a>基本包装类型</h2><p>为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：Boolean、Number 和 String。<br>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。<br>来看下面的例子。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 = &quot;some text&quot;;</span><br><span class=\"line\">var s2 = s1.substring(2);</span><br></pre></td></tr></table></figure>\n<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。<br>而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。<br>我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。</p>\n<!-- more -->\n<p>其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。<br>当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。<br>而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>\n<ol>\n<li>创建 String 类型的一个实例；</li>\n<li>在实例上调用指定的方法；</li>\n<li>销毁这个实例。</li>\n<li>可以将以上三个步骤想象成是执行了下列 JavaScript 代码。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 = new String(&quot;some text&quot;);</span><br><span class=\"line\">var s2 = s1.substring(2);</span><br><span class=\"line\">s1 = null;</span><br></pre></td></tr></table></figure>\n<p>经过此番处理，基本的字符串值就变得跟对象一样了。<br>而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。</p>\n<ul>\n<li>引用类型与基本包装类型的主要区别就是对象的生存期。</li>\n</ul>\n<p>使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。<br>而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</p>\n<p>（使用 new 操作符创建的String引用类型的实例，优于自动创建的基本包装类型）</p>\n<p>这意味着我们不能在运行时为基本类型值添加属性和方法。</p>\n<hr>\n<p>以下为简略概括，关于基本包装类型</p>\n<h2 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h2><p>任何时候，我们都不建议直接实例化Boolean类型。<br>它虽然是与布尔值对应的引用类型，但是他无法用作布尔值判断，意义不明。</p>\n<h2 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h2><p>大多数时候，我们不建议直接实例化Number类型，原因和Boolean类型一样，影响类型判断。<br>Number类型是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。</p>\n<p>例子：var numberObject = new Number(10)  // 十进制</p>\n<p>关于Number类型，我们可以进行数制转换、字符转换。</p>\n<p>但一般不建议使用，我们应该尽量使用Number对象及其方法。（需要用到时，百度即可）<br>（Number类型和Number对象是不一样的，Number对象是基本类型的实例）<br>（Number类型是与<code>数字值</code>对应的引用类型，它只是基本类型的数值的实例。）</p>\n<h2 id=\"String类型\"><a href=\"#String类型\" class=\"headerlink\" title=\"String类型\"></a>String类型</h2><p>String 类型是字符串的<code>对象包装类型</code>，可以像下面这样使用 String 构造函数来创建。</p>\n<blockquote>\n<p>var stringObject = new String(“hello world”);</p>\n</blockquote>\n<p>String 对象的方法也可以在所有基本的字符串值中访问到。<br>其中，继承的 valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。</p>\n<blockquote>\n<p>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。</p>\n</blockquote>\n<p>来看下面的例子。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;hello world&quot;;</span><br><span class=\"line\">console.log(stringValue.length);     // 11</span><br></pre></td></tr></table></figure></p>\n<p>应该注意的是，即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;大家好&quot;;</span><br><span class=\"line\">console.log(stringValue.length);     // 3</span><br></pre></td></tr></table></figure>\n<p>String 类型提供了很多方法，用于辅助完成对 JavaScript 中字符串的解析和操作。</p>\n<p><a href=\"https://github.com/stone0090/javascript-lessons/tree/master/1.11-PrimitiveWrapperObjects\" target=\"_blank\" rel=\"noopener\">方法</a></p>\n<h4 id=\"字符方法\"><a href=\"#字符方法\" class=\"headerlink\" title=\"字符方法\"></a>字符方法</h4><h5 id=\"访问字符串中特定位置的字符：charAt-和-charCodeAt\"><a href=\"#访问字符串中特定位置的字符：charAt-和-charCodeAt\" class=\"headerlink\" title=\"访问字符串中特定位置的字符：charAt() 和 charCodeAt()\"></a>访问字符串中特定位置的字符：charAt() 和 charCodeAt()</h5><p>这两个方法都接收一个参数，即基于0的字符位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;hello world&quot;;</span><br><span class=\"line\">console.log(stringValue.charAt(1));  // &quot;e&quot;</span><br></pre></td></tr></table></figure>\n<p>charAt(): 以单字符字符串的形式返回给定位置的那个字符<br>charCodeAt(): 返回字符编码</p>\n<p>ECMAScript 5 还定义了另一个访问个别字符的方法。<br>在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;hello world&quot;;</span><br><span class=\"line\">console.log(stringValue[1]);   // &quot;e&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"字符串操作方法\"><a href=\"#字符串操作方法\" class=\"headerlink\" title=\"字符串操作方法\"></a>字符串操作方法</h4><h5 id=\"concat-用于将一或多个字符串拼接起来\"><a href=\"#concat-用于将一或多个字符串拼接起来\" class=\"headerlink\" title=\"concat() 用于将一或多个字符串拼接起来\"></a><code>concat()</code> 用于将一或多个字符串拼接起来</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var stringValue = &quot;hello &quot;;</span><br><span class=\"line\">var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(result);        // &quot;hello world!&quot;</span><br><span class=\"line\">console.log(stringValue);   // &quot;hello&quot;</span><br></pre></td></tr></table></figure>\n<p>基于子字符串创建新字符串的方法：slice()、substr() 和 substring()<br>slice(start,end) 从已有的<code>数组</code>中返回选定的元素。<br>substr(start,length) 在<code>字符串</code>中抽取从 start 下标开始的指定数目的字符。<br>substring(start,stop) 提取<code>字符串</code>中介于两个指定下标之间的字符。</p>\n<h4 id=\"字符串位置方法\"><a href=\"#字符串位置方法\" class=\"headerlink\" title=\"字符串位置方法\"></a>字符串位置方法</h4><p>从字符串中查找子字符串的方法：indexOf() 和 lastIndexOf()<br>这两个方法都接收两个参数：要<code>查找的项</code>和（可选的）<code>查找起点位置的索引</code></p>\n<p>indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。<br>lastIndexOf() 返回一个指定的字符串值最后出现的位置。</p>\n<p>前面学过，indexOf()查找时会判断是否全等，详情氪查看js循环的笔记。</p>\n<blockquote>\n<p>它们在比较第一个参数与数组中的每一项时，会使用全等操作符；</p>\n</blockquote>\n<h4 id=\"trim-方法–清除前后空格\"><a href=\"#trim-方法–清除前后空格\" class=\"headerlink\" title=\"trim() 方法–清除前后空格\"></a>trim() 方法–清除前后空格</h4><p>这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>\n<h4 id=\"字符串大小写转换方法\"><a href=\"#字符串大小写转换方法\" class=\"headerlink\" title=\"字符串大小写转换方法\"></a>字符串大小写转换方法</h4><p>toLowerCase() 和 toUpperCase()</p>\n<p>小写和大写</p>\n<h4 id=\"字符串的模式匹配方法\"><a href=\"#字符串的模式匹配方法\" class=\"headerlink\" title=\"字符串的模式匹配方法\"></a>字符串的模式匹配方法</h4><p><code>replace()</code> 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str=&quot;a blue and a blue car&quot;;</span><br><span class=\"line\">var n=str.replace(/blue/g,&quot;red&quot;); // a red and a red car</span><br></pre></td></tr></table></figure></p>\n<p><code>split()</code> 用于把一个字符串分割成字符串数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;2:3:4:5&quot;.split(&quot;:&quot;)\t//将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class=\"line\">&quot;|a|b|c&quot;.split(&quot;|&quot;)\t    //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"localeCompare-方法–比较两个字符串\"><a href=\"#localeCompare-方法–比较两个字符串\" class=\"headerlink\" title=\"localeCompare() 方法–比较两个字符串\"></a>localeCompare() 方法–比较两个字符串</h4><h4 id=\"fromCharCode-方法–接收一或多个字符编码，然后将它们转换成一个字符串。\"><a href=\"#fromCharCode-方法–接收一或多个字符编码，然后将它们转换成一个字符串。\" class=\"headerlink\" title=\"fromCharCode() 方法–接收一或多个字符编码，然后将它们转换成一个字符串。\"></a>fromCharCode() 方法–接收一或多个字符编码，然后将它们转换成一个字符串。</h4>"},{"title":"深入理解js对象排序-sort()","date":"2018-04-28T09:35:26.000Z","_content":"\n[toc]\n\n## 排序\n\n假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。\n\n我们可以使用`sort()`方法\n\n<!-- more -->\n\n### sort()\n\n`sort()` 方法用于`对数组的元素进行排序,并返回数组`。\n默认排序顺序是根据字符串Unicode码点。\n\n<!-- more -->\n\n语法：`arrayObject.sort(参数)`\n参数可选，用于规定排序顺序。必须是函数。\n\n注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序。\n准确的说：是按照字符编码的顺序进行排序。\n\n但要实现默认按字母顺序排序，必须先把数组的元素都转换成字符串。\n\n例1：我们将创建一个数组，并按字母顺序进行排序：\n```\n<script type=\"text/javascript\">\n\nvar arr = new Array(4)\narr[0] = \"G\"\narr[1] = \"J\"\narr[2] = \"T\"\narr[3] = \"A\"\n\ndocument.write(arr.sort())  //A G J T\n\n</script>\n```\n\n例2：我们将创建一个数组，并按字母顺序进行排序：\n\n```\n<script type=\"text/javascript\">\n\nvar arr = new Array(6)\narr[0] = \"10\"\narr[1] = \"5\"\narr[2] = \"40\"\narr[3] = \"25\"\narr[4] = \"1000\"\narr[5] = \"1\"\n\ndocument.write(arr.sort())  // 1 10 1000 25 40 5\n\n</script>\n```\n\n至此，我们了解了`sort()`在没有函数传参的情况下：\n#### 默认按照首字母A~Z、a~z排序，以及0~9排序。\n\n- 原理：真正的默认排序顺序是根据字符串Unicode码点。字符串根据ASCII码进行排序。\n\n----\n\n我们注意到，上面的代码没有按照数值的大小对数字进行排序\n要实现这一点，就必须使用一个排序函数。\n\n#### ① 函数传参（a-b）-升序、降序排序\n\n```\n<script type=\"text/javascript\">\n\nfunction sortNumber(a,b)\n{\n    return a - b\n}\n\nvar arr = new Array(6)\narr[0] = \"10\"\narr[1] = \"5\"\narr[2] = \"40\"\narr[3] = \"25\"\narr[4] = \"1000\"\narr[5] = \"1\"\n\ndocument.write(arr.sort(sortNumber)) // 1 5 10 25 40 10000\n\n</script>\n```\n以上代码可知，升序排列方法为：\n\n```\nfunction sortNumber(a,b)\n{\n    return a - b //同理，如果是降序，则为b - a\n}\n```\n\n----\n\n但如果想根据数组对象中的某个属性值进行排序呢？\n\n#### ② 进阶：函数嵌套传参（自定义函数（属性名））\n\nsort方法接收一个函数作为参数。\n我们可以在参数中嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。\n意思是：根据xx属性的值进行排序\n\n```\nvar arr = [\n    {name:'zopp',age:0},\n    {name:'gpp',age:18},\n    {name:'yjj',age:8}\n];\n\nfunction compare(用于判断的属性名){\n    return function(a,b){\n        var value1 = a[用于判断的属性名];\n        var value2 = b[用于判断的属性名];\n        return value1 - value2;\n    }\n}\nconsole.log(arr.sort(compare('age')))  //返回对象，age从小到大正向排序\n```\n\n----\n\n#### ③ 字母排序兼容\n\n我们已经学会了字面量值的升序降序，以及根据属性名对对象数组进行的升序降序\n\n但要是字母大小写不同，该如何来确定是升序排列，还是降序排序呢？\n\n默认情况下，对字符串排序，是按照ASCII的大小比较的。\n现在，我们提出排序应该忽略大小写，按照字母序排序。\n要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：\n\ntoUpperCase() 方法：把字符串转换为大写。\n以下算法基于js底层的JS引擎实现，严格意义上并非某种算法。\n\n而是对于sort()函数的高阶应用！\n\n(s1、s2)为升序，(s2、s1)为降序\n\n```\nvar arr = ['Google', 'apple', 'Microsoft'];\n\nfunction english(s1, s2) {\n    x1 = s1.toUpperCase();\n    x2 = s2.toUpperCase();\n    if (x1 < x2) {\n        return -1;\n    }\n    if (x1 > x2) {\n        return 1;\n    }\n    return 0;\n}\n\narr.sort(english); // ['apple', 'Google', 'Microsoft']\n\n```\n\n原理解析：\n\n>sort()会默认按照字符编码的顺序进行排序。\n\n字符编码的大小判断，会决定sort()方法的返回结果。\n\n- 然而，尽管如此，我们还是可以利用js本身的语法，去灵活使用sort()方法。\n\n----\n\n## sort()原理与通用方法\n\n参考字母排序方法\n\n让我们来看看sort()是如何通过0，1，-1\n来对不同的对象数组进行排序的。\n\n关于前面的字母排序方法，我使用的廖雪峰大神的博客教学代码，接下来为了方便理解，我还会使用他的代码。\n\n### sort()通用方法\n\n#### ①通用简单升序\n\n```\nvar arr = [10, 20, 1, 2];\n\narr.sort(function (x, y) {\n    if (x < y) {\n        return -1;\n    }\n    if (x > y) {\n        return 1;\n    }\n    return 0;\n});\nconsole.log(arr); // [1, 2, 10, 20]\n```\n\n#### ② 通用简单降序\n\n改变上一段代码的return返回值的1和-1的位置（位置对调）。\n\n>闲话：记得廖雪峰大神的教学代码，看过三次，当时都以为看懂了一部分。其实完全没看懂，只是知道怎么用。\n\n接下来说说原理。\n\n### sort()通用排序原理\n\n原理很简单，但是初学者一般不会想得到：\n那就是————JS引擎的判断机制！\n\n想起很久以前看过的一张动漫对比图：\n>天然呆看到看到苹果会想到“苹果很甜、好吃”，或者我们普通人就再加一个iphone。\n>而学霸看到苹果则是会想到牛顿的万有引力、以及各种相关知识……联想能力强到爆炸，学力满满\n\n咳，姑且不提这个悲伤的故事\n\n我们来说说JS引擎的判断机制。\n这是底层实现、但也不是什么非常厉害的东西。\n\n- 仅仅就是if判断语句！\n\n是不是很惊讶？然而，虽然仅仅是if判断语句，但灵活的把不同的东西一起用，还是要对js有一定了解才行，否则除非非常专注去想要钻研问题，或者运气好。\n\n不然一般还是无法理解。\n\n- 讲解部分\n\n这里廖雪峰大神的代码，通过对字符比较的大小判断，以及return返回……\n判断了到底执行哪一条代码。\n\n本质上，排序原理还是`sort()`方法进行排序（参考最前面的代码）\n只是加入if判断。\n\n实际上，-1和0的返回值，都是可以忽略的。\n因为那代表false\n\n>致命魔术：靠近一点，因为你自以为看到的越多，就越容易被欺骗！\n\n所以知识面广很重要！\n\n在刚开始学习一门新技术时，最好对其有相对全面的认识再深入了解！\n\n（这正是我一开始学了很久，技术也很菜的原因！）","source":"_posts/深入浅出js对象排序.md","raw":"---\ntitle: 深入理解js对象排序-sort()\ndate: 2018-04-28 17:35:26\ncategories:\n  - JS学习笔记\ntags:\n  - 排序 js\n---\n\n[toc]\n\n## 排序\n\n假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。\n\n我们可以使用`sort()`方法\n\n<!-- more -->\n\n### sort()\n\n`sort()` 方法用于`对数组的元素进行排序,并返回数组`。\n默认排序顺序是根据字符串Unicode码点。\n\n<!-- more -->\n\n语法：`arrayObject.sort(参数)`\n参数可选，用于规定排序顺序。必须是函数。\n\n注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序。\n准确的说：是按照字符编码的顺序进行排序。\n\n但要实现默认按字母顺序排序，必须先把数组的元素都转换成字符串。\n\n例1：我们将创建一个数组，并按字母顺序进行排序：\n```\n<script type=\"text/javascript\">\n\nvar arr = new Array(4)\narr[0] = \"G\"\narr[1] = \"J\"\narr[2] = \"T\"\narr[3] = \"A\"\n\ndocument.write(arr.sort())  //A G J T\n\n</script>\n```\n\n例2：我们将创建一个数组，并按字母顺序进行排序：\n\n```\n<script type=\"text/javascript\">\n\nvar arr = new Array(6)\narr[0] = \"10\"\narr[1] = \"5\"\narr[2] = \"40\"\narr[3] = \"25\"\narr[4] = \"1000\"\narr[5] = \"1\"\n\ndocument.write(arr.sort())  // 1 10 1000 25 40 5\n\n</script>\n```\n\n至此，我们了解了`sort()`在没有函数传参的情况下：\n#### 默认按照首字母A~Z、a~z排序，以及0~9排序。\n\n- 原理：真正的默认排序顺序是根据字符串Unicode码点。字符串根据ASCII码进行排序。\n\n----\n\n我们注意到，上面的代码没有按照数值的大小对数字进行排序\n要实现这一点，就必须使用一个排序函数。\n\n#### ① 函数传参（a-b）-升序、降序排序\n\n```\n<script type=\"text/javascript\">\n\nfunction sortNumber(a,b)\n{\n    return a - b\n}\n\nvar arr = new Array(6)\narr[0] = \"10\"\narr[1] = \"5\"\narr[2] = \"40\"\narr[3] = \"25\"\narr[4] = \"1000\"\narr[5] = \"1\"\n\ndocument.write(arr.sort(sortNumber)) // 1 5 10 25 40 10000\n\n</script>\n```\n以上代码可知，升序排列方法为：\n\n```\nfunction sortNumber(a,b)\n{\n    return a - b //同理，如果是降序，则为b - a\n}\n```\n\n----\n\n但如果想根据数组对象中的某个属性值进行排序呢？\n\n#### ② 进阶：函数嵌套传参（自定义函数（属性名））\n\nsort方法接收一个函数作为参数。\n我们可以在参数中嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。\n意思是：根据xx属性的值进行排序\n\n```\nvar arr = [\n    {name:'zopp',age:0},\n    {name:'gpp',age:18},\n    {name:'yjj',age:8}\n];\n\nfunction compare(用于判断的属性名){\n    return function(a,b){\n        var value1 = a[用于判断的属性名];\n        var value2 = b[用于判断的属性名];\n        return value1 - value2;\n    }\n}\nconsole.log(arr.sort(compare('age')))  //返回对象，age从小到大正向排序\n```\n\n----\n\n#### ③ 字母排序兼容\n\n我们已经学会了字面量值的升序降序，以及根据属性名对对象数组进行的升序降序\n\n但要是字母大小写不同，该如何来确定是升序排列，还是降序排序呢？\n\n默认情况下，对字符串排序，是按照ASCII的大小比较的。\n现在，我们提出排序应该忽略大小写，按照字母序排序。\n要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：\n\ntoUpperCase() 方法：把字符串转换为大写。\n以下算法基于js底层的JS引擎实现，严格意义上并非某种算法。\n\n而是对于sort()函数的高阶应用！\n\n(s1、s2)为升序，(s2、s1)为降序\n\n```\nvar arr = ['Google', 'apple', 'Microsoft'];\n\nfunction english(s1, s2) {\n    x1 = s1.toUpperCase();\n    x2 = s2.toUpperCase();\n    if (x1 < x2) {\n        return -1;\n    }\n    if (x1 > x2) {\n        return 1;\n    }\n    return 0;\n}\n\narr.sort(english); // ['apple', 'Google', 'Microsoft']\n\n```\n\n原理解析：\n\n>sort()会默认按照字符编码的顺序进行排序。\n\n字符编码的大小判断，会决定sort()方法的返回结果。\n\n- 然而，尽管如此，我们还是可以利用js本身的语法，去灵活使用sort()方法。\n\n----\n\n## sort()原理与通用方法\n\n参考字母排序方法\n\n让我们来看看sort()是如何通过0，1，-1\n来对不同的对象数组进行排序的。\n\n关于前面的字母排序方法，我使用的廖雪峰大神的博客教学代码，接下来为了方便理解，我还会使用他的代码。\n\n### sort()通用方法\n\n#### ①通用简单升序\n\n```\nvar arr = [10, 20, 1, 2];\n\narr.sort(function (x, y) {\n    if (x < y) {\n        return -1;\n    }\n    if (x > y) {\n        return 1;\n    }\n    return 0;\n});\nconsole.log(arr); // [1, 2, 10, 20]\n```\n\n#### ② 通用简单降序\n\n改变上一段代码的return返回值的1和-1的位置（位置对调）。\n\n>闲话：记得廖雪峰大神的教学代码，看过三次，当时都以为看懂了一部分。其实完全没看懂，只是知道怎么用。\n\n接下来说说原理。\n\n### sort()通用排序原理\n\n原理很简单，但是初学者一般不会想得到：\n那就是————JS引擎的判断机制！\n\n想起很久以前看过的一张动漫对比图：\n>天然呆看到看到苹果会想到“苹果很甜、好吃”，或者我们普通人就再加一个iphone。\n>而学霸看到苹果则是会想到牛顿的万有引力、以及各种相关知识……联想能力强到爆炸，学力满满\n\n咳，姑且不提这个悲伤的故事\n\n我们来说说JS引擎的判断机制。\n这是底层实现、但也不是什么非常厉害的东西。\n\n- 仅仅就是if判断语句！\n\n是不是很惊讶？然而，虽然仅仅是if判断语句，但灵活的把不同的东西一起用，还是要对js有一定了解才行，否则除非非常专注去想要钻研问题，或者运气好。\n\n不然一般还是无法理解。\n\n- 讲解部分\n\n这里廖雪峰大神的代码，通过对字符比较的大小判断，以及return返回……\n判断了到底执行哪一条代码。\n\n本质上，排序原理还是`sort()`方法进行排序（参考最前面的代码）\n只是加入if判断。\n\n实际上，-1和0的返回值，都是可以忽略的。\n因为那代表false\n\n>致命魔术：靠近一点，因为你自以为看到的越多，就越容易被欺骗！\n\n所以知识面广很重要！\n\n在刚开始学习一门新技术时，最好对其有相对全面的认识再深入了解！\n\n（这正是我一开始学了很久，技术也很菜的原因！）","slug":"深入浅出js对象排序","published":1,"updated":"2019-06-16T08:33:39.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhgb001s9kud6vexjbsa","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。</p>\n<p>我们可以使用<code>sort()</code>方法</p>\n<a id=\"more\"></a>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p><code>sort()</code> 方法用于<code>对数组的元素进行排序,并返回数组</code>。<br>默认排序顺序是根据字符串Unicode码点。</p>\n<!-- more -->\n<p>语法：<code>arrayObject.sort(参数)</code><br>参数可选，用于规定排序顺序。必须是函数。</p>\n<p>注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序。<br>准确的说：是按照字符编码的顺序进行排序。</p>\n<p>但要实现默认按字母顺序排序，必须先把数组的元素都转换成字符串。</p>\n<p>例1：我们将创建一个数组，并按字母顺序进行排序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new Array(4)</span><br><span class=\"line\">arr[0] = &quot;G&quot;</span><br><span class=\"line\">arr[1] = &quot;J&quot;</span><br><span class=\"line\">arr[2] = &quot;T&quot;</span><br><span class=\"line\">arr[3] = &quot;A&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(arr.sort())  //A G J T</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>例2：我们将创建一个数组，并按字母顺序进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new Array(6)</span><br><span class=\"line\">arr[0] = &quot;10&quot;</span><br><span class=\"line\">arr[1] = &quot;5&quot;</span><br><span class=\"line\">arr[2] = &quot;40&quot;</span><br><span class=\"line\">arr[3] = &quot;25&quot;</span><br><span class=\"line\">arr[4] = &quot;1000&quot;</span><br><span class=\"line\">arr[5] = &quot;1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(arr.sort())  // 1 10 1000 25 40 5</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>至此，我们了解了<code>sort()</code>在没有函数传参的情况下：</p>\n<h4 id=\"默认按照首字母A-Z、a-z排序，以及0-9排序。\"><a href=\"#默认按照首字母A-Z、a-z排序，以及0-9排序。\" class=\"headerlink\" title=\"默认按照首字母A~Z、a~z排序，以及0~9排序。\"></a>默认按照首字母A~Z、a~z排序，以及0~9排序。</h4><ul>\n<li>原理：真正的默认排序顺序是根据字符串Unicode码点。字符串根据ASCII码进行排序。</li>\n</ul>\n<hr>\n<p>我们注意到，上面的代码没有按照数值的大小对数字进行排序<br>要实现这一点，就必须使用一个排序函数。</p>\n<h4 id=\"①-函数传参（a-b）-升序、降序排序\"><a href=\"#①-函数传参（a-b）-升序、降序排序\" class=\"headerlink\" title=\"① 函数传参（a-b）-升序、降序排序\"></a>① 函数传参（a-b）-升序、降序排序</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">function sortNumber(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return a - b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new Array(6)</span><br><span class=\"line\">arr[0] = &quot;10&quot;</span><br><span class=\"line\">arr[1] = &quot;5&quot;</span><br><span class=\"line\">arr[2] = &quot;40&quot;</span><br><span class=\"line\">arr[3] = &quot;25&quot;</span><br><span class=\"line\">arr[4] = &quot;1000&quot;</span><br><span class=\"line\">arr[5] = &quot;1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(arr.sort(sortNumber)) // 1 5 10 25 40 10000</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>以上代码可知，升序排列方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sortNumber(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return a - b //同理，如果是降序，则为b - a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>但如果想根据数组对象中的某个属性值进行排序呢？</p>\n<h4 id=\"②-进阶：函数嵌套传参（自定义函数（属性名））\"><a href=\"#②-进阶：函数嵌套传参（自定义函数（属性名））\" class=\"headerlink\" title=\"② 进阶：函数嵌套传参（自定义函数（属性名））\"></a>② 进阶：函数嵌套传参（自定义函数（属性名））</h4><p>sort方法接收一个函数作为参数。<br>我们可以在参数中嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。<br>意思是：根据xx属性的值进行排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [</span><br><span class=\"line\">    &#123;name:&apos;zopp&apos;,age:0&#125;,</span><br><span class=\"line\">    &#123;name:&apos;gpp&apos;,age:18&#125;,</span><br><span class=\"line\">    &#123;name:&apos;yjj&apos;,age:8&#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">function compare(用于判断的属性名)&#123;</span><br><span class=\"line\">    return function(a,b)&#123;</span><br><span class=\"line\">        var value1 = a[用于判断的属性名];</span><br><span class=\"line\">        var value2 = b[用于判断的属性名];</span><br><span class=\"line\">        return value1 - value2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(arr.sort(compare(&apos;age&apos;)))  //返回对象，age从小到大正向排序</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"③-字母排序兼容\"><a href=\"#③-字母排序兼容\" class=\"headerlink\" title=\"③ 字母排序兼容\"></a>③ 字母排序兼容</h4><p>我们已经学会了字面量值的升序降序，以及根据属性名对对象数组进行的升序降序</p>\n<p>但要是字母大小写不同，该如何来确定是升序排列，还是降序排序呢？</p>\n<p>默认情况下，对字符串排序，是按照ASCII的大小比较的。<br>现在，我们提出排序应该忽略大小写，按照字母序排序。<br>要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：</p>\n<p>toUpperCase() 方法：把字符串转换为大写。<br>以下算法基于js底层的JS引擎实现，严格意义上并非某种算法。</p>\n<p>而是对于sort()函数的高阶应用！</p>\n<p>(s1、s2)为升序，(s2、s1)为降序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">function english(s1, s2) &#123;</span><br><span class=\"line\">    x1 = s1.toUpperCase();</span><br><span class=\"line\">    x2 = s2.toUpperCase();</span><br><span class=\"line\">    if (x1 &lt; x2) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (x1 &gt; x2) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">arr.sort(english); // [&apos;apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;]</span><br></pre></td></tr></table></figure>\n<p>原理解析：</p>\n<blockquote>\n<p>sort()会默认按照字符编码的顺序进行排序。</p>\n</blockquote>\n<p>字符编码的大小判断，会决定sort()方法的返回结果。</p>\n<ul>\n<li>然而，尽管如此，我们还是可以利用js本身的语法，去灵活使用sort()方法。</li>\n</ul>\n<hr>\n<h2 id=\"sort-原理与通用方法\"><a href=\"#sort-原理与通用方法\" class=\"headerlink\" title=\"sort()原理与通用方法\"></a>sort()原理与通用方法</h2><p>参考字母排序方法</p>\n<p>让我们来看看sort()是如何通过0，1，-1<br>来对不同的对象数组进行排序的。</p>\n<p>关于前面的字母排序方法，我使用的廖雪峰大神的博客教学代码，接下来为了方便理解，我还会使用他的代码。</p>\n<h3 id=\"sort-通用方法\"><a href=\"#sort-通用方法\" class=\"headerlink\" title=\"sort()通用方法\"></a>sort()通用方法</h3><h4 id=\"①通用简单升序\"><a href=\"#①通用简单升序\" class=\"headerlink\" title=\"①通用简单升序\"></a>①通用简单升序</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [10, 20, 1, 2];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.sort(function (x, y) &#123;</span><br><span class=\"line\">    if (x &lt; y) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (x &gt; y) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(arr); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure>\n<h4 id=\"②-通用简单降序\"><a href=\"#②-通用简单降序\" class=\"headerlink\" title=\"② 通用简单降序\"></a>② 通用简单降序</h4><p>改变上一段代码的return返回值的1和-1的位置（位置对调）。</p>\n<blockquote>\n<p>闲话：记得廖雪峰大神的教学代码，看过三次，当时都以为看懂了一部分。其实完全没看懂，只是知道怎么用。</p>\n</blockquote>\n<p>接下来说说原理。</p>\n<h3 id=\"sort-通用排序原理\"><a href=\"#sort-通用排序原理\" class=\"headerlink\" title=\"sort()通用排序原理\"></a>sort()通用排序原理</h3><p>原理很简单，但是初学者一般不会想得到：<br>那就是————JS引擎的判断机制！</p>\n<p>想起很久以前看过的一张动漫对比图：</p>\n<blockquote>\n<p>天然呆看到看到苹果会想到“苹果很甜、好吃”，或者我们普通人就再加一个iphone。<br>而学霸看到苹果则是会想到牛顿的万有引力、以及各种相关知识……联想能力强到爆炸，学力满满</p>\n</blockquote>\n<p>咳，姑且不提这个悲伤的故事</p>\n<p>我们来说说JS引擎的判断机制。<br>这是底层实现、但也不是什么非常厉害的东西。</p>\n<ul>\n<li>仅仅就是if判断语句！</li>\n</ul>\n<p>是不是很惊讶？然而，虽然仅仅是if判断语句，但灵活的把不同的东西一起用，还是要对js有一定了解才行，否则除非非常专注去想要钻研问题，或者运气好。</p>\n<p>不然一般还是无法理解。</p>\n<ul>\n<li>讲解部分</li>\n</ul>\n<p>这里廖雪峰大神的代码，通过对字符比较的大小判断，以及return返回……<br>判断了到底执行哪一条代码。</p>\n<p>本质上，排序原理还是<code>sort()</code>方法进行排序（参考最前面的代码）<br>只是加入if判断。</p>\n<p>实际上，-1和0的返回值，都是可以忽略的。<br>因为那代表false</p>\n<blockquote>\n<p>致命魔术：靠近一点，因为你自以为看到的越多，就越容易被欺骗！</p>\n</blockquote>\n<p>所以知识面广很重要！</p>\n<p>在刚开始学习一门新技术时，最好对其有相对全面的认识再深入了解！</p>\n<p>（这正是我一开始学了很久，技术也很菜的原因！）</p>\n","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。</p>\n<p>我们可以使用<code>sort()</code>方法</p>","more":"<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p><code>sort()</code> 方法用于<code>对数组的元素进行排序,并返回数组</code>。<br>默认排序顺序是根据字符串Unicode码点。</p>\n<!-- more -->\n<p>语法：<code>arrayObject.sort(参数)</code><br>参数可选，用于规定排序顺序。必须是函数。</p>\n<p>注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序。<br>准确的说：是按照字符编码的顺序进行排序。</p>\n<p>但要实现默认按字母顺序排序，必须先把数组的元素都转换成字符串。</p>\n<p>例1：我们将创建一个数组，并按字母顺序进行排序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new Array(4)</span><br><span class=\"line\">arr[0] = &quot;G&quot;</span><br><span class=\"line\">arr[1] = &quot;J&quot;</span><br><span class=\"line\">arr[2] = &quot;T&quot;</span><br><span class=\"line\">arr[3] = &quot;A&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(arr.sort())  //A G J T</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>例2：我们将创建一个数组，并按字母顺序进行排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new Array(6)</span><br><span class=\"line\">arr[0] = &quot;10&quot;</span><br><span class=\"line\">arr[1] = &quot;5&quot;</span><br><span class=\"line\">arr[2] = &quot;40&quot;</span><br><span class=\"line\">arr[3] = &quot;25&quot;</span><br><span class=\"line\">arr[4] = &quot;1000&quot;</span><br><span class=\"line\">arr[5] = &quot;1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(arr.sort())  // 1 10 1000 25 40 5</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>至此，我们了解了<code>sort()</code>在没有函数传参的情况下：</p>\n<h4 id=\"默认按照首字母A-Z、a-z排序，以及0-9排序。\"><a href=\"#默认按照首字母A-Z、a-z排序，以及0-9排序。\" class=\"headerlink\" title=\"默认按照首字母A~Z、a~z排序，以及0~9排序。\"></a>默认按照首字母A~Z、a~z排序，以及0~9排序。</h4><ul>\n<li>原理：真正的默认排序顺序是根据字符串Unicode码点。字符串根据ASCII码进行排序。</li>\n</ul>\n<hr>\n<p>我们注意到，上面的代码没有按照数值的大小对数字进行排序<br>要实现这一点，就必须使用一个排序函数。</p>\n<h4 id=\"①-函数传参（a-b）-升序、降序排序\"><a href=\"#①-函数传参（a-b）-升序、降序排序\" class=\"headerlink\" title=\"① 函数传参（a-b）-升序、降序排序\"></a>① 函数传参（a-b）-升序、降序排序</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">function sortNumber(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return a - b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new Array(6)</span><br><span class=\"line\">arr[0] = &quot;10&quot;</span><br><span class=\"line\">arr[1] = &quot;5&quot;</span><br><span class=\"line\">arr[2] = &quot;40&quot;</span><br><span class=\"line\">arr[3] = &quot;25&quot;</span><br><span class=\"line\">arr[4] = &quot;1000&quot;</span><br><span class=\"line\">arr[5] = &quot;1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">document.write(arr.sort(sortNumber)) // 1 5 10 25 40 10000</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>以上代码可知，升序排列方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sortNumber(a,b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return a - b //同理，如果是降序，则为b - a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>但如果想根据数组对象中的某个属性值进行排序呢？</p>\n<h4 id=\"②-进阶：函数嵌套传参（自定义函数（属性名））\"><a href=\"#②-进阶：函数嵌套传参（自定义函数（属性名））\" class=\"headerlink\" title=\"② 进阶：函数嵌套传参（自定义函数（属性名））\"></a>② 进阶：函数嵌套传参（自定义函数（属性名））</h4><p>sort方法接收一个函数作为参数。<br>我们可以在参数中嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。<br>意思是：根据xx属性的值进行排序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [</span><br><span class=\"line\">    &#123;name:&apos;zopp&apos;,age:0&#125;,</span><br><span class=\"line\">    &#123;name:&apos;gpp&apos;,age:18&#125;,</span><br><span class=\"line\">    &#123;name:&apos;yjj&apos;,age:8&#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">function compare(用于判断的属性名)&#123;</span><br><span class=\"line\">    return function(a,b)&#123;</span><br><span class=\"line\">        var value1 = a[用于判断的属性名];</span><br><span class=\"line\">        var value2 = b[用于判断的属性名];</span><br><span class=\"line\">        return value1 - value2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(arr.sort(compare(&apos;age&apos;)))  //返回对象，age从小到大正向排序</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"③-字母排序兼容\"><a href=\"#③-字母排序兼容\" class=\"headerlink\" title=\"③ 字母排序兼容\"></a>③ 字母排序兼容</h4><p>我们已经学会了字面量值的升序降序，以及根据属性名对对象数组进行的升序降序</p>\n<p>但要是字母大小写不同，该如何来确定是升序排列，还是降序排序呢？</p>\n<p>默认情况下，对字符串排序，是按照ASCII的大小比较的。<br>现在，我们提出排序应该忽略大小写，按照字母序排序。<br>要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：</p>\n<p>toUpperCase() 方法：把字符串转换为大写。<br>以下算法基于js底层的JS引擎实现，严格意义上并非某种算法。</p>\n<p>而是对于sort()函数的高阶应用！</p>\n<p>(s1、s2)为升序，(s2、s1)为降序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">function english(s1, s2) &#123;</span><br><span class=\"line\">    x1 = s1.toUpperCase();</span><br><span class=\"line\">    x2 = s2.toUpperCase();</span><br><span class=\"line\">    if (x1 &lt; x2) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (x1 &gt; x2) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">arr.sort(english); // [&apos;apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;]</span><br></pre></td></tr></table></figure>\n<p>原理解析：</p>\n<blockquote>\n<p>sort()会默认按照字符编码的顺序进行排序。</p>\n</blockquote>\n<p>字符编码的大小判断，会决定sort()方法的返回结果。</p>\n<ul>\n<li>然而，尽管如此，我们还是可以利用js本身的语法，去灵活使用sort()方法。</li>\n</ul>\n<hr>\n<h2 id=\"sort-原理与通用方法\"><a href=\"#sort-原理与通用方法\" class=\"headerlink\" title=\"sort()原理与通用方法\"></a>sort()原理与通用方法</h2><p>参考字母排序方法</p>\n<p>让我们来看看sort()是如何通过0，1，-1<br>来对不同的对象数组进行排序的。</p>\n<p>关于前面的字母排序方法，我使用的廖雪峰大神的博客教学代码，接下来为了方便理解，我还会使用他的代码。</p>\n<h3 id=\"sort-通用方法\"><a href=\"#sort-通用方法\" class=\"headerlink\" title=\"sort()通用方法\"></a>sort()通用方法</h3><h4 id=\"①通用简单升序\"><a href=\"#①通用简单升序\" class=\"headerlink\" title=\"①通用简单升序\"></a>①通用简单升序</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [10, 20, 1, 2];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.sort(function (x, y) &#123;</span><br><span class=\"line\">    if (x &lt; y) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (x &gt; y) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(arr); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure>\n<h4 id=\"②-通用简单降序\"><a href=\"#②-通用简单降序\" class=\"headerlink\" title=\"② 通用简单降序\"></a>② 通用简单降序</h4><p>改变上一段代码的return返回值的1和-1的位置（位置对调）。</p>\n<blockquote>\n<p>闲话：记得廖雪峰大神的教学代码，看过三次，当时都以为看懂了一部分。其实完全没看懂，只是知道怎么用。</p>\n</blockquote>\n<p>接下来说说原理。</p>\n<h3 id=\"sort-通用排序原理\"><a href=\"#sort-通用排序原理\" class=\"headerlink\" title=\"sort()通用排序原理\"></a>sort()通用排序原理</h3><p>原理很简单，但是初学者一般不会想得到：<br>那就是————JS引擎的判断机制！</p>\n<p>想起很久以前看过的一张动漫对比图：</p>\n<blockquote>\n<p>天然呆看到看到苹果会想到“苹果很甜、好吃”，或者我们普通人就再加一个iphone。<br>而学霸看到苹果则是会想到牛顿的万有引力、以及各种相关知识……联想能力强到爆炸，学力满满</p>\n</blockquote>\n<p>咳，姑且不提这个悲伤的故事</p>\n<p>我们来说说JS引擎的判断机制。<br>这是底层实现、但也不是什么非常厉害的东西。</p>\n<ul>\n<li>仅仅就是if判断语句！</li>\n</ul>\n<p>是不是很惊讶？然而，虽然仅仅是if判断语句，但灵活的把不同的东西一起用，还是要对js有一定了解才行，否则除非非常专注去想要钻研问题，或者运气好。</p>\n<p>不然一般还是无法理解。</p>\n<ul>\n<li>讲解部分</li>\n</ul>\n<p>这里廖雪峰大神的代码，通过对字符比较的大小判断，以及return返回……<br>判断了到底执行哪一条代码。</p>\n<p>本质上，排序原理还是<code>sort()</code>方法进行排序（参考最前面的代码）<br>只是加入if判断。</p>\n<p>实际上，-1和0的返回值，都是可以忽略的。<br>因为那代表false</p>\n<blockquote>\n<p>致命魔术：靠近一点，因为你自以为看到的越多，就越容易被欺骗！</p>\n</blockquote>\n<p>所以知识面广很重要！</p>\n<p>在刚开始学习一门新技术时，最好对其有相对全面的认识再深入了解！</p>\n<p>（这正是我一开始学了很久，技术也很菜的原因！）</p>"},{"title":"组件component","date":"2018-05-03T03:55:47.000Z","_content":"[toc]\n\n## 什么是组件？\n\n组件（Component）是 Vue.js 最强大的功能之一。\n组件可以扩展 HTML 元素，封装可重用的代码\n组件是自定义元素（对象）\n\n<!--more-->\n\n## 定义组件的方式\n\n#### 方式1：先创建组件构造器，然后由组件构造器创建组件（全局）\n```\n1.使用Vue.extend()创建一个组件构造器\n\t\tvar MyComponent=Vue.extend({\n\t\t\ttemplate:'<h3>Hello World</h3>'\n\t\t});\n2.使用Vue.component(标签名,组件构造器)，根据组件构造器来创建组件\n\t\tVue.component('hello',MyComponent);\n```\n\n#### 方式2：直接创建组件（全局）\n\n直接把组件构造器写在{}里定义\n\n```\nVue.component('my-world',{\n\t\t\ttemplate:'<h1>你好，世界</h1>'\n\t\t});\n```\n\n#### 方式3：局部组件（常用）\n\n```\n// 挂载到单页面里，只在当前页有效\ncomponents:{\n    'my-world',{\n\t\t\ttemplate:'<h1>你好，世界</h1>'\n\t\t}\n}\n```\n\n## 组件中添加数据\n\n在组件中存储数据时，必须以函数形式，函数返回一个对象\n```\ncomponents:{ //局部组件\n\t\t\t\t'my-world':{\n\t\t\t\t\ttemplate:'<h3>{{age}}</h3>',\n\t\t\t\t\tdata(){\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tage:25\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n```\n\n## 引用模板\n\n组件化开发中，引用模板为直接创建新文件，作为组件。\n组件名为文件名。\n\n```\n<template id=\"wbs\">\n\t<!-- <template>必须有且只有一个根元素 -->\n\t<div></div>\n</template>\n\ncomponents:{\n\t'my-hello':{\n\t\tname:'wbs17022',  //指定组件的名称，默认为标签名，可以不设置\n\t\ttemplate:'#wbs',\n\t\tdata(){\n\t\t\treturn {\n\t\t\t\tmsg:'欢迎来到南京网博',\n\t\t\t\tarr:['tom','jack','mike']\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\t\n}\n```\n\n## 动态加载组件\n\n`<component :is=\"挂载点\">`\n    多个组件使用同一个挂载点，然后动态的在它们之间切换    \n\n```\n<button @click=\"flag='my-hello'\">显示hello组件</button>\n<button @click=\"flag='my-world'\">显示world组件</button>\n\n<component :is=\"flag\"></component>\n\ndata:{\n\t\tflag:'my-hello'\n\t}\n```\n\n## `<keep-alive>`缓存组件\n\n标签的组件实例能够被在它们第一次被创建的时候缓存下来。\n","source":"_posts/组件component.md","raw":"---\ntitle: 组件component\ndate: 2018-05-03 11:55:47\ncategories:\n  - vue\ntags:\n  - vue组件 \n---\n[toc]\n\n## 什么是组件？\n\n组件（Component）是 Vue.js 最强大的功能之一。\n组件可以扩展 HTML 元素，封装可重用的代码\n组件是自定义元素（对象）\n\n<!--more-->\n\n## 定义组件的方式\n\n#### 方式1：先创建组件构造器，然后由组件构造器创建组件（全局）\n```\n1.使用Vue.extend()创建一个组件构造器\n\t\tvar MyComponent=Vue.extend({\n\t\t\ttemplate:'<h3>Hello World</h3>'\n\t\t});\n2.使用Vue.component(标签名,组件构造器)，根据组件构造器来创建组件\n\t\tVue.component('hello',MyComponent);\n```\n\n#### 方式2：直接创建组件（全局）\n\n直接把组件构造器写在{}里定义\n\n```\nVue.component('my-world',{\n\t\t\ttemplate:'<h1>你好，世界</h1>'\n\t\t});\n```\n\n#### 方式3：局部组件（常用）\n\n```\n// 挂载到单页面里，只在当前页有效\ncomponents:{\n    'my-world',{\n\t\t\ttemplate:'<h1>你好，世界</h1>'\n\t\t}\n}\n```\n\n## 组件中添加数据\n\n在组件中存储数据时，必须以函数形式，函数返回一个对象\n```\ncomponents:{ //局部组件\n\t\t\t\t'my-world':{\n\t\t\t\t\ttemplate:'<h3>{{age}}</h3>',\n\t\t\t\t\tdata(){\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tage:25\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n```\n\n## 引用模板\n\n组件化开发中，引用模板为直接创建新文件，作为组件。\n组件名为文件名。\n\n```\n<template id=\"wbs\">\n\t<!-- <template>必须有且只有一个根元素 -->\n\t<div></div>\n</template>\n\ncomponents:{\n\t'my-hello':{\n\t\tname:'wbs17022',  //指定组件的名称，默认为标签名，可以不设置\n\t\ttemplate:'#wbs',\n\t\tdata(){\n\t\t\treturn {\n\t\t\t\tmsg:'欢迎来到南京网博',\n\t\t\t\tarr:['tom','jack','mike']\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\t\n}\n```\n\n## 动态加载组件\n\n`<component :is=\"挂载点\">`\n    多个组件使用同一个挂载点，然后动态的在它们之间切换    \n\n```\n<button @click=\"flag='my-hello'\">显示hello组件</button>\n<button @click=\"flag='my-world'\">显示world组件</button>\n\n<component :is=\"flag\"></component>\n\ndata:{\n\t\tflag:'my-hello'\n\t}\n```\n\n## `<keep-alive>`缓存组件\n\n标签的组件实例能够被在它们第一次被创建的时候缓存下来。\n","slug":"组件component","published":1,"updated":"2019-04-07T14:56:55.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhge001v9kudhohn0x6k","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>[toc]</p>\n<h2 id=\"什么是组件？\"><a href=\"#什么是组件？\" class=\"headerlink\" title=\"什么是组件？\"></a>什么是组件？</h2><p>组件（Component）是 Vue.js 最强大的功能之一。<br>组件可以扩展 HTML 元素，封装可重用的代码<br>组件是自定义元素（对象）</p>\n<a id=\"more\"></a>\n<h2 id=\"定义组件的方式\"><a href=\"#定义组件的方式\" class=\"headerlink\" title=\"定义组件的方式\"></a>定义组件的方式</h2><h4 id=\"方式1：先创建组件构造器，然后由组件构造器创建组件（全局）\"><a href=\"#方式1：先创建组件构造器，然后由组件构造器创建组件（全局）\" class=\"headerlink\" title=\"方式1：先创建组件构造器，然后由组件构造器创建组件（全局）\"></a>方式1：先创建组件构造器，然后由组件构造器创建组件（全局）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.使用Vue.extend()创建一个组件构造器</span><br><span class=\"line\">\t\tvar MyComponent=Vue.extend(&#123;</span><br><span class=\"line\">\t\t\ttemplate:&apos;&lt;h3&gt;Hello World&lt;/h3&gt;&apos;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">2.使用Vue.component(标签名,组件构造器)，根据组件构造器来创建组件</span><br><span class=\"line\">\t\tVue.component(&apos;hello&apos;,MyComponent);</span><br></pre></td></tr></table></figure>\n<h4 id=\"方式2：直接创建组件（全局）\"><a href=\"#方式2：直接创建组件（全局）\" class=\"headerlink\" title=\"方式2：直接创建组件（全局）\"></a>方式2：直接创建组件（全局）</h4><p>直接把组件构造器写在{}里定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;my-world&apos;,&#123;</span><br><span class=\"line\">\t\t\ttemplate:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos;</span><br><span class=\"line\">\t\t&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"方式3：局部组件（常用）\"><a href=\"#方式3：局部组件（常用）\" class=\"headerlink\" title=\"方式3：局部组件（常用）\"></a>方式3：局部组件（常用）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 挂载到单页面里，只在当前页有效</span><br><span class=\"line\">components:&#123;</span><br><span class=\"line\">    &apos;my-world&apos;,&#123;</span><br><span class=\"line\">\t\t\ttemplate:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件中添加数据\"><a href=\"#组件中添加数据\" class=\"headerlink\" title=\"组件中添加数据\"></a>组件中添加数据</h2><p>在组件中存储数据时，必须以函数形式，函数返回一个对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">components:&#123; //局部组件</span><br><span class=\"line\">\t\t\t\t&apos;my-world&apos;:&#123;</span><br><span class=\"line\">\t\t\t\t\ttemplate:&apos;&lt;h3&gt;&#123;&#123;age&#125;&#125;&lt;/h3&gt;&apos;,</span><br><span class=\"line\">\t\t\t\t\tdata()&#123;</span><br><span class=\"line\">\t\t\t\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tage:25</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"引用模板\"><a href=\"#引用模板\" class=\"headerlink\" title=\"引用模板\"></a>引用模板</h2><p>组件化开发中，引用模板为直接创建新文件，作为组件。<br>组件名为文件名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template id=&quot;wbs&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- &lt;template&gt;必须有且只有一个根元素 --&gt;</span><br><span class=\"line\">\t&lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">components:&#123;</span><br><span class=\"line\">\t&apos;my-hello&apos;:&#123;</span><br><span class=\"line\">\t\tname:&apos;wbs17022&apos;,  //指定组件的名称，默认为标签名，可以不设置</span><br><span class=\"line\">\t\ttemplate:&apos;#wbs&apos;,</span><br><span class=\"line\">\t\tdata()&#123;</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tmsg:&apos;欢迎来到南京网博&apos;,</span><br><span class=\"line\">\t\t\t\tarr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态加载组件\"><a href=\"#动态加载组件\" class=\"headerlink\" title=\"动态加载组件\"></a>动态加载组件</h2><p><code>&lt;component :is=&quot;挂载点&quot;&gt;</code><br>    多个组件使用同一个挂载点，然后动态的在它们之间切换    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button @click=&quot;flag=&apos;my-hello&apos;&quot;&gt;显示hello组件&lt;/button&gt;</span><br><span class=\"line\">&lt;button @click=&quot;flag=&apos;my-world&apos;&quot;&gt;显示world组件&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;component :is=&quot;flag&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data:&#123;</span><br><span class=\"line\">\t\tflag:&apos;my-hello&apos;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"lt-keep-alive-gt-缓存组件\"><a href=\"#lt-keep-alive-gt-缓存组件\" class=\"headerlink\" title=\"&lt;keep-alive&gt;缓存组件\"></a><code>&lt;keep-alive&gt;</code>缓存组件</h2><p>标签的组件实例能够被在它们第一次被创建的时候缓存下来。</p>\n","site":{"data":{}},"excerpt":"<p>[toc]</p>\n<h2 id=\"什么是组件？\"><a href=\"#什么是组件？\" class=\"headerlink\" title=\"什么是组件？\"></a>什么是组件？</h2><p>组件（Component）是 Vue.js 最强大的功能之一。<br>组件可以扩展 HTML 元素，封装可重用的代码<br>组件是自定义元素（对象）</p>","more":"<h2 id=\"定义组件的方式\"><a href=\"#定义组件的方式\" class=\"headerlink\" title=\"定义组件的方式\"></a>定义组件的方式</h2><h4 id=\"方式1：先创建组件构造器，然后由组件构造器创建组件（全局）\"><a href=\"#方式1：先创建组件构造器，然后由组件构造器创建组件（全局）\" class=\"headerlink\" title=\"方式1：先创建组件构造器，然后由组件构造器创建组件（全局）\"></a>方式1：先创建组件构造器，然后由组件构造器创建组件（全局）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.使用Vue.extend()创建一个组件构造器</span><br><span class=\"line\">\t\tvar MyComponent=Vue.extend(&#123;</span><br><span class=\"line\">\t\t\ttemplate:&apos;&lt;h3&gt;Hello World&lt;/h3&gt;&apos;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">2.使用Vue.component(标签名,组件构造器)，根据组件构造器来创建组件</span><br><span class=\"line\">\t\tVue.component(&apos;hello&apos;,MyComponent);</span><br></pre></td></tr></table></figure>\n<h4 id=\"方式2：直接创建组件（全局）\"><a href=\"#方式2：直接创建组件（全局）\" class=\"headerlink\" title=\"方式2：直接创建组件（全局）\"></a>方式2：直接创建组件（全局）</h4><p>直接把组件构造器写在{}里定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&apos;my-world&apos;,&#123;</span><br><span class=\"line\">\t\t\ttemplate:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos;</span><br><span class=\"line\">\t\t&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"方式3：局部组件（常用）\"><a href=\"#方式3：局部组件（常用）\" class=\"headerlink\" title=\"方式3：局部组件（常用）\"></a>方式3：局部组件（常用）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 挂载到单页面里，只在当前页有效</span><br><span class=\"line\">components:&#123;</span><br><span class=\"line\">    &apos;my-world&apos;,&#123;</span><br><span class=\"line\">\t\t\ttemplate:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"组件中添加数据\"><a href=\"#组件中添加数据\" class=\"headerlink\" title=\"组件中添加数据\"></a>组件中添加数据</h2><p>在组件中存储数据时，必须以函数形式，函数返回一个对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">components:&#123; //局部组件</span><br><span class=\"line\">\t\t\t\t&apos;my-world&apos;:&#123;</span><br><span class=\"line\">\t\t\t\t\ttemplate:&apos;&lt;h3&gt;&#123;&#123;age&#125;&#125;&lt;/h3&gt;&apos;,</span><br><span class=\"line\">\t\t\t\t\tdata()&#123;</span><br><span class=\"line\">\t\t\t\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tage:25</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"引用模板\"><a href=\"#引用模板\" class=\"headerlink\" title=\"引用模板\"></a>引用模板</h2><p>组件化开发中，引用模板为直接创建新文件，作为组件。<br>组件名为文件名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template id=&quot;wbs&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- &lt;template&gt;必须有且只有一个根元素 --&gt;</span><br><span class=\"line\">\t&lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">components:&#123;</span><br><span class=\"line\">\t&apos;my-hello&apos;:&#123;</span><br><span class=\"line\">\t\tname:&apos;wbs17022&apos;,  //指定组件的名称，默认为标签名，可以不设置</span><br><span class=\"line\">\t\ttemplate:&apos;#wbs&apos;,</span><br><span class=\"line\">\t\tdata()&#123;</span><br><span class=\"line\">\t\t\treturn &#123;</span><br><span class=\"line\">\t\t\t\tmsg:&apos;欢迎来到南京网博&apos;,</span><br><span class=\"line\">\t\t\t\tarr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态加载组件\"><a href=\"#动态加载组件\" class=\"headerlink\" title=\"动态加载组件\"></a>动态加载组件</h2><p><code>&lt;component :is=&quot;挂载点&quot;&gt;</code><br>    多个组件使用同一个挂载点，然后动态的在它们之间切换    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button @click=&quot;flag=&apos;my-hello&apos;&quot;&gt;显示hello组件&lt;/button&gt;</span><br><span class=\"line\">&lt;button @click=&quot;flag=&apos;my-world&apos;&quot;&gt;显示world组件&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;component :is=&quot;flag&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">data:&#123;</span><br><span class=\"line\">\t\tflag:&apos;my-hello&apos;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"lt-keep-alive-gt-缓存组件\"><a href=\"#lt-keep-alive-gt-缓存组件\" class=\"headerlink\" title=\"&lt;keep-alive&gt;缓存组件\"></a><code>&lt;keep-alive&gt;</code>缓存组件</h2><p>标签的组件实例能够被在它们第一次被创建的时候缓存下来。</p>"},{"title":"练习：vue自定义指令","date":"2018-05-02T07:57:07.000Z","_content":"\n这是很少会更新的附带完整代码的博客。\n究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。\n<!--more-->\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>练习：自定义指令</title>\n\t<script src=\"js/vue.js\"></script>\n\t<style>\n\t\t#itany div{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tposition:absolute;\n\t\t}\n\t\t#itany .hello{\n\t\t\tbackground-color:red;\n\t\t\ttop:0;\n\t\t\tleft:0;\n\t\t}\n\t\t#itany .world{\n\t\t\tbackground-color:blue;\n\t\t\ttop:0;\n\t\t\tright:0;\n\t\t}\n\n\t</style>\n</head>\n<body>\n\t<div id=\"itany\">\n\t\t<div class=\"hello\" v-drag>itany</div>\n\t\t<div class=\"world\" v-drag>网博</div>\n\t</div>\n\n\t<script>\n        // vue全局自定义指令\n\t\tVue.directive('drag',function(el){\n\t\t\tel.onmousedown=function(e){\n\t\t\t\t// 获取鼠标点击处分别与div左边和上边的距离：鼠标位置-div位置\n\t\t\t\tvar disX=e.clientX-el.offsetLeft;\n\t\t\t\tvar disY=e.clientY-el.offsetTop;\n\t\t\t\t// console.log(disX,disY);\n\n\t\t\t\t//包含在onmousedown里面，表示点击后才移动，为防止鼠标移出div，使用document.onmousemove\n\t\t\t\tdocument.onmousemove=function(e){\n\t\t\t\t\t// 获取移动后div的位置：鼠标位置-disX/disY\n\t\t\t\t\t// 因为offset获取的是左边和上边，所以移动需使用减法\n\t\t\t\t\tvar l=e.clientX-disX;\n\t\t\t\t\tvar t=e.clientY-disY;\n\t\t\t\t\tel.style.left=l+'px';// 记得要加px像素单位,否则不移动\n\t\t\t\t\tel.style.top=t+'px';\n\t\t\t\t}\n\n\t\t\t\t//停止移动，鼠标抬起触发\n\t\t\t\tdocument.onmouseup=function(e){\n                    // 清空鼠标按住状态\n\t\t\t\t\tdocument.onmousemove=null;\n                    // 销毁自身\n\t\t\t\t\tdocument.onmouseup=null;\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n\n\t\tvar vm=new Vue({\n\t\t\tel:'#itany',\n\t\t\tdata:{\n\t\t\t\tmsg:'welcome to itany',\n\t\t\t\tusername:'alice'\n\t\t\t},\n\t\t\tmethods:{\n\t\t\t\tchange(){\n\t\t\t\t\tthis.msg='欢迎来到南京网博'\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t</script>\n\t\n</body>\n</html>\n```","source":"_posts/练习：vue自定义指令.md","raw":"---\ntitle: 练习：vue自定义指令\ndate: 2018-05-02 15:57:07\ncategories:\n  - vue\ntags:\n  - vue\n---\n\n这是很少会更新的附带完整代码的博客。\n究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。\n<!--more-->\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>练习：自定义指令</title>\n\t<script src=\"js/vue.js\"></script>\n\t<style>\n\t\t#itany div{\n\t\t\twidth: 100px;\n\t\t\theight: 100px;\n\t\t\tposition:absolute;\n\t\t}\n\t\t#itany .hello{\n\t\t\tbackground-color:red;\n\t\t\ttop:0;\n\t\t\tleft:0;\n\t\t}\n\t\t#itany .world{\n\t\t\tbackground-color:blue;\n\t\t\ttop:0;\n\t\t\tright:0;\n\t\t}\n\n\t</style>\n</head>\n<body>\n\t<div id=\"itany\">\n\t\t<div class=\"hello\" v-drag>itany</div>\n\t\t<div class=\"world\" v-drag>网博</div>\n\t</div>\n\n\t<script>\n        // vue全局自定义指令\n\t\tVue.directive('drag',function(el){\n\t\t\tel.onmousedown=function(e){\n\t\t\t\t// 获取鼠标点击处分别与div左边和上边的距离：鼠标位置-div位置\n\t\t\t\tvar disX=e.clientX-el.offsetLeft;\n\t\t\t\tvar disY=e.clientY-el.offsetTop;\n\t\t\t\t// console.log(disX,disY);\n\n\t\t\t\t//包含在onmousedown里面，表示点击后才移动，为防止鼠标移出div，使用document.onmousemove\n\t\t\t\tdocument.onmousemove=function(e){\n\t\t\t\t\t// 获取移动后div的位置：鼠标位置-disX/disY\n\t\t\t\t\t// 因为offset获取的是左边和上边，所以移动需使用减法\n\t\t\t\t\tvar l=e.clientX-disX;\n\t\t\t\t\tvar t=e.clientY-disY;\n\t\t\t\t\tel.style.left=l+'px';// 记得要加px像素单位,否则不移动\n\t\t\t\t\tel.style.top=t+'px';\n\t\t\t\t}\n\n\t\t\t\t//停止移动，鼠标抬起触发\n\t\t\t\tdocument.onmouseup=function(e){\n                    // 清空鼠标按住状态\n\t\t\t\t\tdocument.onmousemove=null;\n                    // 销毁自身\n\t\t\t\t\tdocument.onmouseup=null;\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n\n\t\tvar vm=new Vue({\n\t\t\tel:'#itany',\n\t\t\tdata:{\n\t\t\t\tmsg:'welcome to itany',\n\t\t\t\tusername:'alice'\n\t\t\t},\n\t\t\tmethods:{\n\t\t\t\tchange(){\n\t\t\t\t\tthis.msg='欢迎来到南京网博'\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t</script>\n\t\n</body>\n</html>\n```","slug":"练习：vue自定义指令","published":1,"updated":"2019-04-07T14:56:55.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhgg001y9kudm3fy2has","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><p>这是很少会更新的附带完整代码的博客。<br>究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t&lt;title&gt;练习：自定义指令&lt;/title&gt;</span><br><span class=\"line\">\t&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">\t&lt;style&gt;</span><br><span class=\"line\">\t\t#itany div&#123;</span><br><span class=\"line\">\t\t\twidth: 100px;</span><br><span class=\"line\">\t\t\theight: 100px;</span><br><span class=\"line\">\t\t\tposition:absolute;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t#itany .hello&#123;</span><br><span class=\"line\">\t\t\tbackground-color:red;</span><br><span class=\"line\">\t\t\ttop:0;</span><br><span class=\"line\">\t\t\tleft:0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t#itany .world&#123;</span><br><span class=\"line\">\t\t\tbackground-color:blue;</span><br><span class=\"line\">\t\t\ttop:0;</span><br><span class=\"line\">\t\t\tright:0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;div id=&quot;itany&quot;&gt;</span><br><span class=\"line\">\t\t&lt;div class=&quot;hello&quot; v-drag&gt;itany&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;div class=&quot;world&quot; v-drag&gt;网博&lt;/div&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;script&gt;</span><br><span class=\"line\">        // vue全局自定义指令</span><br><span class=\"line\">\t\tVue.directive(&apos;drag&apos;,function(el)&#123;</span><br><span class=\"line\">\t\t\tel.onmousedown=function(e)&#123;</span><br><span class=\"line\">\t\t\t\t// 获取鼠标点击处分别与div左边和上边的距离：鼠标位置-div位置</span><br><span class=\"line\">\t\t\t\tvar disX=e.clientX-el.offsetLeft;</span><br><span class=\"line\">\t\t\t\tvar disY=e.clientY-el.offsetTop;</span><br><span class=\"line\">\t\t\t\t// console.log(disX,disY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//包含在onmousedown里面，表示点击后才移动，为防止鼠标移出div，使用document.onmousemove</span><br><span class=\"line\">\t\t\t\tdocument.onmousemove=function(e)&#123;</span><br><span class=\"line\">\t\t\t\t\t// 获取移动后div的位置：鼠标位置-disX/disY</span><br><span class=\"line\">\t\t\t\t\t// 因为offset获取的是左边和上边，所以移动需使用减法</span><br><span class=\"line\">\t\t\t\t\tvar l=e.clientX-disX;</span><br><span class=\"line\">\t\t\t\t\tvar t=e.clientY-disY;</span><br><span class=\"line\">\t\t\t\t\tel.style.left=l+&apos;px&apos;;// 记得要加px像素单位,否则不移动</span><br><span class=\"line\">\t\t\t\t\tel.style.top=t+&apos;px&apos;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//停止移动，鼠标抬起触发</span><br><span class=\"line\">\t\t\t\tdocument.onmouseup=function(e)&#123;</span><br><span class=\"line\">                    // 清空鼠标按住状态</span><br><span class=\"line\">\t\t\t\t\tdocument.onmousemove=null;</span><br><span class=\"line\">                    // 销毁自身</span><br><span class=\"line\">\t\t\t\t\tdocument.onmouseup=null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar vm=new Vue(&#123;</span><br><span class=\"line\">\t\t\tel:&apos;#itany&apos;,</span><br><span class=\"line\">\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\tmsg:&apos;welcome to itany&apos;,</span><br><span class=\"line\">\t\t\t\tusername:&apos;alice&apos;</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tmethods:&#123;</span><br><span class=\"line\">\t\t\t\tchange()&#123;</span><br><span class=\"line\">\t\t\t\t\tthis.msg=&apos;欢迎来到南京网博&apos;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&lt;/script&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>这是很少会更新的附带完整代码的博客。<br>究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t&lt;title&gt;练习：自定义指令&lt;/title&gt;</span><br><span class=\"line\">\t&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">\t&lt;style&gt;</span><br><span class=\"line\">\t\t#itany div&#123;</span><br><span class=\"line\">\t\t\twidth: 100px;</span><br><span class=\"line\">\t\t\theight: 100px;</span><br><span class=\"line\">\t\t\tposition:absolute;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t#itany .hello&#123;</span><br><span class=\"line\">\t\t\tbackground-color:red;</span><br><span class=\"line\">\t\t\ttop:0;</span><br><span class=\"line\">\t\t\tleft:0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t#itany .world&#123;</span><br><span class=\"line\">\t\t\tbackground-color:blue;</span><br><span class=\"line\">\t\t\ttop:0;</span><br><span class=\"line\">\t\t\tright:0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;div id=&quot;itany&quot;&gt;</span><br><span class=\"line\">\t\t&lt;div class=&quot;hello&quot; v-drag&gt;itany&lt;/div&gt;</span><br><span class=\"line\">\t\t&lt;div class=&quot;world&quot; v-drag&gt;网博&lt;/div&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;script&gt;</span><br><span class=\"line\">        // vue全局自定义指令</span><br><span class=\"line\">\t\tVue.directive(&apos;drag&apos;,function(el)&#123;</span><br><span class=\"line\">\t\t\tel.onmousedown=function(e)&#123;</span><br><span class=\"line\">\t\t\t\t// 获取鼠标点击处分别与div左边和上边的距离：鼠标位置-div位置</span><br><span class=\"line\">\t\t\t\tvar disX=e.clientX-el.offsetLeft;</span><br><span class=\"line\">\t\t\t\tvar disY=e.clientY-el.offsetTop;</span><br><span class=\"line\">\t\t\t\t// console.log(disX,disY);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//包含在onmousedown里面，表示点击后才移动，为防止鼠标移出div，使用document.onmousemove</span><br><span class=\"line\">\t\t\t\tdocument.onmousemove=function(e)&#123;</span><br><span class=\"line\">\t\t\t\t\t// 获取移动后div的位置：鼠标位置-disX/disY</span><br><span class=\"line\">\t\t\t\t\t// 因为offset获取的是左边和上边，所以移动需使用减法</span><br><span class=\"line\">\t\t\t\t\tvar l=e.clientX-disX;</span><br><span class=\"line\">\t\t\t\t\tvar t=e.clientY-disY;</span><br><span class=\"line\">\t\t\t\t\tel.style.left=l+&apos;px&apos;;// 记得要加px像素单位,否则不移动</span><br><span class=\"line\">\t\t\t\t\tel.style.top=t+&apos;px&apos;;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t//停止移动，鼠标抬起触发</span><br><span class=\"line\">\t\t\t\tdocument.onmouseup=function(e)&#123;</span><br><span class=\"line\">                    // 清空鼠标按住状态</span><br><span class=\"line\">\t\t\t\t\tdocument.onmousemove=null;</span><br><span class=\"line\">                    // 销毁自身</span><br><span class=\"line\">\t\t\t\t\tdocument.onmouseup=null;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tvar vm=new Vue(&#123;</span><br><span class=\"line\">\t\t\tel:&apos;#itany&apos;,</span><br><span class=\"line\">\t\t\tdata:&#123;</span><br><span class=\"line\">\t\t\t\tmsg:&apos;welcome to itany&apos;,</span><br><span class=\"line\">\t\t\t\tusername:&apos;alice&apos;</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\tmethods:&#123;</span><br><span class=\"line\">\t\t\t\tchange()&#123;</span><br><span class=\"line\">\t\t\t\t\tthis.msg=&apos;欢迎来到南京网博&apos;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&lt;/script&gt;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>"},{"title":"组件间数据传递","date":"2018-05-03T07:16:02.000Z","_content":"\n# 父子组件\n\n在一个组件内部定义另一个组件，称为父子组件\n子组件只能在父组件内部使用\n默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的\n\n<!-- more -->\n\n# 组件间数据传递 （通信）\n\n```\n <food @add=\"addFood\" :food=\"selectedFood\" ref=\"food\"></food>\n```\n\n## 子组件访问父组件的数据\n\n- a)在调用子组件时，v-bind绑定想要获取的父组件中的数据\n\n- b)在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据\n    - 总结：父组件通过props向下传递数据给子组件\n\n注：组件中的数据共有三种形式：data、props、computed\n\n## 父组件访问子组件的数据\n\n- a)在子组件中使用vm.$emit(事件名,数据)触发一个自定义事件，事件名自定义\n- b)父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据\n    - 总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件\n\n#### 父组件在标签使用@方法，监听子组件发射回来的函数\n\n```\naddFood(target) {\n        this.$emit('add', target);//把事件传递到父组件@add所绑定的函数\n    },\n```\n\n## 单向数据流\n\nprops是单向绑定的，当父组件的属性变化时，将传导给子组件，但是不会反过来\n而且不允许子组件直接修改父组件中的数据，报错\n\n解决方式：\n    - 方式1：如果子组件想把它作为局部数据来使用，可以将数据存入另一个变量中再操作，不影响父组件中的数据\n    - 方式2：如果子组件想修改数据并且同步更新到父组件，两个方法：\n        - a.使用.sync（1.0版本中支持，2.0版本中不支持，2.3版本又开始支持）\n            需要显式地触发一个更新事件`this.$emit('update:name','alice')`\n        - b.可以将父组件中的数据包装成对象，然后在子组件中修改对象的属性(因为对象是引用类型，指向同一个内存空间)，推荐\n\n\n##  非父子组件间的通信\n\n非父子组件间的通信，可以通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件\n```\nvar Event=new Vue();// 定义空实例（其他实例都会挂载到它上面）\nEvent.$emit(事件名,数据); // 触发当前实例上的事件。附加参数都会传给监听器回调。\nEvent.$on(事件名,data => {}); // 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。\n```","source":"_posts/组件间数据传递.md","raw":"---\ntitle: 组件间数据传递\ndate: 2018-05-03 15:16:02\ncategories:\n  - vue\ntags:\n  - vue组件\n  - 数据传递\n---\n\n# 父子组件\n\n在一个组件内部定义另一个组件，称为父子组件\n子组件只能在父组件内部使用\n默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的\n\n<!-- more -->\n\n# 组件间数据传递 （通信）\n\n```\n <food @add=\"addFood\" :food=\"selectedFood\" ref=\"food\"></food>\n```\n\n## 子组件访问父组件的数据\n\n- a)在调用子组件时，v-bind绑定想要获取的父组件中的数据\n\n- b)在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据\n    - 总结：父组件通过props向下传递数据给子组件\n\n注：组件中的数据共有三种形式：data、props、computed\n\n## 父组件访问子组件的数据\n\n- a)在子组件中使用vm.$emit(事件名,数据)触发一个自定义事件，事件名自定义\n- b)父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据\n    - 总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件\n\n#### 父组件在标签使用@方法，监听子组件发射回来的函数\n\n```\naddFood(target) {\n        this.$emit('add', target);//把事件传递到父组件@add所绑定的函数\n    },\n```\n\n## 单向数据流\n\nprops是单向绑定的，当父组件的属性变化时，将传导给子组件，但是不会反过来\n而且不允许子组件直接修改父组件中的数据，报错\n\n解决方式：\n    - 方式1：如果子组件想把它作为局部数据来使用，可以将数据存入另一个变量中再操作，不影响父组件中的数据\n    - 方式2：如果子组件想修改数据并且同步更新到父组件，两个方法：\n        - a.使用.sync（1.0版本中支持，2.0版本中不支持，2.3版本又开始支持）\n            需要显式地触发一个更新事件`this.$emit('update:name','alice')`\n        - b.可以将父组件中的数据包装成对象，然后在子组件中修改对象的属性(因为对象是引用类型，指向同一个内存空间)，推荐\n\n\n##  非父子组件间的通信\n\n非父子组件间的通信，可以通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件\n```\nvar Event=new Vue();// 定义空实例（其他实例都会挂载到它上面）\nEvent.$emit(事件名,数据); // 触发当前实例上的事件。附加参数都会传给监听器回调。\nEvent.$on(事件名,data => {}); // 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。\n```","slug":"组件间数据传递","published":1,"updated":"2019-06-16T08:33:47.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9u0dhgj00219kudcpk8cd31","content":"<script src=\"/assets/js/APlayer.min.js\"> </script><h1 id=\"父子组件\"><a href=\"#父子组件\" class=\"headerlink\" title=\"父子组件\"></a>父子组件</h1><p>在一个组件内部定义另一个组件，称为父子组件<br>子组件只能在父组件内部使用<br>默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的</p>\n<a id=\"more\"></a>\n<h1 id=\"组件间数据传递-（通信）\"><a href=\"#组件间数据传递-（通信）\" class=\"headerlink\" title=\"组件间数据传递 （通信）\"></a>组件间数据传递 （通信）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;food @add=&quot;addFood&quot; :food=&quot;selectedFood&quot; ref=&quot;food&quot;&gt;&lt;/food&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"子组件访问父组件的数据\"><a href=\"#子组件访问父组件的数据\" class=\"headerlink\" title=\"子组件访问父组件的数据\"></a>子组件访问父组件的数据</h2><ul>\n<li><p>a)在调用子组件时，v-bind绑定想要获取的父组件中的数据</p>\n</li>\n<li><p>b)在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据</p>\n<ul>\n<li>总结：父组件通过props向下传递数据给子组件</li>\n</ul>\n</li>\n</ul>\n<p>注：组件中的数据共有三种形式：data、props、computed</p>\n<h2 id=\"父组件访问子组件的数据\"><a href=\"#父组件访问子组件的数据\" class=\"headerlink\" title=\"父组件访问子组件的数据\"></a>父组件访问子组件的数据</h2><ul>\n<li>a)在子组件中使用vm.$emit(事件名,数据)触发一个自定义事件，事件名自定义</li>\n<li>b)父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据<ul>\n<li>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"父组件在标签使用-方法，监听子组件发射回来的函数\"><a href=\"#父组件在标签使用-方法，监听子组件发射回来的函数\" class=\"headerlink\" title=\"父组件在标签使用@方法，监听子组件发射回来的函数\"></a>父组件在标签使用@方法，监听子组件发射回来的函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addFood(target) &#123;</span><br><span class=\"line\">        this.$emit(&apos;add&apos;, target);//把事件传递到父组件@add所绑定的函数</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h2><p>props是单向绑定的，当父组件的属性变化时，将传导给子组件，但是不会反过来<br>而且不允许子组件直接修改父组件中的数据，报错</p>\n<p>解决方式：</p>\n<pre><code>- 方式1：如果子组件想把它作为局部数据来使用，可以将数据存入另一个变量中再操作，不影响父组件中的数据\n- 方式2：如果子组件想修改数据并且同步更新到父组件，两个方法：\n    - a.使用.sync（1.0版本中支持，2.0版本中不支持，2.3版本又开始支持）\n        需要显式地触发一个更新事件`this.$emit(&apos;update:name&apos;,&apos;alice&apos;)`\n    - b.可以将父组件中的数据包装成对象，然后在子组件中修改对象的属性(因为对象是引用类型，指向同一个内存空间)，推荐\n</code></pre><h2 id=\"非父子组件间的通信\"><a href=\"#非父子组件间的通信\" class=\"headerlink\" title=\"非父子组件间的通信\"></a>非父子组件间的通信</h2><p>非父子组件间的通信，可以通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Event=new Vue();// 定义空实例（其他实例都会挂载到它上面）</span><br><span class=\"line\">Event.$emit(事件名,数据); // 触发当前实例上的事件。附加参数都会传给监听器回调。</span><br><span class=\"line\">Event.$on(事件名,data =&gt; &#123;&#125;); // 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"父子组件\"><a href=\"#父子组件\" class=\"headerlink\" title=\"父子组件\"></a>父子组件</h1><p>在一个组件内部定义另一个组件，称为父子组件<br>子组件只能在父组件内部使用<br>默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的</p>","more":"<h1 id=\"组件间数据传递-（通信）\"><a href=\"#组件间数据传递-（通信）\" class=\"headerlink\" title=\"组件间数据传递 （通信）\"></a>组件间数据传递 （通信）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;food @add=&quot;addFood&quot; :food=&quot;selectedFood&quot; ref=&quot;food&quot;&gt;&lt;/food&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"子组件访问父组件的数据\"><a href=\"#子组件访问父组件的数据\" class=\"headerlink\" title=\"子组件访问父组件的数据\"></a>子组件访问父组件的数据</h2><ul>\n<li><p>a)在调用子组件时，v-bind绑定想要获取的父组件中的数据</p>\n</li>\n<li><p>b)在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据</p>\n<ul>\n<li>总结：父组件通过props向下传递数据给子组件</li>\n</ul>\n</li>\n</ul>\n<p>注：组件中的数据共有三种形式：data、props、computed</p>\n<h2 id=\"父组件访问子组件的数据\"><a href=\"#父组件访问子组件的数据\" class=\"headerlink\" title=\"父组件访问子组件的数据\"></a>父组件访问子组件的数据</h2><ul>\n<li>a)在子组件中使用vm.$emit(事件名,数据)触发一个自定义事件，事件名自定义</li>\n<li>b)父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据<ul>\n<li>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"父组件在标签使用-方法，监听子组件发射回来的函数\"><a href=\"#父组件在标签使用-方法，监听子组件发射回来的函数\" class=\"headerlink\" title=\"父组件在标签使用@方法，监听子组件发射回来的函数\"></a>父组件在标签使用@方法，监听子组件发射回来的函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addFood(target) &#123;</span><br><span class=\"line\">        this.$emit(&apos;add&apos;, target);//把事件传递到父组件@add所绑定的函数</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n<h2 id=\"单向数据流\"><a href=\"#单向数据流\" class=\"headerlink\" title=\"单向数据流\"></a>单向数据流</h2><p>props是单向绑定的，当父组件的属性变化时，将传导给子组件，但是不会反过来<br>而且不允许子组件直接修改父组件中的数据，报错</p>\n<p>解决方式：</p>\n<pre><code>- 方式1：如果子组件想把它作为局部数据来使用，可以将数据存入另一个变量中再操作，不影响父组件中的数据\n- 方式2：如果子组件想修改数据并且同步更新到父组件，两个方法：\n    - a.使用.sync（1.0版本中支持，2.0版本中不支持，2.3版本又开始支持）\n        需要显式地触发一个更新事件`this.$emit(&apos;update:name&apos;,&apos;alice&apos;)`\n    - b.可以将父组件中的数据包装成对象，然后在子组件中修改对象的属性(因为对象是引用类型，指向同一个内存空间)，推荐\n</code></pre><h2 id=\"非父子组件间的通信\"><a href=\"#非父子组件间的通信\" class=\"headerlink\" title=\"非父子组件间的通信\"></a>非父子组件间的通信</h2><p>非父子组件间的通信，可以通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Event=new Vue();// 定义空实例（其他实例都会挂载到它上面）</span><br><span class=\"line\">Event.$emit(事件名,数据); // 触发当前实例上的事件。附加参数都会传给监听器回调。</span><br><span class=\"line\">Event.$on(事件名,data =&gt; &#123;&#125;); // 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck9u0dhe700009kud1cp6c2i6","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhf0000f9kudnz39t1uh"},{"post_id":"ck9u0dheq00089kudv8axpbd0","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhf4000i9kudf61lmtux"},{"post_id":"ck9u0dhev000c9kudwm0th5pa","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhf7000k9kud9lepjmph"},{"post_id":"ck9u0dhef00029kud66ckbwtj","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhfa000o9kud62qtkzf1"},{"post_id":"ck9u0dhex000d9kud9c65z7lm","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhfc000r9kud2dokzo1n"},{"post_id":"ck9u0dhf2000h9kud9nr0o8ac","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhfg000w9kudtcz1uqr7"},{"post_id":"ck9u0dhem00069kudu9ek8c55","category_id":"ck9u0dhf0000e9kudvz8ism6p","_id":"ck9u0dhfk000z9kudlfg9m41x"},{"post_id":"ck9u0dhf6000j9kudsrufuq7g","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhfn00129kudmpxspzbk"},{"post_id":"ck9u0dheo00079kudhnsg2f0o","category_id":"ck9u0dhf8000l9kud03okiija","_id":"ck9u0dhfr00169kudrovit8ij"},{"post_id":"ck9u0dhf9000n9kud4p7ml3tf","category_id":"ck9u0dhfe000t9kudwxpdeh5k","_id":"ck9u0dhft00199kudggjz1opa"},{"post_id":"ck9u0dhfb000q9kudrckl8gvt","category_id":"ck9u0dhfe000t9kudwxpdeh5k","_id":"ck9u0dhfy001f9kudlr9lgy1i"},{"post_id":"ck9u0dhff000v9kudst6c80ls","category_id":"ck9u0dhfe000t9kudwxpdeh5k","_id":"ck9u0dhg4001k9kudnfcrwm3a"},{"post_id":"ck9u0dhfj000y9kudv64tzfrl","category_id":"ck9u0dhfy001e9kud8qvqkomf","_id":"ck9u0dhg9001q9kudv6mi5u2y"},{"post_id":"ck9u0dhfm00109kudbgh1oyhw","category_id":"ck9u0dhg4001l9kudvkpqvpzu","_id":"ck9u0dhgf001w9kudqamag4lx"},{"post_id":"ck9u0dhg7001p9kuds8gep29e","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhgi00209kud68ya0pwj"},{"post_id":"ck9u0dhgb001s9kud6vexjbsa","category_id":"ck9u0dhej00049kudzdjjvbm8","_id":"ck9u0dhgl00239kud7taj69q0"},{"post_id":"ck9u0dhfq00159kud8i2ouezy","category_id":"ck9u0dhg9001r9kudbjxa2wpx","_id":"ck9u0dhgm00259kudnf9plwut"},{"post_id":"ck9u0dhge001v9kudhohn0x6k","category_id":"ck9u0dhg4001l9kudvkpqvpzu","_id":"ck9u0dhgn00279kud1ma6t4zi"},{"post_id":"ck9u0dhgg001y9kudm3fy2has","category_id":"ck9u0dhg4001l9kudvkpqvpzu","_id":"ck9u0dhgo00299kudvewmsnm1"},{"post_id":"ck9u0dhfs00179kudtjb761pr","category_id":"ck9u0dhg9001r9kudbjxa2wpx","_id":"ck9u0dhgp002b9kud724ip84o"},{"post_id":"ck9u0dhgj00219kudcpk8cd31","category_id":"ck9u0dhg4001l9kudvkpqvpzu","_id":"ck9u0dhgq002d9kudv4d3q8q2"},{"post_id":"ck9u0dhfv001b9kud6de4vobx","category_id":"ck9u0dhg4001l9kudvkpqvpzu","_id":"ck9u0dhgs002g9kudxqu94b02"},{"post_id":"ck9u0dhg2001j9kudkl9h5xl8","category_id":"ck9u0dhgo00289kudkta6oeok","_id":"ck9u0dhgs002h9kudazqp7i08"}],"PostTag":[{"post_id":"ck9u0dhe700009kud1cp6c2i6","tag_id":"ck9u0dhel00059kud3uhenrnb","_id":"ck9u0dheu000b9kudauss6wnw"},{"post_id":"ck9u0dhef00029kud66ckbwtj","tag_id":"ck9u0dhes000a9kud7swd5veg","_id":"ck9u0dhfb000p9kudthckb6w3"},{"post_id":"ck9u0dhef00029kud66ckbwtj","tag_id":"ck9u0dhf1000g9kudrkn6of1z","_id":"ck9u0dhfd000s9kudanqbs40b"},{"post_id":"ck9u0dhem00069kudu9ek8c55","tag_id":"ck9u0dhf8000m9kud2ibm0vks","_id":"ck9u0dhfi000x9kud0sa0v3lp"},{"post_id":"ck9u0dheo00079kudhnsg2f0o","tag_id":"ck9u0dhfe000u9kud6cl8l2eg","_id":"ck9u0dhfp00149kudvxf62drz"},{"post_id":"ck9u0dheq00089kudv8axpbd0","tag_id":"ck9u0dhfn00139kudv1b7biif","_id":"ck9u0dhfw001c9kudeguk6fie"},{"post_id":"ck9u0dhev000c9kudwm0th5pa","tag_id":"ck9u0dhfu001a9kudgvihsd9t","_id":"ck9u0dhg1001i9kudmf1afv1n"},{"post_id":"ck9u0dhex000d9kud9c65z7lm","tag_id":"ck9u0dhfz001g9kud32pcrkkv","_id":"ck9u0dhg7001o9kud6q68oviz"},{"post_id":"ck9u0dhf2000h9kud9nr0o8ac","tag_id":"ck9u0dhg5001m9kudg2ad4kor","_id":"ck9u0dhgd001u9kudx4kzio71"},{"post_id":"ck9u0dhf6000j9kudsrufuq7g","tag_id":"ck9u0dhgc001t9kudttvs3uy1","_id":"ck9u0dhgk00229kudjptg50t5"},{"post_id":"ck9u0dhf9000n9kud4p7ml3tf","tag_id":"ck9u0dhgi001z9kud92gmfw8u","_id":"ck9u0dhgq002c9kudbb5f4q5w"},{"post_id":"ck9u0dhf9000n9kud4p7ml3tf","tag_id":"ck9u0dhgn00269kudr5ehza4o","_id":"ck9u0dhgq002e9kudmq31yjxl"},{"post_id":"ck9u0dhfb000q9kudrckl8gvt","tag_id":"ck9u0dhgp002a9kudw0b7ic74","_id":"ck9u0dhgu002k9kudyqc5mxjh"},{"post_id":"ck9u0dhfb000q9kudrckl8gvt","tag_id":"ck9u0dhgr002f9kud1wmdajm0","_id":"ck9u0dhgu002l9kudegz34zf9"},{"post_id":"ck9u0dhfb000q9kudrckl8gvt","tag_id":"ck9u0dhgt002i9kudsbiyqcai","_id":"ck9u0dhgv002n9kud142bdto0"},{"post_id":"ck9u0dhff000v9kudst6c80ls","tag_id":"ck9u0dhf8000m9kud2ibm0vks","_id":"ck9u0dhgw002o9kudr4opirmj"},{"post_id":"ck9u0dhff000v9kudst6c80ls","tag_id":"ck9u0dhgt002j9kudodxc8ic5","_id":"ck9u0dhgx002q9kudkmsrj197"},{"post_id":"ck9u0dhfm00109kudbgh1oyhw","tag_id":"ck9u0dhgv002m9kudp6sb36su","_id":"ck9u0dhgy002r9kudc713tu4m"},{"post_id":"ck9u0dhfq00159kud8i2ouezy","tag_id":"ck9u0dhgv002m9kudp6sb36su","_id":"ck9u0dhh0002u9kudvg5x71b9"},{"post_id":"ck9u0dhfq00159kud8i2ouezy","tag_id":"ck9u0dhgy002s9kud552hr1o8","_id":"ck9u0dhh0002v9kud5a8wocwa"},{"post_id":"ck9u0dhfs00179kudtjb761pr","tag_id":"ck9u0dhgv002m9kudp6sb36su","_id":"ck9u0dhh2002y9kudltqa8m6i"},{"post_id":"ck9u0dhfs00179kudtjb761pr","tag_id":"ck9u0dhh1002w9kudg9831855","_id":"ck9u0dhh2002z9kudri2v14se"},{"post_id":"ck9u0dhfv001b9kud6de4vobx","tag_id":"ck9u0dhgv002m9kudp6sb36su","_id":"ck9u0dhh300319kudi486qdh8"},{"post_id":"ck9u0dhg0001h9kud8ha2ls3k","tag_id":"ck9u0dhh300309kudldsxx0jn","_id":"ck9u0dhh500359kud81ag1we7"},{"post_id":"ck9u0dhg0001h9kud8ha2ls3k","tag_id":"ck9u0dhh400329kudjaxzqnd4","_id":"ck9u0dhh600369kud652yes6v"},{"post_id":"ck9u0dhg0001h9kud8ha2ls3k","tag_id":"ck9u0dhh400339kud7dbiagxf","_id":"ck9u0dhh600389kud54omvcrb"},{"post_id":"ck9u0dhg2001j9kudkl9h5xl8","tag_id":"ck9u0dhh500349kudd9fu6r5z","_id":"ck9u0dhh7003a9kudli2fgq1m"},{"post_id":"ck9u0dhg2001j9kudkl9h5xl8","tag_id":"ck9u0dhh600379kudrvzwt4wm","_id":"ck9u0dhh8003b9kudnr57489s"},{"post_id":"ck9u0dhg7001p9kuds8gep29e","tag_id":"ck9u0dhh700399kudv3qecm3y","_id":"ck9u0dhh9003d9kudfps1zrpl"},{"post_id":"ck9u0dhgb001s9kud6vexjbsa","tag_id":"ck9u0dhh8003c9kudynogmvbx","_id":"ck9u0dhha003f9kud7su9rmzz"},{"post_id":"ck9u0dhge001v9kudhohn0x6k","tag_id":"ck9u0dhh9003e9kudq6mxs511","_id":"ck9u0dhhb003h9kud867h55z7"},{"post_id":"ck9u0dhgg001y9kudm3fy2has","tag_id":"ck9u0dhgv002m9kudp6sb36su","_id":"ck9u0dhhc003j9kudsev6tf3j"},{"post_id":"ck9u0dhgj00219kudcpk8cd31","tag_id":"ck9u0dhh9003e9kudq6mxs511","_id":"ck9u0dhhd003l9kud78rq3qzt"},{"post_id":"ck9u0dhgj00219kudcpk8cd31","tag_id":"ck9u0dhhd003k9kudg62qcnj7","_id":"ck9u0dhhe003m9kuddj68r60m"}],"Tag":[{"name":"ES6","_id":"ck9u0dhel00059kud3uhenrnb"},{"name":"浏览器视图属性","_id":"ck9u0dhes000a9kud7swd5veg"},{"name":"页面内元素移动和滚动","_id":"ck9u0dhf1000g9kudrkn6of1z"},{"name":"CSS","_id":"ck9u0dhf8000m9kud2ibm0vks"},{"name":"ajax 网络请求 js","_id":"ck9u0dhfe000u9kud6cl8l2eg"},{"name":"循环语句 js","_id":"ck9u0dhfn00139kudv1b7biif"},{"name":"函数 js","_id":"ck9u0dhfu001a9kudgvihsd9t"},{"name":"对象 js","_id":"ck9u0dhfz001g9kud32pcrkkv"},{"name":"数组 js","_id":"ck9u0dhg5001m9kudg2ad4kor"},{"name":"面向对象 原型链 js","_id":"ck9u0dhgc001t9kudttvs3uy1"},{"name":"css","_id":"ck9u0dhgi001z9kud92gmfw8u"},{"name":"css模块化","_id":"ck9u0dhgn00269kudr5ehza4o"},{"name":"node","_id":"ck9u0dhgp002a9kudw0b7ic74"},{"name":"mongoodb","_id":"ck9u0dhgr002f9kud1wmdajm0"},{"name":"实战笔记","_id":"ck9u0dhgt002i9kudsbiyqcai"},{"name":"SASS","_id":"ck9u0dhgt002j9kudodxc8ic5"},{"name":"vue","_id":"ck9u0dhgv002m9kudp6sb36su"},{"name":"生命周期 计算属性","_id":"ck9u0dhgy002s9kud552hr1o8"},{"name":"vue实例属性 计算属性","_id":"ck9u0dhh1002w9kudg9831855"},{"name":"html","_id":"ck9u0dhh300309kudldsxx0jn"},{"name":"网页排版","_id":"ck9u0dhh400329kudjaxzqnd4"},{"name":"他人博客","_id":"ck9u0dhh400339kud7dbiagxf"},{"name":"https","_id":"ck9u0dhh500349kudd9fu6r5z"},{"name":"nginx","_id":"ck9u0dhh600379kudrvzwt4wm"},{"name":"基本包装类型 js","_id":"ck9u0dhh700399kudv3qecm3y"},{"name":"排序 js","_id":"ck9u0dhh8003c9kudynogmvbx"},{"name":"vue组件","_id":"ck9u0dhh9003e9kudq6mxs511"},{"name":"数据传递","_id":"ck9u0dhhd003k9kudg62qcnj7"}]}}