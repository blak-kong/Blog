<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【nestjs】控制器和路由]]></title>
    <url>%2F2020%2F05%2F14%2F%E3%80%90nestjs%E3%80%91%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[[TOC] 一、NestJS 中的控制器Nest 中的控制器层负责处理传入的请求, 并返回对客户端的响应。 控制器的目的是接收应用的特定请求。 路由机制控制哪个控制器接收哪些请求。 通常， 每个控制器有多个路由，不同的路由可以执行不同的操作。 ps：express、koa 需要引入 router 中间件。而 nestjs 自己做了封装，可以直接使用控制器做路由。 可以通过 NestCLi 创建控制器： nest g controller [控制器名字] 12// 补充：查看nest g 提供的所有方法nest g -help 二、NestJS 中的路由Nestjs 中没有单独配置路由的地方。 定义好控制器后 nestjs 会自动给我们配置对应的路由。 下面代码定义了一个新闻控制器。装饰器为@Controller(‘article’) 装饰器参数里面的’article’ 就是我们的路由。 如果我们要返回 index 方法里面的内容我们在浏览器输入 http://localhost:3000/article 如果我们要返回 add 方法里面的内容我们在浏览器输入 http://localhost:3000/article/add 12345678910111213import &#123; Controller, Get &#125; from &apos;@nestjs/common&apos;;@Controller(&apos;article&apos;)export class ArticleController &#123; @Get() index(): string &#123; return ‘这是 article 里面的 index’; &#125; @Get(‘add’) add(): string &#123; return ‘这是 article 里面的 index’; &#125;&#125; 关于 nest 的 return： 当请求处理程序返回 JavaScript 对象或数组时，它将自动序列化为 JSON。但是，当它返回一个字符串时，Nest 将只发送一个字符串而不是序列化它。 这使响应处理变得简单：只需要返回值，Nest 负责其余部分。 三、NestJS 中的 Get Post 以及通过方法参数装饰器获取传值1、首先看一个 Get Post 请求的例子注意我们使用 nestjs 内置装饰器的时候必须得在 @nestjs/common 模块下面引入对应的装饰器。 1234567891011121314// 引入装饰器import &#123; Controller, Get, Post &#125; from &apos;@nestjs/common&apos;;@Controller(&apos;cats&apos;)export class CatsController &#123; @Post() create(): string &#123; return &apos;This action adds a new cat&apos;; &#125; @Get() findAll(): string &#123; return &apos;This action returns all cats&apos;; &#125;&#125; Nestjs 也提供了其他 HTTP 请求方法的装饰器 @Put() 、@Delete()、@Patch()、 @Options()、 @Head()和 @All() 2、Nestjs 中获取请求参数在 Nestjs 中获取 Get 传值或者 Post 提交的数据的话我们可以使用 Nestjs 中的装饰器来获取。 装饰器 使用方法 @Request() req @Next() next @Session() req.session @Param(key?: string) req.params / req.params[key] @Body(key?: string) req.body / req.body[key] @Query(key?: string) req.query / req.query[key] @Headers(name?: string) req.headers / req.headers[name] 123456789101112131415161718192021import &#123; Controller, Get, Post &#125; from &apos;@nestjs/common&apos;;@Controller(&apos;news&apos;)export class NewsController &#123; @Get() getAbout(@Query() query):string &#123; console.log(query); //这里获取的就是所有的 Get 传值 return &apos;这是 getAbout&apos; &#125; @Get(&apos;list&apos;) getNews(@Query(‘id’) query):string &#123; console.log(query); //这里获取的就是 Get 传值里面的 Id 的值 return &apos;这是 getNews&apos; &#125; @Post(&apos;doAdd&apos;) async addNews(@Body() newsData)&#123; console.log(newsData); return &apos;增加新闻&apos; &#125;&#125; 四、NestJS 中的动态路由 当您需要接受动态数据作为请求的一部分时，具有静态路径的路由将不起作用（例如，GET /cats/1)获取具有 id 的 cat 1）。 为了定义带参数的路由，我们可以在路由中添加路由参数标记，以捕获请求 URL 中该位置的动态值。 @Get() 下面的装饰器示例中的路由参数标记演示了此用法。 可以使用 @Param() 装饰器访问以这种方式声明的路由参数，该装饰器应添加到函数签名中 12345@Get(&apos;:id&apos;)findOne(@Param() params): string &#123; console.log(params.id); return `This action returns a #$&#123;params.id&#125; cat`;&#125;]]></content>
      <tags>
        <tag>nestjs</tag>
        <tag>教程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【nestjs】创建nestjs项目]]></title>
    <url>%2F2020%2F05%2F14%2F%E3%80%90nestjs%E3%80%91%E5%88%9B%E5%BB%BAnestjs%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Nest 是一个渐进的 Node.js 框架，可以在 TypeScript 和 JavaScript (ES6、ES7、ES8)之上构 建高效、可伸缩的企业级服务器端应用程序。 Nest 基于 TypeScript 编写并且结合了 OOP（面向对象编程），FP（函数式编程）和 FRP （函数式响应编程）的相关理念。在设计上的很多灵感来自于 Angular，Angular 的很多模 式又来自于 Java 中的 Spring 框架，依赖注入、面向切面编程等，所以我们也可以认为： Nest 是 Node.js 版的 Spring 框架。 Nest 框架底层 HTTP 平台默认是基于 Express 实现的，所以无需担心第三方库的缺失。 Nest 旨在成为一个与平台无关的框架。 通过平台，可以创建可重用的逻辑部件，开发人员可以利用这些部件来跨越多种不同类型的应用程序。 从技术上讲，Nest 可以在创建适配器 后使用任何 Node HTTP 框架。 有两个支持开箱即用的 HTTP 平台：express 和 fastify。 您 可以选择最适合您需求的产品。 NestJs 的核心思想：就是提供了一个层与层直接的耦合度极小,抽象化极高的一个架构 体系。 Nestjs 目前在行业内具有很高的关注度，所以我们有必要学习一下 官网：https://nestjs.com/ 中文网站：https://docs.nestjs.cn/ GitHub: https://github.com/nestjs/nest nest 主要是学习，国内实际使用，还是优先选 eggjs（文档第一）[TOC] 安装 nestjs以下三种 nest 脚手架的全局安装方式，任选其一 npm i -g @nestjs/cli yarn global add @nestjs/cli cnpm i -g @nestjs/cli 创建项目 nest new nestdemo 接下来按提示，进入目录，运行即可]]></content>
      <tags>
        <tag>nestjs</tag>
        <tag>教程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【docker】部署第一个应用doclever]]></title>
    <url>%2F2020%2F05%2F07%2F%E3%80%90docker%E3%80%91%E9%83%A8%E7%BD%B2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8doclever%2F</url>
    <content type="text"><![CDATA[doclever 开源接口管理平台的 github 地址 为了方便部署和使用，我们使用 docker-compose 用法： ① 在文件夹下创建docker-compose.yml，填入以下内容 123456789101112131415161718192021222324version: &quot;2&quot;services: DOClever: image: lw96/doclever restart: always container_name: &quot;DOClever&quot; ports: - 20080:10000 volumes: - /svr/doclever/file:/root/DOClever/data/file - /svr/doclever/img:/root/DOClever/data/img - /svr/doclever/tmp:/root/DOClever/data/tmp environment: - DB_HOST=mongodb://mongo:27017/DOClever - PORT=10000 links: - mongo:mongo mongo: image: mongo:latest restart: always container_name: &quot;mongodb&quot; volumes: - /svr/doclever/db:/data/db ② 运行 docker-compose up -d]]></content>
  </entry>
  <entry>
    <title><![CDATA[2]]></title>
    <url>%2F2020%2F05%2F07%2F2%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[【docker】centos安装docker和docker-compose]]></title>
    <url>%2F2020%2F05%2F07%2F%E3%80%90docker%E3%80%91centos%E5%AE%89%E8%A3%85docker%E5%92%8Cdocker-compose%2F</url>
    <content type="text"><![CDATA[[TOC] docker 官方文档：centos 安装 docker一、先运行卸载，确保环境安全12345678sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 二、使用储存库安装在首次在新主机上安装 Docker 引擎之前，需要设置 Docker 存储库。之后，您可以从存储库中安装和更新 Docker。 设置存储库需要安装yum-utils包 它提供了yum-config-manager工具，并设置稳定储存库。 1sudo yum install -y yum-utils 123sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 三、安装 docker12# 安装最新版sudo yum install docker-ce docker-ce-cli containerd.io 12345678# 安装指定版# 查看版本列表yum list docker-ce --showduplicates | sort -r# 指定版本 有些版本有冒号# 例如docker-ce.x86_64 3:18.09.1-3.el7# 应该忽略冒号之前的内容，正确示例：docker-ce-18.09.1sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io 四、启动 docker sudo systemctl start docker 五、试运行 hello-world sudo docker run hello-world运行成功则安装成功，且能正常使用 docker-compose参考菜鸟教程：https://www.runoob.com/docker/docker-compose.html Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：https://github.com/docker/compose/releases。 运行以下命令以下载 Docker Compose 的指定版本 1.25.4，要安装其他版本的 Compose，请替换 1.24.1。 1curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 将可执行权限应用于二进制文件： 1chmod +x /usr/local/bin/docker-compose 创建软链： 1sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 测试是否安装成功 123docker-compose --version# 成功打印 docker-compose version 1.25.4, build 8d51620a 配置加速地址道客云：http://get.daocloud.io/ 道客云提供加速：https://www.daocloud.io/mirror 运行加速配置 curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io]]></content>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HTML】参考博客]]></title>
    <url>%2F2020%2F05%2F05%2F%E3%80%90HTML%E3%80%91%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[[toc] 一、 网页排版排版标签： &lt;h1&gt; &lt;p&gt; &lt;hr /&gt; 水平分割线标签 &lt;br /&gt; 换行标签 &lt;div&gt; &lt;span&gt; &lt;pre&gt; 预定义标签：原样输出内容 原文地址： HTML 标签：排版标签 二、字体与锚点链接个人简要笔记： 2-1.字体12345// b s u i 都是已经废弃的，现在用左边更语义化的标签strong == b // strong 粗体标签 语义: 定义重要性强调的文字del == s // del 中划线/删除线 语义(deleted): 定义被删除的文字ins == u // ins 下划线 语义(inseted): 定义插入的文字em == i // em 斜体 语义(emphasized): 定义强调的文字 2-2.锚点链接锚点链接即是通过给元素设置 id（设置标记），实现浏览器可以在链接访问网页的时候，在根据链接地址后面的#id参数，来自动定位到网页文档的对应位置。 锚链接的作用是在本页面或者其他页面的的不同位置进行跳转。 比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就可以利用锚链接。 不过锚链接没有动画，是立即跳转到对应位置。所以实际使用中，往往需要依赖别人封装好的插件。 例如navScroll.ja 参考原文地址： HTML 标签：字体标签和超链接 三、图片标签主要注意 align 属性 图片的 align 属性：图片和周围文字的相对位置。 属性取值可以是：bottom（默认）、center、top、left、right。 如果想实现图文混排的效果，请使用 align 属性，取值为 left 或 right。 我们来分别看一下这 align 属性的这几个属性值的区别。 1、align=””，图片和文字低端对齐。即默认情况下的显示效果 2、align=”center”：图片和文字水平方向上居中对齐。 3、align=”top”：图片与文字顶端对齐。 4、align=”left”：图片在文字的左边。 5、align=”right”：图片在文字的右边。 原文地址： HTML 标签：图片标签]]></content>
      <tags>
        <tag>html</tag>
        <tag>网页排版</tag>
        <tag>他人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HEXO】hexo部署到阿里云]]></title>
    <url>%2F2020%2F05%2F05%2F%E3%80%90HEXO%E3%80%91hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%2F</url>
    <content type="text"><![CDATA[从零搭建 Hexo 博客并部署阿里云服务器（奶妈级教学）_运维_Object 的博客-CSDN 博客 https://blog.csdn.net/NoCortY/article/details/99631249 有一个修改文件权限的坑，不了解 linux，卡了几小时。 如果遇到了，参考下面这篇文章，chmod 这一步改成 777 即可 chmod 修改文件权限 777 和 754_运维_pythonw 的博客-CSDN 博客 https://blog.csdn.net/pythonw/article/details/80263428]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HTTPS】记一次阿里云配置https]]></title>
    <url>%2F2020%2F05%2F05%2F%E3%80%90HTTPS%E3%80%91%E9%98%BF%E9%87%8C%E4%BA%91%E9%85%8D%E7%BD%AEhttps%2F</url>
    <content type="text"><![CDATA[[TOC] 给阿里云配置 https 很简单，只需要申请证书、然后安装到云服务器内的 web 服务器中，配置一下即可。 阿里云有官方案例，这里选择 nginx https://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO nginx 安装步骤我的 nginx 是使用 yum 安装的，所以安装目录在/etc/nginx yum install -y nginx 强烈推荐使用这种方式安装，非常方便 第一步：上传密钥到 nginx 目录下在 nginx 目录下运行 mkdir cert 创建密钥文件夹，把密钥文件都上传到该文件夹下。 第二步：配置 nginx我们使用 nginx 不应该任何时候都直接改动 nginx.conf，这里我有一个vhost/blog.conf的文件夹，里面配置了一个代理的网站。参考配置 1234567891011121314151617181920212223server &#123; listen 80; root /home/www/blog-website; server_name www.lzwlook.fun lzwlook.fun; rewrite ^/(.*)$ https://www.lzwlook.fun/$1 permanent; location / &#123; &#125;&#125;server &#123; listen 443 ssl; root /home/www/blog-website; server_name www.lzwlook.fun lzwlook.fun; ssl_certificate /etc/nginx/cert/3847437_www.lzwlook.fun.pem; ssl_certificate_key /etc/nginx/cert/3847437_www.lzwlook.fun.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; location / &#123; &#125;&#125; 三、重启 nginx1nginx -s reload 补充：使用 include 管理项目目前对于 nginx 不够了解，仅仅是文抄公。 这里再补一下，创建 vhost 文件夹后，nginx 中怎么生效。 我们还需要在 nginx.conf 中通过include，进行引入 1234http &#123; include /etc/nginx/conf.d/*.conf; # 这个是自带的 include /etc/nginx/vhost/*.conf; # 这是我们的配置&#125; 在 nginx.conf 文件中使用 include 引入文件夹和配置，会让项目的管理方便很多，这样只要给每个新增项目建一个 \*\*.conf 文件就好了。]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2020%2F04%2F15%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>test</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node+mongoodb学习]]></title>
    <url>%2F2019%2F04%2F07%2Fnode%2Bmongoodb%E5%AD%A6%E4%B9%A0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[[toc] 说明此系列将在一周内更新完，不记细节，只记基础知识点 1.服务器启动Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。 使用 Express 可以快速地搭建一个完整功能的网站。 Express 框架核心特性： 可以设置中间件来响应 HTTP 请求。 定义了路由表用于执行不同的 HTTP 请求动作。 可以通过向模板传递参数来动态渲染 HTML 页面。 启动文件：server.js12345678910const express = require("express");const express = require("express");const app = express(); // 实例化const port = process.env.PORT || 5000; // 端口号app.get("/", (req, res) =&gt; &#123; res.send("hello world!") // 默认输出&#125;)app.listen(port, () =&gt; &#123; // 监听 console.log(`Server running on port $&#123;port&#125;`);&#125;) 此时推荐安装插件nodemon，它默认会监听当前目录，重启Express 2.mongodb创建数据库数据库：config/keys.js123456789module.exports = &#123; // 本地写法，无需登录 mongoURI: "mongodb://localhost:27017/testData"&#125;module.exports = &#123; // 远程写法 mongoURI: "mongodb://名称:密码@远程 数据库地址/testData"&#125; 回到启动文件：server.js123456789const mongoose = require("mongoose") // 引入mongo// DB configconst db = require("./config/keys").mongoURI; // 引入数据库地址// connect to mongodb 链接mongodbmongoose.connect(db, &#123;useNewUrlParser: true&#125;) .then(() =&gt; console.log("MongoDB Connected 666") .catch(err =&gt; console.log(err)) 访问mongodb成功后，node命令行会输出MongoDB Connected 666 3.创建接口接口目录:router/api/user.js以下为最简单的router接口访问，只能输出消息。1234567891011// login &amp; registerconst express = require("express");const router = express.Router();// $route GET api/users/test// @desc 返回的请求的json数据// @access publicrouter.get("/test", (req, res) =&gt; &#123; res.json(&#123;msg: "login works"&#125;)&#125;) 如果需要实现更多功能，则需要编写逻辑，甚至安装更多插件配合。例：123const bcrypt = require("bcrypt"); // 加密const gravatar = require('gravatar'); // 全球公共头像const jwt = require("jsonwebtoken"); // 生成token 4.为什么接口要用到Schema在数据库中，schema（模式）是数据库的组织和结构。也就是数据结构。 1.在创建接口后，根据字段需要，创建schema（模式）。 2.该接口在前后端的字段传值，必须符合schema（模式）的定义。 例：123456789101112131415161718192021222324252627const mongoose = require("mongoose")const Schema = mongoose.Schema;// Create Schema 模型const UserSchema = new Schema(&#123; name: &#123; type: String, required: true &#125;, email: &#123; type: String, required: true &#125;, password: &#123; type: String, required: true &#125;, avatar: &#123; type: String &#125;, date: &#123; type: Date, default: Date.now &#125;&#125;)module.exports = User = mongoose.model("users", UserSchema); 5.接口调试工具：postman1.谷歌应用商店搜索postman，安装使用 2.直接百度搜索，下载安装软件 5.1.Express中间件body-parser当express使用get以外的请求时，需要安装中间件body-parser处理不同类型的请求 body-parser实现的·要点如下： 处理不同类型的请求体：比如text、json、urlencoded等，对应的报文主体的格式不同。 处理不同的编码：比如utf8、gbk等。 处理不同的压缩类型：比如gzip、deflare等。 其他边界、异常的处理。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>mongoodb</tag>
        <tag>实战笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件间数据传递]]></title>
    <url>%2F2018%2F05%2F03%2F%E7%BB%84%E4%BB%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[父子组件在一个组件内部定义另一个组件，称为父子组件子组件只能在父组件内部使用默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的 组件间数据传递 （通信）1&lt;food @add=&quot;addFood&quot; :food=&quot;selectedFood&quot; ref=&quot;food&quot;&gt;&lt;/food&gt; 子组件访问父组件的数据 a)在调用子组件时，v-bind绑定想要获取的父组件中的数据 b)在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据 总结：父组件通过props向下传递数据给子组件 注：组件中的数据共有三种形式：data、props、computed 父组件访问子组件的数据 a)在子组件中使用vm.$emit(事件名,数据)触发一个自定义事件，事件名自定义 b)父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据 总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件 父组件在标签使用@方法，监听子组件发射回来的函数123addFood(target) &#123; this.$emit(&apos;add&apos;, target);//把事件传递到父组件@add所绑定的函数 &#125;, 单向数据流props是单向绑定的，当父组件的属性变化时，将传导给子组件，但是不会反过来而且不允许子组件直接修改父组件中的数据，报错 解决方式： - 方式1：如果子组件想把它作为局部数据来使用，可以将数据存入另一个变量中再操作，不影响父组件中的数据 - 方式2：如果子组件想修改数据并且同步更新到父组件，两个方法： - a.使用.sync（1.0版本中支持，2.0版本中不支持，2.3版本又开始支持） 需要显式地触发一个更新事件`this.$emit(&apos;update:name&apos;,&apos;alice&apos;)` - b.可以将父组件中的数据包装成对象，然后在子组件中修改对象的属性(因为对象是引用类型，指向同一个内存空间)，推荐 非父子组件间的通信非父子组件间的通信，可以通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件123var Event=new Vue();// 定义空实例（其他实例都会挂载到它上面）Event.$emit(事件名,数据); // 触发当前实例上的事件。附加参数都会传给监听器回调。Event.$on(事件名,data =&gt; &#123;&#125;); // 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue组件</tag>
        <tag>数据传递</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件component]]></title>
    <url>%2F2018%2F05%2F03%2F%E7%BB%84%E4%BB%B6component%2F</url>
    <content type="text"><![CDATA[[toc] 什么是组件？组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码组件是自定义元素（对象） 定义组件的方式方式1：先创建组件构造器，然后由组件构造器创建组件（全局）1234561.使用Vue.extend()创建一个组件构造器 var MyComponent=Vue.extend(&#123; template:&apos;&lt;h3&gt;Hello World&lt;/h3&gt;&apos; &#125;);2.使用Vue.component(标签名,组件构造器)，根据组件构造器来创建组件 Vue.component(&apos;hello&apos;,MyComponent); 方式2：直接创建组件（全局）直接把组件构造器写在{}里定义 123Vue.component(&apos;my-world&apos;,&#123; template:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos; &#125;); 方式3：局部组件（常用）123456// 挂载到单页面里，只在当前页有效components:&#123; &apos;my-world&apos;,&#123; template:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos; &#125;&#125; 组件中添加数据在组件中存储数据时，必须以函数形式，函数返回一个对象12345678910components:&#123; //局部组件 &apos;my-world&apos;:&#123; template:&apos;&lt;h3&gt;&#123;&#123;age&#125;&#125;&lt;/h3&gt;&apos;, data()&#123; return &#123; age:25 &#125; &#125; &#125; &#125; 引用模板组件化开发中，引用模板为直接创建新文件，作为组件。组件名为文件名。 123456789101112131415161718&lt;template id=&quot;wbs&quot;&gt; &lt;!-- &lt;template&gt;必须有且只有一个根元素 --&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;components:&#123; &apos;my-hello&apos;:&#123; name:&apos;wbs17022&apos;, //指定组件的名称，默认为标签名，可以不设置 template:&apos;#wbs&apos;, data()&#123; return &#123; msg:&apos;欢迎来到南京网博&apos;, arr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;] &#125; &#125; &#125; &#125; 动态加载组件&lt;component :is=&quot;挂载点&quot;&gt; 多个组件使用同一个挂载点，然后动态的在它们之间切换 12345678&lt;button @click=&quot;flag=&apos;my-hello&apos;&quot;&gt;显示hello组件&lt;/button&gt;&lt;button @click=&quot;flag=&apos;my-world&apos;&quot;&gt;显示world组件&lt;/button&gt;&lt;component :is=&quot;flag&quot;&gt;&lt;/component&gt;data:&#123; flag:&apos;my-hello&apos; &#125; &lt;keep-alive&gt;缓存组件标签的组件实例能够被在它们第一次被创建的时候缓存下来。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[练习：vue自定义指令]]></title>
    <url>%2F2018%2F05%2F02%2F%E7%BB%83%E4%B9%A0%EF%BC%9Avue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这是很少会更新的附带完整代码的博客。究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;练习：自定义指令&lt;/title&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; #itany div&#123; width: 100px; height: 100px; position:absolute; &#125; #itany .hello&#123; background-color:red; top:0; left:0; &#125; #itany .world&#123; background-color:blue; top:0; right:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;itany&quot;&gt; &lt;div class=&quot;hello&quot; v-drag&gt;itany&lt;/div&gt; &lt;div class=&quot;world&quot; v-drag&gt;网博&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // vue全局自定义指令 Vue.directive(&apos;drag&apos;,function(el)&#123; el.onmousedown=function(e)&#123; // 获取鼠标点击处分别与div左边和上边的距离：鼠标位置-div位置 var disX=e.clientX-el.offsetLeft; var disY=e.clientY-el.offsetTop; // console.log(disX,disY); //包含在onmousedown里面，表示点击后才移动，为防止鼠标移出div，使用document.onmousemove document.onmousemove=function(e)&#123; // 获取移动后div的位置：鼠标位置-disX/disY // 因为offset获取的是左边和上边，所以移动需使用减法 var l=e.clientX-disX; var t=e.clientY-disY; el.style.left=l+&apos;px&apos;;// 记得要加px像素单位,否则不移动 el.style.top=t+&apos;px&apos;; &#125; //停止移动，鼠标抬起触发 document.onmouseup=function(e)&#123; // 清空鼠标按住状态 document.onmousemove=null; // 销毁自身 document.onmouseup=null; &#125; &#125; &#125;); var vm=new Vue(&#123; el:&apos;#itany&apos;, data:&#123; msg:&apos;welcome to itany&apos;, username:&apos;alice&apos; &#125;, methods:&#123; change()&#123; this.msg=&apos;欢迎来到南京网博&apos; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSSOM视图模式]]></title>
    <url>%2F2018%2F05%2F02%2FCSSOM%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CSSOM视图模块(CSSOM View Module)它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性 包括布局框定位、视区宽度和元素滚动。 以下就是一些API属性的相关内容，包括兼容性，使用，测试等。 window视图属性（几乎没用）这些属性可以hold住整个浏览器窗体大小。微软则将这些API称为“Screenview 接口”。 语法：window.xxxxx 它们一般没什么用，仅作了解： innerWidth 属性和 innerHeight 属性 表示获取window窗体的内部宽高，不包括用户界面元素，比如窗框。 pageXOffset 属性和 pageYOffset 属性 表示整个浏览器窗体的大小，包括任务栏等。 screenX 属性和 screenY 属性 表示整个页面滚动的像素值（水平方向的和垂直方向的） outerWidth 属性和 outerHeight 属性 浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。 Screen视图属性（几乎没用） 语法：screen.xxxxx availWidth和availHeight 显示器可用宽高，不包括任务栏之类的东东。 width和height 表示显示器屏幕的宽高。 元素视图属性 (重点)使用方法，自己获取页面元素，然后对元素应用方法。 clientLeft和clientTop（事件内容的位置） 表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。 clientWidth和clientHeight（事件内容的大小） 表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。 offsetLeft和offsetTop（检测位置） 表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。 offsetWidth和offsetHeight（检测大小） 整个元素的尺寸（包括边框）。 scrollLeft和scrollTop（用于滚动） 表示元素滚动的像素大小。可读可写。 scrollWidth和scrollHeight（整个内容的宽高-包括滚动） 表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。 鼠标位置 （重要） 语法：event.clientX clientX,clientY 相对于window，为鼠标相对于window的偏移。 用于点击移动 offsetX, offsetY 表示鼠标相对于当前被点击元素padding box的左上偏移值，各个浏览器的兼容性五花八门. 获取鼠标在元素内的位置 pageX, pageY（兼容性不好） 为鼠标相对于document的坐标。 screenX, screenY 鼠标相对于显示器屏幕的偏移坐标。 clientXY+offsetXY组合用法 clienX-offsetX = 元素不超出页面 因为window宽度就是浏览器宽度。]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>浏览器视图属性</tag>
        <tag>页面内元素移动和滚动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue动画]]></title>
    <url>%2F2018%2F05%2F01%2Fvue%E5%8A%A8%E7%94%BB%E4%B8%8Eanimations%E5%8A%A8%E7%94%BB%E5%BA%93%2F</url>
    <content type="text"><![CDATA[单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 vue的动画也是使用css3实现的。只是写法有些不一样，我们需要将代码嵌套在中 过渡的类名而与css动画最大的区别，我们需要使用vue自带的模板语法通过Vue自带的类名，我们可以定义css动画的触发时机 在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。 在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。 在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。 在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。 在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。 在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。 在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 1234567891011121314151617181920.fade-enter-active,.fade-leave-active&#123; transition:all 3s ease; &#125; .fade-enter-active&#123; opacity:1;// 动画开始状态 width:300px; height:300px; &#125; .fade-leave-active&#123; opacity:0; width:50px; height:50px; &#125; /* .fade-enter需要放在.fade-enter-active的后面 */ .fade-enter&#123; opacity:0; /*初始状态（css重叠样式表，属性覆盖，必须放后面）*/ width: 100px; height: 100px; &#125; javaScript 钩子可以在属性中声明 JavaScript 钩子 1234567891011&lt;transition name=&quot;fade&quot; @before-enter=&quot;beforeEnter&quot;// 动画进入之前 @enter=&quot;enter&quot;// 动画进入 @after-enter=&quot;afterEnter&quot;// 动画进入之后 @before-leave=&quot;beforeLeave&quot;// 动画即将离开之前 @leave=&quot;leave&quot;// 动画离开 @after-leave=&quot;afterLeave&quot;// 动画离开之后 &gt; &lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt; &lt;/transition&gt; 钩子函数的触发时机1234567891011121314151617181920212223methods:&#123; beforeEnter(el)&#123; // alert(&apos;动画进入之前&apos;); &#125;, enter()&#123; // alert(&apos;动画进入&apos;); &#125;, afterEnter(el)&#123; // alert(&apos;动画进入之后&apos;); el.style.background=&apos;blue&apos;; &#125;, beforeLeave()&#123; // alert(&apos;动画即将之前&apos;); &#125;, leave()&#123; // alert(&apos;动画离开&apos;); &#125;, afterLeave(el)&#123; // alert(&apos;动画离开之后&apos;); el.style.background=&apos;red&apos;; &#125; &#125; 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。 当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 在vue中使用animations.css动画库只需要引入animations.css，然后写法如下，在标签中直接定义开始动画和离开动画即可 123&lt;transition enter-active-class=&quot;animated fadeInLeft&quot; leave-active-class=&quot;animated fadeOutRight&quot;&gt; &lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt; &lt;/transition&gt; 多元素动画对于原生标签可以使用 v-if/v-else 。 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lt;transition&gt; 组件中的多个元素设置 key 也是一个更好的实践。1234&lt;transition enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt; &lt;p v-show=&quot;flag&quot; :key=&quot;1&quot;&gt;itany&lt;/p&gt; &lt;p v-show=&quot;flag&quot; :key=&quot;2&quot;&gt;网博&lt;/p&gt;&lt;/transition&gt; 我们也可以通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else 12345&lt;transition&gt; &lt;button v-bind:key=&quot;isEditing&quot;&gt; &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125; &lt;/button&gt;&lt;/transition&gt; 或者使用多个if 列表过渡同时渲染整个列表&lt;transition-group&gt; 不同于 ，它会以一个真实元素呈现：默认为一个 。你也可以通过 tag 特性更换为其他元素。 内部元素 总是需要 提供唯一的 key 属性值 1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;itany&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;transition-group enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt; &lt;p v-for=&quot;(v,k) in arr2&quot; :key=&quot;k&quot; v-show=&quot;flag&quot;&gt; &#123;&#123;v&#125;&#125; &lt;/p&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script&gt; var vm=new Vue(&#123; el:&apos;#itany&apos;, data:&#123; flag:true, arr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;,&apos;alice&apos;,&apos;alex&apos;,&apos;mark&apos;], name:&apos;&apos; &#125;, computed:&#123; arr2:function()&#123; var temp=[]; this.arr.forEach(val =&gt; &#123; // Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 if(val.includes(this.name))&#123; // 判断是否存在传入字符，存在则push元素 temp.push(val); &#125; &#125;); return temp; &#125; &#125; &#125;); &lt;/script&gt; 检测元素数组元素是否存在：Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue自定义指定]]></title>
    <url>%2F2018%2F05%2F01%2Fvue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[[TOC] 自定义属性/** 自定义全局指令 注：使用指令时必须在指名名称前加前缀v-，即v-指令名称*/ 1234567891011121314151617Vue.directive(&apos;hello&apos;,&#123; bind()&#123; //常用！！ alert(&apos;指令第一次绑定到元素上时调用，只调用一次，可执行初始化操作&apos;); &#125;, inserted()&#123; alert(&apos;被绑定元素插入到DOM中时调用&apos;); &#125;, update()&#123; alert(&apos;被绑定元素所在模板更新时调用&apos;); &#125;, componentUpdated()&#123; alert(&apos;被绑定元素所在模板完成一次更新周期时调用&apos;); &#125;, unbind()&#123; alert(&apos;指令与元素解绑时调用，只调用一次&apos;); &#125;&#125;); 全局注册自定义指令12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&apos;focus&apos;, &#123; // 当被绑定的元素插入到 DOM 中时调用 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 局部注册123456789directives: &#123;// 自定义指令名 focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 在模板中使用1&lt;input v-focus&gt; 钩子函数参数 常用参数为el和binding 钩子函数 参数1 参数2 参数3bind: function (el, binding, vnode) 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。可以为它绑定事件、也可以直接修改dom属性。 binding：一个对象。包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 12345Vue.directive(&apos;demo&apos;, &#123;// demo为指令名 bind: function (el, binding, vnode) &#123; &#125;&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的实例属性和方法]]></title>
    <url>%2F2018%2F05%2F01%2Fvue%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] vue实例的属性和方法仅记录部分大部分时候是随学随用，但是学到了就来记录。 实例属性和方法 == 组件实例和方法 != 全局属性和方法 另外，在组件实例的methods方法中不能使用全局Vue方法 属性vm.属性名 获取data中的属性1//console.log(vm.msg); vm.$el 获取vue实例关联的元素12// console.log(vm.$el); //DOM对象// vm.$el.style.color=&apos;red&apos;; vm.$data 获取数据对象data12// console.log(vm.$data);// console.log(vm.$data.msg); vm.$options 获取自定义属性123// console.log(vm.$options.name);// console.log(vm.$options.age);// vm.$options.show(); vm.$refs 获取所有添加ref属性的元素123// console.log(vm.$refs);// console.log(vm.$refs.hello); //DOM对象// vm.$refs.hello.style.color=&apos;blue&apos;; 方法vm.$mount() 手动挂载vue实例// vm.$mount(&apos;#itany&apos;); var vm=new Vue({ data:{ msg:&apos;欢迎来到南京网博&apos;, name:&apos;tom&apos; } }).$mount(&apos;#itany&apos;); vm.$destroy() 销毁实例这个列出来只是了解一下，官方也建议使用v-if或v-for以数据驱动的方式控制子组件和生命周期 // vm.$destroy(); vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM//修改数据 vm.name=&apos;汤姆&apos;; //DOM还没更新完，Vue实现响应式并不是数据发生改变之后DOM立即变化，需要按一定的策略进行DOM更新，需要时间！！ // console.log(vm.$refs.title.textContent); vm.$nextTick(function(){ //DOM更新完成，更新完成后再执行此代码 console.log(vm.$refs.title.textContent); }); vm.$set(target,key,value) 添加对象的属性和值关于dom // vm.$set(this.food, ‘count’, 1);// 注意：在methods方法中不能使用Vue.set// 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新// Tip:Vue.set()在methods中可以写成this.$set() vm.$delete(target,key) 删除对象的属性// vm.$delete(this.food, ‘count’);// 注意：在methods方法中不能使用Vue.delete vm.$watch( expOrFn, callback, [options] ) 观察者模式参数：监听对象，回调方法，选项（deep/immediate） 观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。 实例使用方法1234//方式1：使用vue实例提供的$watch()方法 vm.$watch(&apos;name&apos;,function(newValue,oldValue)&#123; console.log(&apos;name被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue); &#125;); vue提供的选项方法123456789101112watch:&#123; //方式2：使用vue实例提供的watch选项 age:(newValue,oldValue) =&gt; &#123; console.log(&apos;age被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue); &#125;, // 对对象监视，需要使用深度监视 user:&#123; handler:(newValue,oldValue) =&gt; &#123; console.log(&apos;user被修改啦，原值：&apos;+oldValue.name+&apos;，新值：&apos;+newValue.name); &#125;, deep:true //深度监视，当对象中的属性发生变化时也会监视 &#125;&#125; vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。]]></content>
      <categories>
        <category>前端 vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue实例属性 计算属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期和计算属性]]></title>
    <url>%2F2018%2F05%2F01%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[生命周期vue有八个生命周期，但只有两个是常用的新手阶段只需要掌握created()和mounted()即可 created(): 实例已经创建完成，并且已经进行数据观测和事件配置此时可用于添加数据、配置事件 mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示此时可用于操作html和dom元素 123456789101112131415161718192021222324beforeCreate()&#123; alert(&apos;组件实例刚刚创建，还未进行数据观测和事件配置&apos;);&#125;,created()&#123; //常用！！！ alert(&apos;实例已经创建完成，并且已经进行数据观测和事件配置&apos;);&#125;,beforeMount()&#123; alert(&apos;模板编译之前，还没挂载&apos;);&#125;,mounted()&#123; //常用！！！ alert(&apos;模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示&apos;);&#125;,beforeUpdate()&#123; alert(&apos;组件更新之前&apos;);&#125;,updated()&#123; alert(&apos;组件更新之后&apos;);&#125;,beforeDestroy()&#123; alert(&apos;组件销毁之前&apos;);&#125;,destroyed()&#123; alert(&apos;组件销毁之后&apos;);&#125; 计算属性 computedcomputed：对于两个以上操作的复杂逻辑，应当使用计算属性（不建议仅有一个操作的简单逻辑）。 一个简单实例-反转字符串html代码1&lt;p&gt;&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt; 这里会输出olleh js代码12345678910111213141516var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; // 绑定的字符串 &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) // split(&apos;&apos;)把每个字符分割，形成数组 // reverse()反转数组 // join(&apos;&apos;)拼接数组元素，返回字符串 &#125; &#125;&#125;) 通过上面的实例，我们看到在计算属性中，当我们定义方法时，是使用了计算属性的一个getter。但是getter和setter往往是一对的，分别是只读只写。所以这个实例，是不是漏了什么呢？ 没错，它还不足以讲解计算属性，这里只是说明了它可以通过调用使用。 另外，我们可以像绑定普通属性一样在模板中绑定计算属性。123console.log(vm.reversedMessage) // =&gt; &apos;olleH&apos;vm.message = &apos;Goodbye&apos;console.log(vm.reversedMessage) // =&gt; &apos;eybdooG&apos; 计算属性缓存 vs 方法我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。 computed计算属性 必须有计算methods方法 一般用于处理事件、改变状态。计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。这就意味着只要数据还没有发生改变，即便多次访问方法，计算属性也会立即返回之前的计算结果，而不必再次执行函数。这也意味着计算属性将不再更新。 计算属性 vs 侦听属性Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch 然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。 计算属性的 setter计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter。通过给set传值，可以间接改变该计算属性的值。 （绝对不能直接给计算属性赋值）1234567891011121314151617181920212223242526272829data:&#123; //普通属性 num1:8&#125;,computed:&#123; //计算属性 num2:&#123; get:function()&#123; console.log(&apos;num2：&apos;+new Date()); return this.num1-1; &#125;, set:function(val)&#123; // val=111 // console.log(&apos;修改num2值&apos;); // this.num2=val; 不能直接赋值num2，那不是计算,会死循环溢出 this.num1=val;// 赋值修改num1 &#125; &#125;&#125;,methods:&#123; change()&#123; // this.msg=&apos;i love you&apos;; this.num1=666;// 赋值修改num1 &#125;, getNum2()&#123; console.log(new Date()); return this.num1-1; &#125;, change2()&#123; this.num2=111; //传入set &#125;&#125; 侦听器一旦发生改变，就会运行，watch中可以自定义函数1234567891011data: &#123; obj: &apos;&apos;, answer: &apos;请输入!&apos; &#125;,watch: &#123; // 如果 `obj` 发生改变，这个函数就会运行 obj: function (新的值, 旧的值) &#123; this.answer = &apos;每次监听到getAnswer()发生变化，就把这句话赋值给answer，反正还是会被getAnswer()覆盖&apos; this.getAnswer()// 还在methods方法里自定义要监听调用的函数。 &#125; &#125;,]]></content>
      <categories>
        <category>前端 vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>生命周期 计算属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax学习]]></title>
    <url>%2F2018%2F05%2F01%2Fajax%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[[toc] ajaxXMLHttpRequest 是 AJAX 的基础。 XMLHttpRequest 对象 XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 通过它，你可以很容易的取回一个 URL 上的资源数据。 尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。而且除了 HTTP ，它还支持 file 和 ftp 协议。 构造函数 XMLHttpRequest()构造函数初始化一个 XMLHttpRequest 对象。必须在所有其他方法被调用前调用构造函数。 语法： var myRequest = new XMLHttpRequest(); 此时 myRequest 已经成为一个XMLHttpRequest 对象，可以使用XMLHttpRequest的方法。 向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：12xmlhttp.open(&quot;GET&quot;,url,true);xmlhttp.send(null); open(method,url,async) //规定请求的类型、URL 以及是否异步处理请求。 method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步） send(string) // 将请求发送到服务器。 string：仅用于 POST 请求（如果不需要发送请求，则必须传入Null） GET请求如果您希望通过 GET 方法发送信息，请向 URL 添加信息（在地址后面加问号，然后再添加）：12xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;,true);xmlhttp.send(); POST请求如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：123xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;); 方法: setRequestHeader(header,value) 向请求添加 HTTP 头。 header: 规定头的名称 value: 规定头的值 我们使用 GET 还是 POST？GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 异步如何设置 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true。 通过 AJAX，JavaScript 无需等待服务器的响应，而是： 在等待服务器响应时执行其他脚本 当响应就绪后对响应进行处理 接收响应一个完整的http响应是由状态码，响应头集合，和响应主题组成。在收到响应的消息后，这些都是可以通过xhr对象的属性和方法所使用。它们主要有以下4个属性 12345responseText;作为相应主题返回的文本，（文本形式）responseXML;如果响应的内容是‘text/xml’或者是哦application/xml;属性中将会保存，响应数据的xml形式。DOM文档形式。status: http的状态码（数字形式）statusText;http状态说明，（文本形式） ajax原生123456789101112131415161718192021222324252627282930313233343536373839//**********第一步, 获得一个xhr对象************* var xmlHttpReq = null;// 声明一个空对象用来装入XMLHttpRequest if (window.XMLHttpRequest)&#123;// ie7 以上的浏览器XMLHttpRequest是window的子对象 xmlHttpReq = new XMLHttpRequest();// 实例化一个XMLHttpRequest &#125;else (window.ActiveXObject)&#123;// IE5 IE6是以ActiveXObject的方式引入XMLHttpRequest的 xmlHttpReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; if(xhr != null)&#123; // 如果对象实例化成功 //设置回调函数 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; // 确定响应已经成功返回 // 200可作为成功标志, 304表示请求资源没有修改, 可直接使用浏览器缓存 if ((xhr.status&gt;=200 &amp;&amp; xhr.status &lt; 300 ) || xhr.status == 304)&#123; alert(xhr.responseText); // 请求成功，服务器返回的数据 &#125; else &#123; alert( &quot;请求失败: &quot; + xhr.status); &#125; &#125; &#125;//************第二步: 启动请求.****************** // open方法接收三个参数: 要发送的请求类型(get,post等), 请求的url和是否异步发送请求的布尔值 xhr.open(&quot;get&quot;,&quot;test.php&quot;,true); // 调用open()方法并采用异步方式. 如果第三个参数是false, 同步执行, 则js代码会等到服务器响应之后再继续执行//*************第三步: 发送数据******************* // send方法接收一个参数,即要作为请求主体发送的数据. 如果不需要通过请求主体发送数据, 则必须传入null. 因为这个参数对有些浏览器是必须的 xhr.send(null); // 因为使用get方式提交，所以可以使用null参调用// 如果要设置请求头部信息,必须在调用open()方法之后且调用send()方法之前调用setRequestHeader() readyStatus的五个阶段 0：未初始化。尚未调用open()方法 1：启动。已经调用open()方法，尚未调用send()方法 2：发送。已经调用send()方法，尚未接收到响应 3：接收。已经接收部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。【一般只需检查这个阶段】 获得的数据在responseText或responseXML属性中, 后者需要XML解析 ajax跨域三种跨域方法：一、一般使用封装好的jsonp jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。普通方法: 给html标签添加脚本属性1234567891011121314151617function addScriptTag(src) &#123; // 创建script元素标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); // 给script标签，设置标签属性 script.src = src; // 把script标签添加成为body的子标签 document.body.appendChild(script);&#125;// 提供jsonp服务的url地址，并调用foo函数window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;; jqurey方法：12345678910 $.ajax(&#123; url: &quot;url&quot;, type: &quot;GET&quot;, dataType: &quot;jsonp&quot;, //指定服务器返回的数据类型 jsonp: &quot;cb&quot;, //指定参数名称 jsonpCallback: &quot;showData&quot;, //指定回调函数名称 success: function (data) &#123; console.log(&quot;调用success&quot;); &#125;&#125;); 二、CORS是跨源资源分享（在后端设置头部支持，允许跨域） Access-Control-Allow-Origin:* 三、设置代理请求（不会） vue使用Ajax本身不支持发送AJAX请求，需要使用vue-resource、axios等插件实现 axios使用Ajax注意：axios不支持跨域 参考github上的官方文档，[options]是可以使用的方法1234567891011121314axios([options]) axios.get(url[,options]); 传参方式： 1.通过url传参 2.通过params选项传参axios.post(url,data,[options]); axios默认发送数据时，数据格式是Request Payload，并非我们常用的Form Data格式， 所以参数必须要以键值对形式传递，不能以json形式传参 传参方式： 1.自己拼接为键值对 2.使用transformRequest，在请求发送前将请求数据进行转换 3.如果使用模块化开发，可以使用qs模块进行转换axios本身并不支持发送跨域的请求，没有提供相应的API，作者也暂没计划在axios添加支持发送跨域请求，所以只能使用第三方库 get请求示例123456789101112131415161718192021写法一（只能用这个，参考上面的传参方式）axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123;// 成功 console.log(response); &#125;) .catch(function (error) &#123;// 失败 console.log(error); &#125;);写法二axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 使用vue-resource发送跨域请求基本用法12345678使用this.$http发送请求 this.$http.get(url, [options]) this.$http.head(url, [options]) this.$http.delete(url, [options]) this.$http.jsonp(url, [options]) this.$http.post(url, [body], [options]) this.$http.put(url, [body], [options]) this.$http.patch(url, [body], [options]) 12345678this.$http.jsonp(&apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&apos;,&#123; params:&#123; wd:this.keyword &#125;, jsonp:&apos;cb&apos; &#125;).then(resp =&gt; &#123; this.myData=resp.data.s; &#125;);]]></content>
      <categories>
        <category>JS学习笔记 vue学习</category>
      </categories>
      <tags>
        <tag>ajax 网络请求 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象（原型链）]]></title>
    <url>%2F2018%2F05%2F01%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[[toc] 原型及原型链原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 proto 属性指向创建它的构造函数的 prototype（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、proto 这五个概念入手。 函数对象前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。下面示例代码对「普通对象」和「函数对象」进行了区分。 普通对象12var o1 = &#123;&#125;;var o2 = new Object(); 函数对象123function f1()&#123;&#125;;var f2 = function()&#123;&#125;;var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;); 简单的说，凡是使用 function 关键字或 Function 构造函数创建的对象都是函数对象。而且，只有函数对象才拥有 prototype （原型）属性。 constructor 构造函数函数还有一种用法，就是把它作为构造函数使用。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。 构造原型1234567891011121314&lt;script&gt;// 构造函数首字母应大写，便于区分普通函数function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; console.log(this.name); &#125;;&#125;var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);&lt;script/&gt; new 操作符要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 构造函数与其他函数的唯一区别，就在于调用它们的方式不同。 归根结底，使用 new 关键字，可以在后面跟随一个函数调用。 只要通过 new 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。 构造函数的问题构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。 函数名是指针，使用构造函数调用创建新对象，解决了内存覆盖问题：但所有对象都是深拷贝，并没有变方便。没有必要创建两个完成同样任务的 Function 实例 prototype 原型我们创建的每个函数都有一个 prototype（原型）属性。使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。 12345678910111213141516function Person()&#123;&#125;Person.prototype.name = &quot;Stone&quot;;Person.prototype.age = 28;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); // &quot;Stone&quot;var person2 = new Person();person2.sayName(); // &quot;Stone&quot;console.log(person1.sayName == person2.sayName); // true 此例子有缺陷，因为共享了内存。 若是原型链中存在引用类型，那么一个值改变，所有值都会跟着改变。 理解原型对象在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针（potor）。就拿前面的例子来说，Person.prototype.constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。 此时，我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。 这就是js的屏蔽方法。当为对象实例添加一个属性时，这个属性就会屏蔽原型中保存的同名属性 更简单的原型语法为了摆脱每添加一个属性和方法就要敲一遍 Person.prototype为了减少不必要的输入，也为了从视觉上更好地封装原型的功能常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象12345678910function Person()&#123;&#125;Person.prototype = &#123; name : &quot;Stone&quot;, age : 28, job: &quot;Software Engineer&quot;, sayName : function () &#123; console.log(this.name); &#125;&#125;; 注意：此时 constructor 属性不再指向 Person 了。尽管仍能使用。 解决办法是把它加回去constructor : Person 注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。 123456789101112131415161718function Person()&#123;&#125;Person.prototype = &#123; name : &quot;Stone&quot;, age : 28, job : &quot;Software Engineer&quot;, sayName : function () &#123; console.log(this.name); &#125;&#125;; // 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器// Object.defineProperty(obj, prop, descriptor)// 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123; enumerable: false, value: Person&#125;); obj: 要在其上定义属性的对象。prop: 要定义或修改的属性的名称。descriptor: 将被定义或修改的属性描述符。 原型的动态性由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。1234567var friend = new Person();Person.prototype.sayHi = function()&#123; console.log(&quot;hi&quot;);&#125;;friend.sayHi(); // &quot;hi&quot;（没有问题！） 其原因可以归结为实例与原型之间的松散连接关系。因为实例与原型之间的连接只不过是一个指针，而非一个副本. 但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]的 __potoy__ 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 请记住：实例中的指针仅指向原型，而不指向构造函数。 原型对象的问题原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，问题很突出 123456789101112131415161718192021function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name : &quot;Stone&quot;, age : 28, job : &quot;Software Engineer&quot;, friends : [&quot;ZhangSan&quot;, &quot;LiSi&quot;], sayName : function () &#123; console.log(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(&quot;WangWu&quot;);console.log(person1.friends); // &quot;ZhangSan,LiSi,WangWu&quot;console.log(person2.friends); // &quot;ZhangSan,LiSi,WangWu&quot;console.log(person1.friends === person2.friends); // true 引用类型单独占一块堆内存,连原型也只是指针指向数组 构造函数和原型结合构造函数用于定义实例属性，而原型用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。下面的代码重写了前面的例子 123456789101112131415161718192021function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;ZhangSan&quot;, &quot;LiSi&quot;];&#125;Person.prototype = &#123; constructor : Person, sayName : function()&#123; console.log(this.name); &#125;&#125;var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);person1.friends.push(&quot;WangWu&quot;);console.log(person1.friends); // &quot;ZhangSan,LiSi,WangWu&quot;console.log(person2.friends); // &quot;ZhangSan,LiSi&quot;console.log(person1.friends === person2.friends); // false 构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 proto当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 proto , 指向构造函数的原型。123function Person()&#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true Object.proto = Object.prototype; 原型链JavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 简单回顾一下构造函数、原型和实例的关系： 每个构造函数都有一个原型对象(调用对象)原型对象都包含一个指向构造函数的指针(prototype)而实例都包含一个指向原型对象的内部指针。(proto)]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>面向对象 原型链 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本包装类型]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本包装类型为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：Boolean、Number 和 String。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。来看下面的例子。 12var s1 = &quot;some text&quot;;var s2 = s1.substring(2); 这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。 其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。 创建 String 类型的一个实例； 在实例上调用指定的方法； 销毁这个实例。 可以将以上三个步骤想象成是执行了下列 JavaScript 代码。 123var s1 = new String(&quot;some text&quot;);var s2 = s1.substring(2);s1 = null; 经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。 引用类型与基本包装类型的主要区别就是对象的生存期。 使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。 （使用 new 操作符创建的String引用类型的实例，优于自动创建的基本包装类型） 这意味着我们不能在运行时为基本类型值添加属性和方法。 以下为简略概括，关于基本包装类型 Boolean类型任何时候，我们都不建议直接实例化Boolean类型。它虽然是与布尔值对应的引用类型，但是他无法用作布尔值判断，意义不明。 Number类型大多数时候，我们不建议直接实例化Number类型，原因和Boolean类型一样，影响类型判断。Number类型是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。 例子：var numberObject = new Number(10) // 十进制 关于Number类型，我们可以进行数制转换、字符转换。 但一般不建议使用，我们应该尽量使用Number对象及其方法。（需要用到时，百度即可）（Number类型和Number对象是不一样的，Number对象是基本类型的实例）（Number类型是与数字值对应的引用类型，它只是基本类型的数值的实例。） String类型String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。 var stringObject = new String(“hello world”); String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。 String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。 来看下面的例子。12var stringValue = &quot;hello world&quot;;console.log(stringValue.length); // 11 应该注意的是，即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。例如： 12var stringValue = &quot;大家好&quot;;console.log(stringValue.length); // 3 String 类型提供了很多方法，用于辅助完成对 JavaScript 中字符串的解析和操作。 方法 字符方法访问字符串中特定位置的字符：charAt() 和 charCodeAt()这两个方法都接收一个参数，即基于0的字符位置。 12var stringValue = &quot;hello world&quot;;console.log(stringValue.charAt(1)); // &quot;e&quot; charAt(): 以单字符字符串的形式返回给定位置的那个字符charCodeAt(): 返回字符编码 ECMAScript 5 还定义了另一个访问个别字符的方法。在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。12var stringValue = &quot;hello world&quot;;console.log(stringValue[1]); // &quot;e&quot; 字符串操作方法concat() 用于将一或多个字符串拼接起来12345var stringValue = &quot;hello &quot;;var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;);console.log(result); // &quot;hello world!&quot;console.log(stringValue); // &quot;hello&quot; 基于子字符串创建新字符串的方法：slice()、substr() 和 substring()slice(start,end) 从已有的数组中返回选定的元素。substr(start,length) 在字符串中抽取从 start 下标开始的指定数目的字符。substring(start,stop) 提取字符串中介于两个指定下标之间的字符。 字符串位置方法从字符串中查找子字符串的方法：indexOf() 和 lastIndexOf()这两个方法都接收两个参数：要查找的项和（可选的）查找起点位置的索引 indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。lastIndexOf() 返回一个指定的字符串值最后出现的位置。 前面学过，indexOf()查找时会判断是否全等，详情氪查看js循环的笔记。 它们在比较第一个参数与数组中的每一项时，会使用全等操作符； trim() 方法–清除前后空格这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。 字符串大小写转换方法toLowerCase() 和 toUpperCase() 小写和大写 字符串的模式匹配方法replace() 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。12var str=&quot;a blue and a blue car&quot;;var n=str.replace(/blue/g,&quot;red&quot;); // a red and a red car split() 用于把一个字符串分割成字符串数组。12&quot;2:3:4:5&quot;.split(&quot;:&quot;) //将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]&quot;|a|b|c&quot;.split(&quot;|&quot;) //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] localeCompare() 方法–比较两个字符串fromCharCode() 方法–接收一或多个字符编码，然后将它们转换成一个字符串。]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>基本包装类型 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数理解]]></title>
    <url>%2F2018%2F04%2F30%2Fjs%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[toc] 函数函数是一段代码，它只定义一次，但可以被执行或调用任意次。在 JavaScript 里，函数即对象，程序可以随意操控它们。（万物皆对象） 函数定义在 JavaScript 中，函数实际上是对象，每个函数都是 Function 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。 函数通常有以下3中定义方式。例如： 123456789101112// 写法一：函数声明（推荐写法）function sum (num1, num2) &#123; return num1 + num2;&#125;// 写法二：函数表达式（推荐写法）var sum = function(num1, num2)&#123; return num1 + num2;&#125;;// 写法三：Function 构造函数（不推荐写法）var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;); 由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。 换句话说，一个函数可能会有多个名字。例如： 12345678910function sum(num1, num2)&#123; return num1 + num2;&#125;console.log(sum(10,10)); // 20var anotherSum = sum;console.log(anotherSum(10,10)); // 20sum = null;console.log(anotherSum(10,10)); // 20 没有重载–函数名是指针将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。(因为改变函数体内容，只是指向改变，内存并没有清空)123456789function addSomeNumber(num)&#123; return num + 100;&#125;function addSomeNumber(num, num2) &#123; return num + 200;&#125;var result = addSomeNumber(100); // 300 显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别：(因为改变函数体内容，只是指向改变，内存并没有清空)123456789var addSomeNumber = function (num)&#123; return num + 100;&#125;;addSomeNumber = function (num, num2) &#123; return num + 200;&#125;;var result = addSomeNumber(100); // 300 函数声明与函数表达式–变量提升解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；—-变量提升至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。 例如：1234console.log(sum(10,10)); // 20function sum(num1, num2)&#123; return num1 + num2;&#125; 以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。1234console.log(sum(10,10)); // Uncaught TypeError: sum is not a functionvar sum = function(num1, num2)&#123; return num1 + num2;&#125;; 作为值的函数因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。123function callSomeFunction(someFunction, someArgument)&#123; return someFunction(someArgument);&#125; 这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。12345678910111213function add10(num)&#123; return num + 10;&#125;var result1 = callSomeFunction(add10, 10);console.log(result1); // 20function getGreeting(name)&#123; return &quot;Hello, &quot; + name;&#125;var result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;);console.log(result2); // &quot;Hello, Nicholas&quot; 函数的形参和实参在函数内部，有两个特殊的对象：arguments 和 this。其中，arguments 是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。请看下面这个非常经典的阶乘函数。1234567function factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1) &#125;&#125; 定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee1234567function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125; 在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：123456789// 这里需要结合上一段代码var trueFactorial = factorial;factorial = function()&#123;// 重置了factorial函数指向 return 0;&#125;;console.log(trueFactorial(5)); // 120console.log(factorial(5)); // 0 arguments用法：使用在函数体中，可用 arguments.callee 指向拥有这个 arguments 对象的函数。函数的属性和方法JavaScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length 和 prototype。其中，length 属性表示函数希望接收的命名参数的个数，也就是形参个数。 不过这不重要。 接下来要说的才是属性与方法。JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为： 12345/*apply()方法*/function.apply(thisObj[, argArray])/*call()方法*/function.call(thisObj[, arg1[, arg2[, [,...argN]]]]); 它们各自的定义： apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。 例如：B.apply(A, arguments);即A对象应用B对象的方法。 call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。 例如：B.call(A, args1,args2);即A对象调用B对象的方法。 它们的共同之处：都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。 它们的不同之处： apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。 call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。 基本用法1234567891011121314function add(a,b)&#123; return a+b; &#125;function sub(a,b)&#123; return a-b; &#125;var a1 = add.apply(sub,[4,2]); //sub应用add的方法var a2 = sub.apply(add,[4,2]);alert(a1); //6 alert(a2); //2/*call的用法*/var a2 = add.call(sub,4,2); //sub调用add的方法alert(a2); //6 关卡：123456789// 挑战一，合并任意个数的字符串var concat = function()&#123; var result = &apos;&apos;; for(var i = 0; i &lt; arguments.length; i ++)&#123; // 遍历arguments实参长度 result += arguments[i]; // 把所有实参元素累加 &#125; return result;&#125;console.log(concat(&apos;st&apos;,&apos;on&apos;,&apos;e&apos;)); // stone]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>函数 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组方法]]></title>
    <url>%2F2018%2F04%2F29%2Fjs%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[toc] 使用数组字面量创建数组（推荐）1var empty = []; 使用 new 关键字创建数组使用 new 关键字调用构造函数 Array() 是创建数组的另一种方法。我们可以用三种方式调用构造函数。例如：12345678// 调用时没有参数var a = new Array();// 调用时有一个数值参数，它指定长度var a = new Array(10); // 显式指定多个数组元素或者数组的一个非数值元素var a = new Array(5, 4, 3, 2, 1, &quot;testing&quot;); 稀疏数组稀疏数组就是包含从0开始的不连续索引的数组。数组遍历经典for循环 123456var keys = Object.keys(o); // 获得 o 对象属性名组成的数组var values = [] // 在数组中存储匹配属性的值for(var i = 0; i &lt; keys.length; i++) &#123; // 对于数组中每个索引 var key = keys[i]; // 获得索引处的键值 values[i] = o[key]; // 在 values 数组中保存属性值&#125; for-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。forEach(值,索引,数组对象本身) 循环所有元素并回调，传入的参数仅表示是否回调具体案例参考另一篇博客，javascript循环语句 数组检测Array.isArray() es5语法：给定一个未知的对象，判定它是否为数组。数组转换转换方法toString()：当调用数组的 toString() 方法，会返回以逗号分隔数组中每个值的字符串。为了创建这个字符串会调用数组每一项的 toString() 方法。 转换方法toLocaleString()：基本同上。但内置本地字符串格式转换功能（时间格式转换）。123var sd=new Date()sd.toLocaleString() //&quot;2017/2/15 上午11:21:31&quot;sd.toString() //&quot;Wed Feb 15 2017 11:21:31 GMT+0800 (CST)&quot; join() 可以使用不同的分隔符来构建字符串数组。123var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];console.log(colors.join(&quot;,&quot;)); // red,green,blueconsole.log(colors.join(&quot;||&quot;)); // red||green||blue split() 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。第一个参数是指定字符串或正则表达式。若传入第二个参数，可以指定数组长度12&quot;2:3:4:5&quot;.split(&quot;:&quot;) //将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]&quot;|a|b|c&quot;.split(&quot;|&quot;) //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 栈方法和队列方法栈方法（后进先出）：push() 和 pop()// 越后面加入数组的，越先被pop()移除push() 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。pop() 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。 12345678910var colors = []; // 创建一个数组var count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项console.log(count); // 2，数组的长度count = colors.push(&quot;black&quot;); // 推入另一项console.log(count); // 3，数组的长度var item = colors.pop(); // 取得最后一项console.log(item); // &quot;black&quot;,返回移除的项console.log(colors.length); // 2，数组的长度 队列方法（先进先出）push() 和 shift()push() 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。shift() 从数组前端移除第一项，减少数组的 length 值，然后返回移除的项。 反向队列方法（反方向先进先出）unshift()和pop()unshift() 把任意数量参数逐个添加到数组前端，然后返回length 值pop() 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。 重排序方法数组中有两个重排序的方法：reverse() 和 sort()。 reverse() 方法可以反转数组元素的顺序。sort() 方法可以按升序或降序排列数组元素。sort具体用法，可以查看深入理解js对象排序-sort() 通用代码演示123456789101112var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 数组操作concat() 基于当前数组中的所有项创建一个新数组。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 12345var a = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var b = a.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);//基于a创建新数组console.log(a); // red,green,blueconsole.log(b); // red,green,blue,yellow,black,brown slice() 它能够基于当前数组中的一或多个项创建一个新数组。slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。 在只有一个参数的情况下，slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。 注意，slice() 方法不会影响原始数组。 123456var a = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var a1 = a.slice(1);var a2 = a.slice(1,4);console.log(a1); // green,blue,yellow,purpleconsole.log(a2); // green,blue,yellow splice() 它的主要用途是向数组的中部插入元素,或者进行删除、替换写法：Array.splice(起始位置，删除数量，插入) 只写前两项，是从指定位置开始删除不写第二项，写第三项，是插入元素三个都写，则是替换指定位置的元素 位置方法ECMAScript 5 为数组实例添加了两个位置方法：indexOf() 和 lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）查找起点位置的索引 indexOf() 方法从数组的开头（位置0）开始向后查找lastIndexOf() 方法则从数组的末尾开始向前查找。注意：最终返回的索引，都是数组开头往后算。 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1。它们在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用 === 一样）。 例如：1234567891011var numbers = [1,2,3,4,5,4,3,2,1];console.log(numbers.indexOf(4)); // 3 从前往后，查找数组第一个4console.log(numbers.lastIndexOf(4)); // 5 从后往前，查找数组第一个4console.log(numbers.indexOf(4, 4)); // 5 从前往后，从索引4开始查找元素4console.log(numbers.lastIndexOf(4, 4)); // 3 从后往前，从索引-4开始往前查找元素4var person = &#123; name: &quot;Nicholas&quot; &#125;;var people = [&#123; name: &quot;Nicholas&quot; &#125;];var morePeople = [person];console.log(people.indexOf(person)); // -1 没找到 -1console.log(morePeople.indexOf(person)); // 0 找到索引 0 迭代方法ECMAScript 5 为数组定义了5个迭代方法。 每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象。传入这些方法中的函数会接收三个参数：值、索引和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。 通用使用方法 array1.xxxx(callbackfn[, thisArg]) array1必需。一个数组对象。 callbackfn必需。一个接受最多三个参数的函数。对于数组中的每个元素，filter 方法都会调用 callbackfn 函数一次。 thisArg可选。可在 callbackfn 函数中为其引用 this 关键字的对象。如果省略 thisArg，则 undefined 将用作 this 值。 以下是这5个迭代方法的作用。 every() 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true。 filter() 过滤器：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach() 元素遍历：对数组中的每一项运行给定函数。这个方法没有返回值。 map() 数组映射：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some() 对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true。 5个迭代方法的用法： every() 确定数组的所有成员是否满足指定的测试。array1.every(callbackfn[, thisArg]) 判断数组元素是否全部都能整除2 123456789101112131415161718192021// 定义回调函数function CheckIfEven(value, index, ar) &#123; // CheckIfEven(值，索引，数组本身) if (value % 2 == 0) &#123; // 取余，检查是否能整除2 return true; &#125; else &#123; return false; &#125;&#125;// 创建数组 Create an array.var numbers = [2, 4, 5, 6, 8];// 检查回调函数是否返回所有的数组值if (numbers.every(CheckIfEven)) &#123; console.log(&quot;All are even.&quot;); // true,满足指定的测试时运行 &#125; else &#123; console.log(&quot;Some are not even.&quot;); // false,不满足指定的测试时运行 &#125;// 输出(Output): Some are not even. filter() 返回数组中的满足回调函数中指定的条件的元素array1.filter(callbackfn[, thisArg]) 以下代码为，使用过滤器判断数组中的质数 123456789101112131415161718192021// 定义回调函数function CheckIfPrime(value, index, ar) &#123; // Math.floor向下取整 // Math.sqrt() 方法可返回一个数的平方根。 high = Math.floor(Math.sqrt(value)) + 1; // 平方根向下取整再加一 for (var div = 2; div &lt;= high; div++) &#123; // 判断是否能否被2以上的数整除 if (value % div == 0) &#123; // 如果能被整除，则不是质数 return false; &#125; &#125; return true;&#125;// 创建初始数组var numbers = [31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53];// 获取原始数组中的质数var primes = numbers.filter(CheckIfPrime);console.log(primes); // [31,37,41,43,47,53] forEach() 为数组中的每个元素执行指定操作。array1.forEach(callbackfn[, thisArg]) 若不写回调函数，则默认操作为遍历所有元素。 以下代码为，数组求和 12345678910// 创建数组var numbers = [10, 11, 12];// 调用每个数组元素，并回调函数var sum = 0;numbers.forEach( function addNumber(value) &#123; sum += value; &#125; // 所有元素加起来);console.log(sum); // 输出(Output): 33 map() 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。array1.map(callbackfn[, thisArg]) 以下代码为，数组取余 1234567891011121314151617// 定义一个包含取余属性的对象// 原型方法定义var obj = &#123; divisor: 10, // 除以10 remainder: function (value) &#123; return value % this.divisor; &#125;&#125;// 创建数组var numbers = [6, 12, 25, 30];// 获取余数var result = numbers.map(obj.remainder, obj);console.log(result);// 输出(Output): [6,2,5,0] some() 确定指定的回调函数是否为数组中的任何元素均返回 true。array1.some(callbackfn[, thisArg]) some()判断是否存在至少一个数符合条件 12345678910111213// 创建一个函数，如果值为true，则返回true。var isOutsideRange = function (value) &#123; // 检测是否超出范围 return value &lt; this.minimum || value &gt; this.maximum;&#125;// 创建数组.var numbers = [6, 12, 16, 22, -12];// 范围对象是“这个”对象。var range = &#123; minimum: 10, maximum: 20 &#125;;console.log(numbers.some(isOutsideRange, range)); // true 存在小于10和大于20的数 挑战 数组去重// 挑战一，一维数组 思路使用indexOf(i)检测新数组newArr里有没有包含Arr里的i项如果没有则向newArr里添加Aii[i]项如果有则跳过；不做任何操作。 12345678910111213141516var arr = [2,3,4,2,3,5,6,4,3,2];var unique = function(arr)&#123; var result = []; // 创建空数组，用于存放新数组 arr.forEach(function(item)&#123; // indexOf()会使用全等操作符,判断item索引与遍历数组中所有元素都不相等，才运行 if(result.indexOf(item) &lt; 0)&#123; // 此处代码，只有数组索引小于0（数组中不存在），才会运行 // 所以可以达到去重效果 result.push(item); &#125; &#125;); return result;&#125;console.log(unique(arr)); // [2,3,4,5,6] // 挑战二（二维数组）1234567891011121314151617181920var arr = [2,3,4,[2,3,4,5],3,5,[2,3,4,2],4,3,6,2];var unique = function(arr)&#123; var result = []; // 创建空数组，用于存放新数组 arr.forEach(function(item) &#123; // 遍历数组元素给item if (Array.isArray(item)) &#123; // 判定item是否为数组，只有数组才能往下运行 item.forEach(function(i) &#123; // 把item中的数组，遍历给i // indexOf()会使用全等操作符,判断i索引与遍历数组中所有元素都不相等，才能往下运行 if (result.indexOf(i) &lt; 0) &#123; result.push(i); &#125; &#125;); &#125; else &#123; if (result.indexOf(item) &lt; 0) &#123; result.push(item); &#125; &#125; &#125;); return result;&#125;console.log(unique(arr)); // [2,3,4,5,6]]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>数组 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象理解]]></title>
    <url>%2F2018%2F04%2F29%2Fjs%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[toc] 创建对象对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。 JavaScript 的「三类对象」和「两类属性」进行区分： 内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。 自有属性（own property），是直接在对象中定义的属性。继承属性（inherited property），是在对象的原型对象中定义的属性。 使用对象字面量创建对象（推荐）12345678910// 推荐写法var person = &#123; name : &quot;stone&quot;, age : 28&#125;;// 也可以写成var person = &#123;&#125;;person.name = &quot;stone&quot;;person.age = 28; 使用 new 关键字创建对象new 关键字创建并初始化一个新对象。关键字 new 后跟随一个函数调用。这里的函数称做构造函数（constructor），构造函数用以初始化一个新创建的对象。JavaScript 语言核心中的原始类型都包含内置构造函数。例如：123var person = new Object();person.name = &quot;stone&quot;;person.age = 28; 只要在 new 后面跟随一个已创建的对象，就可以继承它的原型属性。 使用 Object.create() 函数创建对象Object.create() 创建一个具有指定原型且可选择性地包含指定属性的对象。 Object.create(prototype, descriptors) 参数prototype必需。 要用作原型的对象。 可以为 null。descriptors可选。 包含一个或多个属性描述符的 JavaScript 对象。“数据属性”是可获取且可设置值的属性。数据属性描述符包含 value(值) 特性，以及 writable(可写)、enumerable（可枚举） 和 configurable（可配置） 特性。如果未指定最后三个特性，则它们默认为 false。只要检索或设置该值，“访问器属性”就会调用用户提供的函数。访问器属性描述符包含 set 特性和/或 get 特性。 下面的示例创建使用 null 原型的对象并添加两个可枚举的属性。 123456789101112131415161718192021var newObj = Object.create(null, &#123; size: &#123; value: &quot;large&quot;, enumerable: true &#125;, shape: &#123; value: &quot;round&quot;, enumerable: true &#125; &#125;);console.log(newObj.size + &quot;&lt;br/&gt;&quot;);console.log(newObj.shape + &quot;&lt;br/&gt;&quot;);console.log(Object.getPrototypeOf(newObj));// Object.getPrototypeOf 函数可获取原始对象的原型。// 输出(Output):// large// round// null 原型（prototype）所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。Object.prototype 是所有对象的原型对象，也是原型链终点，但是它默认是null的。Object.prototype.proto为null （普通的对象）Object.prototype 的存在价值就是象征Object类型本身,是根对象 通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。 因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。 没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。 所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。 这一系列链接的原型对象就是所谓的「原型链（prototype chain）」。 注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性函数的prototype属性:在定义函数时自动添加的,默认值是一个空的Object对象对象的proto属性:创建对象是自动创建、添加的,默认值为其对应构造函数的prototype属性值 属性的查询和设置1234//设置person.name = &quot;sophie&quot;; // 赋值//查询console.log(person.name); // &quot;sophie&quot; 属性的访问错误查询一个不存在的属性并不会报错，如果不存在，则返回undefined 删除属性JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。 in 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true。 1234var o = &#123; x: 1 &#125;console.log(&quot;x&quot; in o); // true，x是o的属性console.log(&quot;y&quot; in o); // false，y不是o的属性console.log(&quot;toString&quot; in o); // true，toString是继承属性 除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false。 propertyIsEnumerable() 检测对象有自有属性且可枚举性为 true 时它才返回 true。 枚举属性除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。 for-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如：12345var o = &#123;x:1, y:2, z:3&#125;; // 三个可枚举的自有属性o.propertyIsEnumerable(&quot;toString&quot;); // false，内置方法不可枚举for (p in o) &#123; // 遍历属性 console.log(p); // 输出x、y和z，不会输出toString&#125; 有许多实用工具库给 Object.prototype 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。 为了过滤继承的属性，我们可以对 for-in 进行改造只许加入两个判断hasOwnProperty()这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。typeof 判断对象类型1234for(p in o) &#123; if (!o.hasOwnProperty(p)) continue; // 跳过继承的属性 if (typeof o[p] === &quot;function&quot;) continue; // 跳过函数方法&#125; 除了 for-in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。 第一个是 Object.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。 第二个是 Object.getOwnPropertyNames()，它和 Ojbect.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。 属性的 getter 和 setter由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」它不同于「数据属性（data property）」，数据属性只有一个简单的值。并且和数据属性不同，存取器属性不具有可写性（writable attribute）。 12345678var o = &#123; // 普通的数据属性 data_prop: value, // 存取器属性都是成对定义的函数 get accessor_prop() &#123; /*这里是函数体 */ &#125;, set accessor_prop(value) &#123; /* 这里是函数体*/ &#125;&#125;; 存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。 序列化对象（JSON）对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。JSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串JSON.parse() 用于将一个 JSON 字符串转换为对象。 关卡枚举题 总结创建对象的三种方式，在默认情况下，都一样。但是在涉及原型的情况下 new 和 create() ，就产生了区别。至于字面量方法，则是无法继承原型。 new 关键字创建并初始化一个新对象。关键字 new 后跟随一个函数调用，新对象会继承它的原型属性。 工厂模式、构造函数模式、原型模式等……面向对象常用语法 Object.create() 创建一个具有指定原型且可选择性地包含指定属性的对象。 new的高级应用？]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>对象 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数内部的特殊对象]]></title>
    <url>%2F2018%2F04%2F29%2F%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解js对象排序-sort()]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjs%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[[toc] 排序假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。 我们可以使用sort()方法 sort()sort() 方法用于对数组的元素进行排序,并返回数组。默认排序顺序是根据字符串Unicode码点。 语法：arrayObject.sort(参数)参数可选，用于规定排序顺序。必须是函数。 注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序。准确的说：是按照字符编码的顺序进行排序。 但要实现默认按字母顺序排序，必须先把数组的元素都转换成字符串。 例1：我们将创建一个数组，并按字母顺序进行排序：1234567891011&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(4)arr[0] = &quot;G&quot;arr[1] = &quot;J&quot;arr[2] = &quot;T&quot;arr[3] = &quot;A&quot;document.write(arr.sort()) //A G J T&lt;/script&gt; 例2：我们将创建一个数组，并按字母顺序进行排序： 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(6)arr[0] = &quot;10&quot;arr[1] = &quot;5&quot;arr[2] = &quot;40&quot;arr[3] = &quot;25&quot;arr[4] = &quot;1000&quot;arr[5] = &quot;1&quot;document.write(arr.sort()) // 1 10 1000 25 40 5&lt;/script&gt; 至此，我们了解了sort()在没有函数传参的情况下： 默认按照首字母A~Z、a~z排序，以及0~9排序。 原理：真正的默认排序顺序是根据字符串Unicode码点。字符串根据ASCII码进行排序。 我们注意到，上面的代码没有按照数值的大小对数字进行排序要实现这一点，就必须使用一个排序函数。 ① 函数传参（a-b）-升序、降序排序123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt;function sortNumber(a,b)&#123; return a - b&#125;var arr = new Array(6)arr[0] = &quot;10&quot;arr[1] = &quot;5&quot;arr[2] = &quot;40&quot;arr[3] = &quot;25&quot;arr[4] = &quot;1000&quot;arr[5] = &quot;1&quot;document.write(arr.sort(sortNumber)) // 1 5 10 25 40 10000&lt;/script&gt; 以上代码可知，升序排列方法为： 1234function sortNumber(a,b)&#123; return a - b //同理，如果是降序，则为b - a&#125; 但如果想根据数组对象中的某个属性值进行排序呢？ ② 进阶：函数嵌套传参（自定义函数（属性名））sort方法接收一个函数作为参数。我们可以在参数中嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。意思是：根据xx属性的值进行排序 1234567891011121314var arr = [ &#123;name:&apos;zopp&apos;,age:0&#125;, &#123;name:&apos;gpp&apos;,age:18&#125;, &#123;name:&apos;yjj&apos;,age:8&#125;];function compare(用于判断的属性名)&#123; return function(a,b)&#123; var value1 = a[用于判断的属性名]; var value2 = b[用于判断的属性名]; return value1 - value2; &#125;&#125;console.log(arr.sort(compare(&apos;age&apos;))) //返回对象，age从小到大正向排序 ③ 字母排序兼容我们已经学会了字面量值的升序降序，以及根据属性名对对象数组进行的升序降序 但要是字母大小写不同，该如何来确定是升序排列，还是降序排序呢？ 默认情况下，对字符串排序，是按照ASCII的大小比较的。现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以： toUpperCase() 方法：把字符串转换为大写。以下算法基于js底层的JS引擎实现，严格意义上并非某种算法。 而是对于sort()函数的高阶应用！ (s1、s2)为升序，(s2、s1)为降序 123456789101112131415var arr = [&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;];function english(s1, s2) &#123; x1 = s1.toUpperCase(); x2 = s2.toUpperCase(); if (x1 &lt; x2) &#123; return -1; &#125; if (x1 &gt; x2) &#123; return 1; &#125; return 0;&#125;arr.sort(english); // [&apos;apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;] 原理解析： sort()会默认按照字符编码的顺序进行排序。 字符编码的大小判断，会决定sort()方法的返回结果。 然而，尽管如此，我们还是可以利用js本身的语法，去灵活使用sort()方法。 sort()原理与通用方法参考字母排序方法 让我们来看看sort()是如何通过0，1，-1来对不同的对象数组进行排序的。 关于前面的字母排序方法，我使用的廖雪峰大神的博客教学代码，接下来为了方便理解，我还会使用他的代码。 sort()通用方法①通用简单升序123456789101112var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] ② 通用简单降序改变上一段代码的return返回值的1和-1的位置（位置对调）。 闲话：记得廖雪峰大神的教学代码，看过三次，当时都以为看懂了一部分。其实完全没看懂，只是知道怎么用。 接下来说说原理。 sort()通用排序原理原理很简单，但是初学者一般不会想得到：那就是————JS引擎的判断机制！ 想起很久以前看过的一张动漫对比图： 天然呆看到看到苹果会想到“苹果很甜、好吃”，或者我们普通人就再加一个iphone。而学霸看到苹果则是会想到牛顿的万有引力、以及各种相关知识……联想能力强到爆炸，学力满满 咳，姑且不提这个悲伤的故事 我们来说说JS引擎的判断机制。这是底层实现、但也不是什么非常厉害的东西。 仅仅就是if判断语句！ 是不是很惊讶？然而，虽然仅仅是if判断语句，但灵活的把不同的东西一起用，还是要对js有一定了解才行，否则除非非常专注去想要钻研问题，或者运气好。 不然一般还是无法理解。 讲解部分 这里廖雪峰大神的代码，通过对字符比较的大小判断，以及return返回……判断了到底执行哪一条代码。 本质上，排序原理还是sort()方法进行排序（参考最前面的代码）只是加入if判断。 实际上，-1和0的返回值，都是可以忽略的。因为那代表false 致命魔术：靠近一点，因为你自以为看到的越多，就越容易被欺骗！ 所以知识面广很重要！ 在刚开始学习一门新技术时，最好对其有相对全面的认识再深入了解！ （这正是我一开始学了很久，技术也很菜的原因！）]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>排序 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript循环语句]]></title>
    <url>%2F2018%2F04%2F28%2Fjavascript%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[[TOC] 学习和记录循环语句需要注意的重要细节，深入理解js的循环语句 for（条件循环）一般for循环的语法为：123for(语句1;语句2;语句3)&#123; 被执行的代码块；&#125; 语句 1 在循环（代码块）开始前执行语句 2 定义运行循环（代码块）的条件语句 3 在循环（代码块）已被执行之后执行 干巴巴的说明有点无聊，不方便记忆，我们来做一道经典题型 以面试题级别的题型为例： 123456// 挑战一var k;for(i=0, j=0; i&lt;10, j&lt;6; i++, j++)&#123; k = i + j;&#125;console.log(k); // ？？？ 偶不！它一次定义了很多条语句！这不是for循环！等等……仔细一看，它只有三个分号。冷静，这是我们刚才学习的for循环！ 毕竟也没有谁规定一个语句之中，只能写一个判断，这样做是可以的。那么，答案会是多少呢？ 一开始，i和j都等于零。条件判断后，i和j都自加一。 但条件判断是以谁为基准？分别循环？不可能！ 所幸，我们不是真的在面试，直接用浏览器运行便能一窥究竟。答案是10 而如果把i&lt;10 和 j&lt;6 的位置对调则会输出18 由此可见，for循环的条件判断停止条件，由最接近第二个分号的条件为准。 顺便一提，当循环遍历一个数组，并且数组的长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 例： const arr = [1, 2, 3];for(let i = 0, len = arr.length; i &lt; len; i++) for-in (遍历所有可枚举的属性)for-in语句用于对数组或者对象的属性进行循环操作。 for-in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作。 Tip: for-in循环应该用在非数组对象的遍历上，使用for-in进行循环也被称为“枚举”。因为它真正遍历的是对象“可枚举的属性” 注意： for-in 遍历属性的顺序并不确定。即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。 Array 的真相Array 在 Javascript 中是一个对象， Array 的索引是属性名。 事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。 实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。 有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？ 那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。 现在我们来看看用 for-in 来循环数组的特殊例子 1234567891011const arr = [1, 2, 3];arr.name = &quot;Hello world&quot;;let index;for(index in arr) &#123; console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);&#125;//运行结果//arr[0] = 1//arr[1] = 2//arr[2] = 3//arr[name] = Hello world 我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。 同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。 那是不是说，只要我们不在 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。 因为 for-in 不仅仅遍历 array 自身的属性，它还遍历 array 原型链上的所有可枚举的属性。 下面我们看个例子： 123456789101112Array.prototype.fatherName = &quot;Father&quot;;const arr = [1, 2, 3];arr.name = &quot;Hello world&quot;;let index;for(index in arr) &#123; console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);&#125;//arr[0] = 1//arr[1] = 2//arr[2] = 3//arr[name] = Hello world//arr[fatherName] = Father 写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。 但是有一种情况例外，那就是稀疏数组。 12345678910111213let key;const arr = [];arr[0] = &quot;a&quot;;arr[100] = &quot;b&quot;;arr[10000] = &quot;c&quot;;for(key in arr) &#123; if(arr.hasOwnProperty(key) &amp;&amp; /^0$|^[1-9]\d*$/.test(key) &amp;&amp; key &lt;= 4294967294 ) &#123; console.log(arr[key]); &#125;&#125; for-in 只会遍历存在的实体. 上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，而普通 for 循环则会遍历 10001 次）。所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。 for-in 性能正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。 如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：123456789const obj = &#123; &quot;prop1&quot;: &quot;value1&quot;, &quot;prop2&quot;: &quot;value2&quot;&#125;; const props = [&quot;prop1&quot;, &quot;prop2&quot;];for(let i = 0; i &lt; props.length; i++) &#123; console.log(obj[props[i]]);&#125; 上面代码中，将对象的属性都存入一个数组中，相对于 for-in 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。 for-in总结：最后来一个面试题 1234var nums = [12,32,54,56,78,89];for(var n in nums)&#123; console.log(n); // 0,1,2,3,4,5&#125; 因为for-in的真正作用已经解释了很多，所以我们只需要梳理一下知识点，即可轻松解答 总结：①：Array实际上不存在索引（但存在类似的属性）②：for-in只能遍历可枚举属性（几乎所有属性）③：for-in并不直接获取数组元素（获取元素方法：数组[索引属性]）④：for-in输出顺序不确定（不会自动排列） 由此可得：①：console.log(n)不可能输出元素②：n是索引属性 所以，Array不存在索引，但for-in遍历索引属性（普通的for循环是遍历数组长度）。 补充：（过滤不想要的属性）1234567for(var i in a) &#123; // 跳过继承的属性 if (!a.hasOwnProperty(i)) continue; // continue结束本次循环 // 跳过不是非负整数的 i if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;&#125; forEach (遍历所有元素并回调)在 ES5 中，引入了新的循环，即 forEach 循环。 1234567const arr = [1, 2, 3];arr.forEach((data) =&gt; &#123; console.log(data);&#125;);//1//2//3 forEach 方法为数组中含有有效值的每一项执行一次 callback 函数。那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 callback 函数会被依次传入三个参数： forEach(值,索引,数组对象本身)，默认只遍历值 数组当前项的值； 数组当前项的索引； 数组对象本身； 需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。 如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。 12345678const arr = [];arr[0] = &quot;a&quot;;arr[3] = &quot;b&quot;;arr[10] = &quot;c&quot;;arr.name = &quot;Hello world&quot;;arr.forEach((data, index, array) =&gt; &#123; console.log(data, index, array);&#125;); 运行结果: 123a 0 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]b 3 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]c 10 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;] 这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。 所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。 另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分： every: 循环在第一次 return false 后返回 some: 循环在第一次 return true 后返回 filter: 返回一个新的数组，该数组内的元素满足回调函数 map: 将原数组中的元素处理后再返回 reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。 forEach 性能：一般forEach 的速度不如 for ，因为forEach会遍历所有元素，并一一进行回调。]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>循环语句 js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6语法学习]]></title>
    <url>%2F2018%2F04%2F13%2FES6%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ES6在代码中，如果使用了ES6语法，那么强制开启严格模式 let和const let:使用let定义的变量，拥有块级作用域. 注意：使用let定义变量，在同一块级作用域内，不能重复定义同一个名字。 const:使用const定义的是常量，不可更改，且也拥有块级作用域。 注意：const只能在定义赋值，因为它定义的是常量，不可更改。除非在定义时赋值的常量，是一个Object。因为Object是引用类型，赋值Object等于给const赋值了一个指针，指针不会变，Object改变不影响指向它的指针。 涉及的JS基础知识基本类型（私人空间）：每定义一个变量，就会在栈内存中开辟一个存放这个变量的空间。 引用类型（公共空间）：如果有两个不同的变量指向同一个对象，则这个对象是唯一存在堆内存的。当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。 解构赋值示例：数组解构赋值 { let a,b; [a,b]=[1,2]; console.log(a,b); // 1 2 } 赋值展开平铺语法：…变量 { let a,b,rest; [a,b,...rest]=[1,2,3,4,5,6]; console.log(a,b,rest); // 1 2 [3,4,5,6] } 对象解构赋值： { let a,b; ({a,b}={a:1,b:2}) console.log(a,b); // 1 2 } 如果解构赋值没有在结构上成功配对，则赋值对象为未定义,否则设定默认值 { let a,b,c,rest; [a,b,c=3]=[1,2] console.log(a,b,c) //1 2 3 } 解构赋值的常用使用场景：1.数值交换 { let a=1; let b=2; [a,b]=[b,a]; console.log(a,b); // 2 1 } 2.函数返回 { function f(){ return [1,2] } let a,b; [a,b]=f(); console.log(a,b); // 1 2 } 3.函数选择返回 { function f(){ return [1,2,3,4,5,] } let a,b,c; [a,,,b]=f(); console.log(a,b); // 1 4 } 4.函数平铺返回 { function f(){ return [1,2,3,4,5,] } let a,b,c; [a,...b]=f(); console.log(a,b); // 1 [2,3,4,5] } 5.对象解构赋值 { let o={p:42,q:true}; let {p,q}=o; console.log(p,q); // 42 true } 6,对象设置默认值 { let {a=10,b=5}={a:3} console.log(a,b); // 3 5 } 解构赋值：模拟后台json数据{ let metaData={ title:&apos;abc&apos;, test:[{ title:&apos;test&apos;, desc:&apos;description&apos; }] } let {title:esTitle,test:[{title:cnTitle}]}=metaData; console.log(esTitle,cnTitle); } Module模块化导出：export xxx()export default { xxx, zzz yyy} 引入：import xxx from ‘./路径’]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用css module替代scopet]]></title>
    <url>%2F2018%2F04%2F08%2Fmodule%E6%9B%BF%E4%BB%A3scopet%2F</url>
    <content type="text"><![CDATA[[toc] 关于CSS Module css modules是一种流行的模块化和组合CSS的系统。 vue-loader提供了与css modules的集成，作为scope CSS的替代方案。 vue引入scopet，有缺陷的样式私有化最开始的时候，我们提倡并大量使用的是scoped这种技术在vue组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style标签上添加scoped属性，以表示它的只属于当下的模块，这是一个非常好的举措。 @media (min-width: 250px) { .list-container:hover { background: orange; } } &lt;!-- more --&gt; 这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-21e5b78) 为组件内 CSS 指定作用域编译的时候 .list-container:hover 会被编译成类似 .list-container[data-v-21e5b78]:hover 但是，它并不能完全避免冲突 如果用户在不同的父子级，定义了一个重复的类名，会影响到所有定义为errShow类名的组件的显示并且它会造成一种后果，每个样式的权重加重了：理论上我们要去修改这个样式，需要更高的权重去覆盖这个样式。这是增加复杂度的其中一个维度。 CSS modules则做的更好，它不是添加属性，而是直接改变类名SS Modules既不是官方标准，也不是浏览器的特性，而是在构建步骤中对CSS类名选择器限定作用域的一种方式（通过hash实现类似于命名空间的方法）。 类名是动态生成的，唯一的，并准确对应到源文件中的各个类的样式。 实际上，CSS Modules只是CSS模块化的一种方式。为什么我们需要CSS模块化呢？ CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。于是，亟待解决的就是样式冲突（污染）的问题。一般地，为了解决冲突，会把class命名写长一点，降低冲突几率；加上父元素的选择器，来限制范围等…… CSS模块化就是来解决这个问题的，一般地，分为三类 1、命名约定类 该类CSS模块化方案主要用来规范CSS命名，最常见的是BEM，当然还有OOCSS等，在构建工具出现之前，大多数都是在CSS命名上做文章 2、CSS in JS 彻底抛弃CSS，用javascript来写CSS规则，常见的有styled-components 3、使用JS来管理样式 使用JS编译原生的CSS文件，使其具备模块化的能力，最常见的就是CSS Modules 随着构建工具的兴起，越来越多的人开始使用后两者方案，书写CSS时，不用再特意地关心样式冲突问题。只需要使用约定的格式编写代码即可 VUE的CSS Module写法 使用时需要进行添加v-bind，如样式绑定简写 :class ① 在style标签中添加module属性，表示打开CSS-loader的模块模式 &lt;style module&gt; .red {color: red;} &lt;/style&gt; ② 在模板中使用动态类绑定 :class ，并在类名前面加上 $style. &lt;template&gt; &lt;p :class=&quot;$style.red&quot;&gt; This should be red &lt;/p&gt; &lt;/template&gt; ③ 如果类名包含中划线，则使用中括号语法 &lt;h4 :class=&quot;$style[&apos;header-tit&apos;]&quot;&gt;类别推荐&lt;/h4&gt; ④ 也可以使用数组或对象语法 &lt;p :class=&quot;{ [$style.red]: isRed }&quot;&gt; Am I red? &lt;/p&gt; &lt;p :class=&quot;[$style.red, $style.bold]&quot;&gt; Red and bold &lt;/p&gt; ⑤ 更复杂的对象语法 &lt;ul :class=&quot;{ [$style.panelBox]:true, [$style.transitionByPanelBox]:needTransition }&quot; ⑥ 更复杂的数组语法 &lt;li :class=&quot;[ $style[&apos;aside-item&apos;], {[$style[&apos;aside-item_active&apos;]]:(i === index)} ]&quot; 配置css-loader关于CSS modules的默认配置如下 { modules: true, importLoaders: 1, localIdentName: &apos;[hash:base64]&apos; } 可以使用vue-loader的cssModules选项为css-loader进行自定义的配置 module: { rules: [ { test: &apos;\.vue$&apos;, loader: &apos;vue-loader&apos;, options: { cssModules: { localIdentName: &apos;[path][name]---[local]---[hash:base64:5]&apos;, camelCase: true } } } ] }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass使用之mixin]]></title>
    <url>%2F2018%2F04%2F08%2Fsass%E4%BD%BF%E7%94%A8%E4%B9%8Bmixin%2F</url>
    <content type="text"><![CDATA[目前仅用于最简单的实战，没有深入学习，以下介绍SASS常用方法 定义mixin通过 @mixin 名称 的方式可以定义一个Mixins模块：在模块内你可以添加任何你想重复使用的样式。 示例（以下全文使用一个例子）： @mixin flex($direction:column,$inline:block) { display: if($inline==block,flex,inline-flex); flex-direction: $direction; flex-wrap: wrap; } 由于历史原因，连字符和下划线被认为是相同的，也就是说 @mixin button-large { } 和 @mixin button_large { } 是一样的。 Mixins能够包含任何在 CSS 和 Sass 中有效的内容。 调用Mixin你可以通过 @include 来调用具有相同名称的mixin模块。 @mixin btn { display:inline-block; } .btn { @include btn; //等于display:inline-block; } @include 也可以在mixin模块的定义中使用 参数的使用使用$，Mixins可以接收和使用参数，这有点像less，但作用域不同 @mixin btn($size:14px,$color:#fff,$bgcolor:#f04752,$padding:5px,$radius:5px) { padding: $padding; background-color: $bgcolor; border-radius: $radius; border: 1px solid $bgcolor; font-size: $size; color: $color; text-align: center; line-height: 1; display: inline-block; } 关键字参数为了帮助你的代码更加容易理解，你可以在传递值给mixin时将参数名称和参数值一并传递过去。 button-green { @include button($background: green, $color: #fff); } 关键字参数会额外增加一些代码，但是这会使得你的@include更加容易理解。上面的代码明确指出了green和#fff分别是什么。 数量可变的参数Mixins可以接收未知数量的参数。通过在变量名后增加三个点（…）来使mixin模块接收数量可变的参数。当你使用@include传递参数的时候，使用逗号将参数分开。 @mixin box-shadows($shadow...) { box-shadow: $shadow; } .container { @include box-shadows(0px 1px 2px #333, 2px 3px 4px #ccc); } 编译为 .container { box-shadow: 0px 1px 2px #333, 2px 3px 4px #ccc; }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>SASS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css布局思路]]></title>
    <url>%2F2018%2F04%2F02%2Fcss%E5%B8%83%E5%B1%80%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[使用三段论推理：三段论包括大前提、小前提、结论三个部分。所谓CSS布局：布局是大前提，html是小前提。良好的布局思路，决定了代码的优雅。 ①我要用什么布局②DOM结构用什么标签③结构的主体是什么 看似简单，是逻辑推理中的基础【三点式推理】。但是一定要想清楚！严格遵循这个顺序！ 只有一开始便理清思路，并且不断累积这样的判断经验，才能提高开发效率与正确的直觉！]]></content>
      <categories>
        <category>css学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
