<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>非黑非白の博客</title>
  
  <subtitle>重学前端,记录笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blak-kong.github.io/"/>
  <updated>2020-04-14T18:40:17.909Z</updated>
  <id>http://blak-kong.github.io/</id>
  
  <author>
    <name>blak-kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="http://blak-kong.github.io/2020/04/15/test/"/>
    <id>http://blak-kong.github.io/2020/04/15/test/</id>
    <published>2020-04-14T18:40:01.195Z</published>
    <updated>2020-04-14T18:40:17.909Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
      <category term="test" scheme="http://blak-kong.github.io/categories/test/"/>
    
    
  </entry>
  
  <entry>
    <title>node+mongoodb学习</title>
    <link href="http://blak-kong.github.io/2019/04/07/node+mongoodb%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <id>http://blak-kong.github.io/2019/04/07/node+mongoodb学习(一)/</id>
    <published>2019-04-07T12:26:53.000Z</published>
    <updated>2019-06-16T08:32:20.105Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>此系列将在一周内更新完，不记细节，只记基础知识点</p><h4 id="1-服务器启动"><a href="#1-服务器启动" class="headerlink" title="1.服务器启动"></a>1.服务器启动</h4><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p><p>使用 Express 可以快速地搭建一个完整功能的网站。</p><a id="more"></a><p>Express 框架核心特性：</p><ul><li>可以设置中间件来响应 HTTP 请求。</li><li>定义了路由表用于执行不同的 HTTP 请求动作。</li><li>可以通过向模板传递参数来动态渲染 HTML 页面。</li></ul><p>启动文件：server.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);<span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express(); <span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">5000</span>; <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">"hello world!"</span>) <span class="comment">// 默认输出</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(port, () =&gt; &#123; <span class="comment">// 监听</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Server running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>此时推荐安装插件nodemon，它默认会监听当前目录，重启Express</p><h4 id="2-mongodb创建数据库"><a href="#2-mongodb创建数据库" class="headerlink" title="2.mongodb创建数据库"></a>2.mongodb创建数据库</h4><p>数据库：config/keys.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 本地写法，无需登录</span></span><br><span class="line">    mongoURI: <span class="string">"mongodb://localhost:27017/testData"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 远程写法</span></span><br><span class="line">    mongoURI: <span class="string">"mongodb://名称:密码@远程 数据库地址/testData"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回到启动文件：server.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>) <span class="comment">// 引入mongo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DB config</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">"./config/keys"</span>).mongoURI; <span class="comment">// 引入数据库地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// connect to mongodb 链接mongodb</span></span><br><span class="line">mongoose.connect(db, &#123;<span class="attr">useNewUrlParser</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"MongoDB Connected 666"</span>)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></p><p>访问mongodb成功后，node命令行会输出MongoDB Connected 666</p><h4 id="3-创建接口"><a href="#3-创建接口" class="headerlink" title="3.创建接口"></a>3.创建接口</h4><p>接口目录:router/api/user.js<br>以下为最简单的router接口访问，只能输出消息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// login &amp; register</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $route   GET api/users/test</span></span><br><span class="line"><span class="comment">// @desc    返回的请求的json数据</span></span><br><span class="line"><span class="comment">// @access  public</span></span><br><span class="line">router.get(<span class="string">"/test"</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;<span class="attr">msg</span>: <span class="string">"login works"</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如果需要实现更多功能，则需要编写逻辑，甚至安装更多插件配合。<br>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">"bcrypt"</span>); <span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">const</span> gravatar = <span class="built_in">require</span>(<span class="string">'gravatar'</span>); <span class="comment">// 全球公共头像</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">"jsonwebtoken"</span>); <span class="comment">// 生成token</span></span><br></pre></td></tr></table></figure></p><h4 id="4-为什么接口要用到Schema"><a href="#4-为什么接口要用到Schema" class="headerlink" title="4.为什么接口要用到Schema"></a>4.为什么接口要用到Schema</h4><p>在数据库中，schema（模式）是数据库的组织和结构。<br>也就是数据结构。</p><p>1.在创建接口后，根据字段需要，创建schema（模式）。</p><p>2.该接口在前后端的字段传值，必须符合schema（模式）的定义。</p><p>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>)</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Schema 模型</span></span><br><span class="line"><span class="keyword">const</span> UserSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    email: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    avatar: &#123;</span><br><span class="line">        type: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    date: &#123;</span><br><span class="line">        type: <span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">Date</span>.now</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = User = mongoose.model(<span class="string">"users"</span>, UserSchema);</span><br></pre></td></tr></table></figure></p><h4 id="5-接口调试工具：postman"><a href="#5-接口调试工具：postman" class="headerlink" title="5.接口调试工具：postman"></a>5.接口调试工具：postman</h4><p>1.谷歌应用商店搜索postman，安装使用</p><p>2.直接百度搜索，下载安装软件</p><h4 id="5-1-Express中间件body-parser"><a href="#5-1-Express中间件body-parser" class="headerlink" title="5.1.Express中间件body-parser"></a>5.1.Express中间件body-parser</h4><p>当express使用get以外的请求时，需要安装中间件body-parser处理不同类型的请求</p><p>body-parser实现的·要点如下：</p><ul><li>处理不同类型的请求体：<code>比如text、json、urlencoded等，对应的报文主体的格式不同</code>。</li><li>处理不同的编码：<code>比如utf8、gbk等</code>。</li><li>处理不同的压缩类型：<code>比如gzip、deflare等</code>。</li><li>其他边界、异常的处理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;此系列将在一周内更新完，不记细节，只记基础知识点&lt;/p&gt;
&lt;h4 id=&quot;1-服务器启动&quot;&gt;&lt;a href=&quot;#1-服务器启动&quot; class=&quot;headerlink&quot; title=&quot;1.服务器启动&quot;&gt;&lt;/a&gt;1.服务器启动&lt;/h4&gt;&lt;p&gt;Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。&lt;/p&gt;
&lt;p&gt;使用 Express 可以快速地搭建一个完整功能的网站。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blak-kong.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="http://blak-kong.github.io/tags/node/"/>
    
      <category term="mongoodb" scheme="http://blak-kong.github.io/tags/mongoodb/"/>
    
      <category term="实战笔记" scheme="http://blak-kong.github.io/tags/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>组件间数据传递</title>
    <link href="http://blak-kong.github.io/2018/05/03/%E7%BB%84%E4%BB%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>http://blak-kong.github.io/2018/05/03/组件间数据传递/</id>
    <published>2018-05-03T07:16:02.000Z</published>
    <updated>2019-06-16T08:33:47.917Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h1><p>在一个组件内部定义另一个组件，称为父子组件<br>子组件只能在父组件内部使用<br>默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的</p><a id="more"></a><h1 id="组件间数据传递-（通信）"><a href="#组件间数据传递-（通信）" class="headerlink" title="组件间数据传递 （通信）"></a>组件间数据传递 （通信）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;food @add=&quot;addFood&quot; :food=&quot;selectedFood&quot; ref=&quot;food&quot;&gt;&lt;/food&gt;</span><br></pre></td></tr></table></figure><h2 id="子组件访问父组件的数据"><a href="#子组件访问父组件的数据" class="headerlink" title="子组件访问父组件的数据"></a>子组件访问父组件的数据</h2><ul><li><p>a)在调用子组件时，v-bind绑定想要获取的父组件中的数据</p></li><li><p>b)在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据</p><ul><li>总结：父组件通过props向下传递数据给子组件</li></ul></li></ul><p>注：组件中的数据共有三种形式：data、props、computed</p><h2 id="父组件访问子组件的数据"><a href="#父组件访问子组件的数据" class="headerlink" title="父组件访问子组件的数据"></a>父组件访问子组件的数据</h2><ul><li>a)在子组件中使用vm.$emit(事件名,数据)触发一个自定义事件，事件名自定义</li><li>b)父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据<ul><li>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件</li></ul></li></ul><h4 id="父组件在标签使用-方法，监听子组件发射回来的函数"><a href="#父组件在标签使用-方法，监听子组件发射回来的函数" class="headerlink" title="父组件在标签使用@方法，监听子组件发射回来的函数"></a>父组件在标签使用@方法，监听子组件发射回来的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addFood(target) &#123;</span><br><span class="line">        this.$emit(&apos;add&apos;, target);//把事件传递到父组件@add所绑定的函数</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>props是单向绑定的，当父组件的属性变化时，将传导给子组件，但是不会反过来<br>而且不允许子组件直接修改父组件中的数据，报错</p><p>解决方式：</p><pre><code>- 方式1：如果子组件想把它作为局部数据来使用，可以将数据存入另一个变量中再操作，不影响父组件中的数据- 方式2：如果子组件想修改数据并且同步更新到父组件，两个方法：    - a.使用.sync（1.0版本中支持，2.0版本中不支持，2.3版本又开始支持）        需要显式地触发一个更新事件`this.$emit(&apos;update:name&apos;,&apos;alice&apos;)`    - b.可以将父组件中的数据包装成对象，然后在子组件中修改对象的属性(因为对象是引用类型，指向同一个内存空间)，推荐</code></pre><h2 id="非父子组件间的通信"><a href="#非父子组件间的通信" class="headerlink" title="非父子组件间的通信"></a>非父子组件间的通信</h2><p>非父子组件间的通信，可以通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Event=new Vue();// 定义空实例（其他实例都会挂载到它上面）</span><br><span class="line">Event.$emit(事件名,数据); // 触发当前实例上的事件。附加参数都会传给监听器回调。</span><br><span class="line">Event.$on(事件名,data =&gt; &#123;&#125;); // 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;父子组件&quot;&gt;&lt;a href=&quot;#父子组件&quot; class=&quot;headerlink&quot; title=&quot;父子组件&quot;&gt;&lt;/a&gt;父子组件&lt;/h1&gt;&lt;p&gt;在一个组件内部定义另一个组件，称为父子组件&lt;br&gt;子组件只能在父组件内部使用&lt;br&gt;默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue组件" scheme="http://blak-kong.github.io/tags/vue%E7%BB%84%E4%BB%B6/"/>
    
      <category term="数据传递" scheme="http://blak-kong.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>组件component</title>
    <link href="http://blak-kong.github.io/2018/05/03/%E7%BB%84%E4%BB%B6component/"/>
    <id>http://blak-kong.github.io/2018/05/03/组件component/</id>
    <published>2018-05-03T03:55:47.000Z</published>
    <updated>2019-04-07T14:56:55.760Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h2 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h2><p>组件（Component）是 Vue.js 最强大的功能之一。<br>组件可以扩展 HTML 元素，封装可重用的代码<br>组件是自定义元素（对象）</p><a id="more"></a><h2 id="定义组件的方式"><a href="#定义组件的方式" class="headerlink" title="定义组件的方式"></a>定义组件的方式</h2><h4 id="方式1：先创建组件构造器，然后由组件构造器创建组件（全局）"><a href="#方式1：先创建组件构造器，然后由组件构造器创建组件（全局）" class="headerlink" title="方式1：先创建组件构造器，然后由组件构造器创建组件（全局）"></a>方式1：先创建组件构造器，然后由组件构造器创建组件（全局）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.使用Vue.extend()创建一个组件构造器</span><br><span class="line">var MyComponent=Vue.extend(&#123;</span><br><span class="line">template:&apos;&lt;h3&gt;Hello World&lt;/h3&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">2.使用Vue.component(标签名,组件构造器)，根据组件构造器来创建组件</span><br><span class="line">Vue.component(&apos;hello&apos;,MyComponent);</span><br></pre></td></tr></table></figure><h4 id="方式2：直接创建组件（全局）"><a href="#方式2：直接创建组件（全局）" class="headerlink" title="方式2：直接创建组件（全局）"></a>方式2：直接创建组件（全局）</h4><p>直接把组件构造器写在{}里定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-world&apos;,&#123;</span><br><span class="line">template:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="方式3：局部组件（常用）"><a href="#方式3：局部组件（常用）" class="headerlink" title="方式3：局部组件（常用）"></a>方式3：局部组件（常用）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 挂载到单页面里，只在当前页有效</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;my-world&apos;,&#123;</span><br><span class="line">template:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件中添加数据"><a href="#组件中添加数据" class="headerlink" title="组件中添加数据"></a>组件中添加数据</h2><p>在组件中存储数据时，必须以函数形式，函数返回一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">components:&#123; //局部组件</span><br><span class="line">&apos;my-world&apos;:&#123;</span><br><span class="line">template:&apos;&lt;h3&gt;&#123;&#123;age&#125;&#125;&lt;/h3&gt;&apos;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">age:25</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用模板"><a href="#引用模板" class="headerlink" title="引用模板"></a>引用模板</h2><p>组件化开发中，引用模板为直接创建新文件，作为组件。<br>组件名为文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;wbs&quot;&gt;</span><br><span class="line">&lt;!-- &lt;template&gt;必须有且只有一个根元素 --&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">components:&#123;</span><br><span class="line">&apos;my-hello&apos;:&#123;</span><br><span class="line">name:&apos;wbs17022&apos;,  //指定组件的名称，默认为标签名，可以不设置</span><br><span class="line">template:&apos;#wbs&apos;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">msg:&apos;欢迎来到南京网博&apos;,</span><br><span class="line">arr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态加载组件"><a href="#动态加载组件" class="headerlink" title="动态加载组件"></a>动态加载组件</h2><p><code>&lt;component :is=&quot;挂载点&quot;&gt;</code><br>    多个组件使用同一个挂载点，然后动态的在它们之间切换    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;flag=&apos;my-hello&apos;&quot;&gt;显示hello组件&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;flag=&apos;my-world&apos;&quot;&gt;显示world组件&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;component :is=&quot;flag&quot;&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">flag:&apos;my-hello&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lt-keep-alive-gt-缓存组件"><a href="#lt-keep-alive-gt-缓存组件" class="headerlink" title="&lt;keep-alive&gt;缓存组件"></a><code>&lt;keep-alive&gt;</code>缓存组件</h2><p>标签的组件实例能够被在它们第一次被创建的时候缓存下来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;什么是组件？&quot;&gt;&lt;a href=&quot;#什么是组件？&quot; class=&quot;headerlink&quot; title=&quot;什么是组件？&quot;&gt;&lt;/a&gt;什么是组件？&lt;/h2&gt;&lt;p&gt;组件（Component）是 Vue.js 最强大的功能之一。&lt;br&gt;组件可以扩展 HTML 元素，封装可重用的代码&lt;br&gt;组件是自定义元素（对象）&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue组件" scheme="http://blak-kong.github.io/tags/vue%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>练习：vue自定义指令</title>
    <link href="http://blak-kong.github.io/2018/05/02/%E7%BB%83%E4%B9%A0%EF%BC%9Avue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
    <id>http://blak-kong.github.io/2018/05/02/练习：vue自定义指令/</id>
    <published>2018-05-02T07:57:07.000Z</published>
    <updated>2019-04-07T14:56:55.757Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这是很少会更新的附带完整代码的博客。<br>究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;练习：自定义指令&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#itany div&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">position:absolute;</span><br><span class="line">&#125;</span><br><span class="line">#itany .hello&#123;</span><br><span class="line">background-color:red;</span><br><span class="line">top:0;</span><br><span class="line">left:0;</span><br><span class="line">&#125;</span><br><span class="line">#itany .world&#123;</span><br><span class="line">background-color:blue;</span><br><span class="line">top:0;</span><br><span class="line">right:0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;itany&quot;&gt;</span><br><span class="line">&lt;div class=&quot;hello&quot; v-drag&gt;itany&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;world&quot; v-drag&gt;网博&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">        // vue全局自定义指令</span><br><span class="line">Vue.directive(&apos;drag&apos;,function(el)&#123;</span><br><span class="line">el.onmousedown=function(e)&#123;</span><br><span class="line">// 获取鼠标点击处分别与div左边和上边的距离：鼠标位置-div位置</span><br><span class="line">var disX=e.clientX-el.offsetLeft;</span><br><span class="line">var disY=e.clientY-el.offsetTop;</span><br><span class="line">// console.log(disX,disY);</span><br><span class="line"></span><br><span class="line">//包含在onmousedown里面，表示点击后才移动，为防止鼠标移出div，使用document.onmousemove</span><br><span class="line">document.onmousemove=function(e)&#123;</span><br><span class="line">// 获取移动后div的位置：鼠标位置-disX/disY</span><br><span class="line">// 因为offset获取的是左边和上边，所以移动需使用减法</span><br><span class="line">var l=e.clientX-disX;</span><br><span class="line">var t=e.clientY-disY;</span><br><span class="line">el.style.left=l+&apos;px&apos;;// 记得要加px像素单位,否则不移动</span><br><span class="line">el.style.top=t+&apos;px&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//停止移动，鼠标抬起触发</span><br><span class="line">document.onmouseup=function(e)&#123;</span><br><span class="line">                    // 清空鼠标按住状态</span><br><span class="line">document.onmousemove=null;</span><br><span class="line">                    // 销毁自身</span><br><span class="line">document.onmouseup=null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var vm=new Vue(&#123;</span><br><span class="line">el:&apos;#itany&apos;,</span><br><span class="line">data:&#123;</span><br><span class="line">msg:&apos;welcome to itany&apos;,</span><br><span class="line">username:&apos;alice&apos;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">change()&#123;</span><br><span class="line">this.msg=&apos;欢迎来到南京网博&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是很少会更新的附带完整代码的博客。&lt;br&gt;究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>CSSOM视图模式</title>
    <link href="http://blak-kong.github.io/2018/05/02/CSSOM%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blak-kong.github.io/2018/05/02/CSSOM视图模式/</id>
    <published>2018-05-02T05:26:18.000Z</published>
    <updated>2019-04-07T14:56:53.530Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="CSSOM视图模块-CSSOM-View-Module"><a href="#CSSOM视图模块-CSSOM-View-Module" class="headerlink" title="CSSOM视图模块(CSSOM View Module)"></a>CSSOM视图模块(CSSOM View Module)</h1><p>它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性</p><p>包括布局框定位、视区宽度和元素滚动。</p><p>以下就是一些API属性的相关内容，包括兼容性，使用，测试等。</p><a id="more"></a><h2 id="window视图属性（几乎没用）"><a href="#window视图属性（几乎没用）" class="headerlink" title="window视图属性（几乎没用）"></a>window视图属性（几乎没用）</h2><p>这些属性可以hold住整个浏览器窗体大小。微软则将这些API称为“Screenview 接口”。</p><blockquote><p>语法：window.xxxxx</p></blockquote><p>它们一般没什么用，仅作了解：</p><ul><li>innerWidth 属性和 innerHeight 属性<ul><li>表示获取window窗体的内部宽高，不包括用户界面元素，比如窗框。</li></ul></li><li>pageXOffset 属性和 pageYOffset 属性<ul><li>表示整个浏览器窗体的大小，包括任务栏等。</li></ul></li><li>screenX 属性和 screenY 属性<ul><li>表示整个页面滚动的像素值（水平方向的和垂直方向的）</li></ul></li><li>outerWidth 属性和 outerHeight 属性<ul><li>浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。</li></ul></li></ul><h2 id="Screen视图属性（几乎没用）"><a href="#Screen视图属性（几乎没用）" class="headerlink" title="Screen视图属性（几乎没用）"></a>Screen视图属性（几乎没用）</h2><blockquote><p>语法：screen.xxxxx</p></blockquote><ul><li>availWidth和availHeight<ul><li>显示器可用宽高，不包括任务栏之类的东东。</li></ul></li><li>width和height<ul><li>表示显示器屏幕的宽高。</li></ul></li></ul><h2 id="元素视图属性-重点"><a href="#元素视图属性-重点" class="headerlink" title="元素视图属性 (重点)"></a>元素视图属性 (重点)</h2><p>使用方法，自己获取页面元素，然后对元素应用方法。</p><ul><li>clientLeft和clientTop（事件内容的位置）<ul><li>表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。</li></ul></li></ul><ul><li><p>clientWidth和clientHeight（事件内容的大小）</p><ul><li>表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。</li></ul></li><li><p>offsetLeft和offsetTop（检测位置）</p><ul><li>表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。</li></ul></li></ul><ul><li><p>offsetWidth和offsetHeight（检测大小）</p><ul><li>整个元素的尺寸（包括边框）。</li></ul></li><li><p>scrollLeft和scrollTop（用于滚动）</p><ul><li>表示元素滚动的像素大小。可读可写。</li></ul></li><li><p>scrollWidth和scrollHeight（整个内容的宽高-包括滚动）</p><ul><li>表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。</li></ul></li></ul><h2 id="鼠标位置-（重要）"><a href="#鼠标位置-（重要）" class="headerlink" title="鼠标位置 （重要）"></a>鼠标位置 （重要）</h2><blockquote><p>语法：event.clientX</p></blockquote><ul><li>clientX,clientY<ul><li>相对于window，为鼠标相对于window的偏移。</li></ul></li></ul><blockquote><p>用于点击移动</p></blockquote><ul><li>offsetX, offsetY<ul><li>表示鼠标相对于当前被点击元素padding box的左上偏移值，各个浏览器的兼容性五花八门.</li></ul></li></ul><blockquote><p>获取鼠标在元素内的位置</p></blockquote><ul><li><p>pageX, pageY（兼容性不好）</p><ul><li>为鼠标相对于document的坐标。</li></ul></li><li><p>screenX, screenY</p><ul><li>鼠标相对于显示器屏幕的偏移坐标。</li></ul></li></ul><h4 id="clientXY-offsetXY组合用法"><a href="#clientXY-offsetXY组合用法" class="headerlink" title="clientXY+offsetXY组合用法"></a>clientXY+offsetXY组合用法</h4><blockquote><p>clienX-offsetX = 元素不超出页面</p></blockquote><p>因为window宽度就是浏览器宽度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSSOM视图模块-CSSOM-View-Module&quot;&gt;&lt;a href=&quot;#CSSOM视图模块-CSSOM-View-Module&quot; class=&quot;headerlink&quot; title=&quot;CSSOM视图模块(CSSOM View Module)&quot;&gt;&lt;/a&gt;CSSOM视图模块(CSSOM View Module)&lt;/h1&gt;&lt;p&gt;它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性&lt;/p&gt;
&lt;p&gt;包括布局框定位、视区宽度和元素滚动。&lt;/p&gt;
&lt;p&gt;以下就是一些API属性的相关内容，包括兼容性，使用，测试等。&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="浏览器视图属性" scheme="http://blak-kong.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%86%E5%9B%BE%E5%B1%9E%E6%80%A7/"/>
    
      <category term="页面内元素移动和滚动" scheme="http://blak-kong.github.io/tags/%E9%A1%B5%E9%9D%A2%E5%86%85%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%BB%9A%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>vue动画</title>
    <link href="http://blak-kong.github.io/2018/05/01/vue%E5%8A%A8%E7%94%BB%E4%B8%8Eanimations%E5%8A%A8%E7%94%BB%E5%BA%93/"/>
    <id>http://blak-kong.github.io/2018/05/01/vue动画与animations动画库/</id>
    <published>2018-05-01T14:32:07.000Z</published>
    <updated>2019-04-07T14:56:55.728Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p><ul><li>条件渲染 (使用 v-if)</li><li>条件展示 (使用 v-show)</li><li>动态组件</li><li>组件根节点</li></ul><p>vue的动画也是使用css3实现的。<br>只是写法有些不一样，我们需要将代码嵌套在<transition>中</transition></p><a id="more"></a><h2 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h2><p>而与css动画最大的区别，我们需要使用vue自带的模板语法<br>通过Vue自带的类名，我们可以定义css动画的触发时机</p><p>在进入/离开的过渡中，会有 6 个 class 切换。</p><ul><li><p>v-enter：定义进入过渡的开始状态。</p><ul><li>在元素被插入之前生效，在元素被插入之后的下一帧移除。</li></ul></li><li><p>v-enter-active：定义进入过渡生效时的状态。</p><ul><li>在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li></ul></li><li><p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。</p><ul><li>在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li></ul></li><li><p>v-leave: 定义离开过渡的开始状态。</p><ul><li>在离开过渡被触发时立刻生效，下一帧被移除。</li></ul></li><li><p>v-leave-active：定义离开过渡生效时的状态。</p><ul><li>在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li></ul></li><li><p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。</p><ul><li>在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.fade-enter-active,.fade-leave-active&#123;</span><br><span class="line">transition:all 3s ease;</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter-active&#123;</span><br><span class="line">opacity:1;// 动画开始状态</span><br><span class="line">width:300px;</span><br><span class="line">height:300px;</span><br><span class="line">&#125;</span><br><span class="line">.fade-leave-active&#123;</span><br><span class="line">opacity:0;</span><br><span class="line">width:50px;</span><br><span class="line">height:50px;</span><br><span class="line">&#125;</span><br><span class="line">/* .fade-enter需要放在.fade-enter-active的后面 */</span><br><span class="line">.fade-enter&#123;</span><br><span class="line">opacity:0; /*初始状态（css重叠样式表，属性覆盖，必须放后面）*/</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="javaScript-钩子"><a href="#javaScript-钩子" class="headerlink" title="javaScript 钩子"></a>javaScript 钩子</h2><p>可以在属性中声明 JavaScript 钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;fade&quot; </span><br><span class="line">@before-enter=&quot;beforeEnter&quot;// 动画进入之前</span><br><span class="line">@enter=&quot;enter&quot;// 动画进入</span><br><span class="line">@after-enter=&quot;afterEnter&quot;// 动画进入之后</span><br><span class="line"></span><br><span class="line">@before-leave=&quot;beforeLeave&quot;// 动画即将离开之前</span><br><span class="line">@leave=&quot;leave&quot;// 动画离开</span><br><span class="line">@after-leave=&quot;afterLeave&quot;// 动画离开之后</span><br><span class="line">&gt;</span><br><span class="line">&lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>钩子函数的触发时机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">beforeEnter(el)&#123;</span><br><span class="line">// alert(&apos;动画进入之前&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">enter()&#123;</span><br><span class="line">// alert(&apos;动画进入&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">afterEnter(el)&#123;</span><br><span class="line">// alert(&apos;动画进入之后&apos;);</span><br><span class="line">el.style.background=&apos;blue&apos;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">beforeLeave()&#123;</span><br><span class="line">// alert(&apos;动画即将之前&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">leave()&#123;</span><br><span class="line">// alert(&apos;动画离开&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">afterLeave(el)&#123;</span><br><span class="line">// alert(&apos;动画离开之后&apos;);</span><br><span class="line">el.style.background=&apos;red&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。</p><blockquote><p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。<br>否则，它们会被同步调用，过渡会立即完成。</p></blockquote><blockquote><p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。<br>这也可以避免过渡过程中 CSS 的影响。</p></blockquote><h1 id="在vue中使用animations-css动画库"><a href="#在vue中使用animations-css动画库" class="headerlink" title="在vue中使用animations.css动画库"></a>在vue中使用animations.css动画库</h1><p>只需要引入animations.css，然后写法如下，在标签中直接定义开始动画和离开动画即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition enter-active-class=&quot;animated fadeInLeft&quot; leave-active-class=&quot;animated fadeOutRight&quot;&gt;</span><br><span class="line">&lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><h2 id="多元素动画"><a href="#多元素动画" class="headerlink" title="多元素动画"></a>多元素动画</h2><p>对于原生标签可以使用 v-if/v-else 。</p><p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。<br>即使在技术上没有必要，给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key 也是一个更好的实践。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt;</span><br><span class="line">&lt;p v-show=&quot;flag&quot; :key=&quot;1&quot;&gt;itany&lt;/p&gt;</span><br><span class="line">&lt;p v-show=&quot;flag&quot; :key=&quot;2&quot;&gt;网博&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><p>我们也可以通过给同一个元素的 key 特性设置不同的状态<br>来代替 v-if 和 v-else</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</span><br><span class="line">    &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>或者使用多个if</p><h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p>同时渲染整个列表<code>&lt;transition-group&gt;</code></p><ul><li>不同于 <transition>，它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。</span></transition></li><li>内部元素 总是需要 提供唯一的 key 属性值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;itany&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;transition-group enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt;</span><br><span class="line">&lt;p v-for=&quot;(v,k) in arr2&quot; :key=&quot;k&quot; v-show=&quot;flag&quot;&gt;</span><br><span class="line">&#123;&#123;v&#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm=new Vue(&#123;</span><br><span class="line">el:&apos;#itany&apos;,</span><br><span class="line">data:&#123;</span><br><span class="line">flag:true,</span><br><span class="line">arr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;,&apos;alice&apos;,&apos;alex&apos;,&apos;mark&apos;],</span><br><span class="line">name:&apos;&apos;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">arr2:function()&#123;</span><br><span class="line">var temp=[];</span><br><span class="line">this.arr.forEach(val =&gt; &#123;</span><br><span class="line">// Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</span><br><span class="line">if(val.includes(this.name))&#123; // 判断是否存在传入字符，存在则push元素</span><br><span class="line">temp.push(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>检测元素数组元素是否存在：<br>Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单元素-组件的过渡&quot;&gt;&lt;a href=&quot;#单元素-组件的过渡&quot; class=&quot;headerlink&quot; title=&quot;单元素/组件的过渡&quot;&gt;&lt;/a&gt;单元素/组件的过渡&lt;/h2&gt;&lt;p&gt;Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件渲染 (使用 v-if)&lt;/li&gt;
&lt;li&gt;条件展示 (使用 v-show)&lt;/li&gt;
&lt;li&gt;动态组件&lt;/li&gt;
&lt;li&gt;组件根节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vue的动画也是使用css3实现的。&lt;br&gt;只是写法有些不一样，我们需要将代码嵌套在&lt;transition&gt;中&lt;/transition&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue自定义指定</title>
    <link href="http://blak-kong.github.io/2018/05/01/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E5%AE%9A/"/>
    <id>http://blak-kong.github.io/2018/05/01/vue自定义指定/</id>
    <published>2018-05-01T14:31:39.000Z</published>
    <updated>2019-06-16T08:32:57.309Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[TOC]</p><h1 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>/**</p><ul><li>自定义全局指令</li><li>注：使用指令时必须在指名名称前加前缀v-，即v-指令名称<br>*/</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;hello&apos;,&#123;</span><br><span class="line">bind()&#123; //常用！！</span><br><span class="line">alert(&apos;指令第一次绑定到元素上时调用，只调用一次，可执行初始化操作&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">inserted()&#123;</span><br><span class="line">alert(&apos;被绑定元素插入到DOM中时调用&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">update()&#123;</span><br><span class="line">alert(&apos;被绑定元素所在模板更新时调用&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">componentUpdated()&#123;</span><br><span class="line">alert(&apos;被绑定元素所在模板完成一次更新周期时调用&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">unbind()&#123;</span><br><span class="line">alert(&apos;指令与元素解绑时调用，只调用一次&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="全局注册自定义指令"><a href="#全局注册自定义指令" class="headerlink" title="全局注册自定义指令"></a>全局注册自定义指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注册一个全局自定义指令 `v-focus`</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当被绑定的元素插入到 DOM 中时调用</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">// 自定义指令名</span><br><span class="line">  focus: &#123;</span><br><span class="line">    // 指令的定义</span><br><span class="line">    inserted: function (el) &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在模板中使用"><a href="#在模板中使用" class="headerlink" title="在模板中使用"></a>在模板中使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure><h2 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h2><ul><li>常用参数为<code>el</code>和<code>binding</code></li></ul><p>钩子函数        参数1  参数2   参数3<br>bind: function (el, binding, vnode)</p><p>指令钩子函数会被传入以下参数：</p><ul><li>el：指令所绑定的元素，可以用来直接操作 DOM 。可以为它绑定事件、也可以直接修改dom属性。</li><li>binding：一个对象。包含以下属性：<ul><li>name：指令名，不包括 v- 前缀。</li><li>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li><li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li><li>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li><li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li><li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li></ul></li><li>vnode：Vue 编译生成的虚拟节点。</li><li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;demo&apos;, &#123;// demo为指令名</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;自定义属性&quot;&gt;&lt;a href=&quot;#自定义属性&quot; class=&quot;headerlink&quot; title=&quot;自定义属性&quot;&gt;&lt;/a&gt;自定义属性&lt;/h1&gt;&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义全局指令&lt;/li&gt;
&lt;li&gt;注：使用指令时必须在指名名称前加前缀v-，即v-指令名称&lt;br&gt;*/&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue的实例属性和方法</title>
    <link href="http://blak-kong.github.io/2018/05/01/vue%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://blak-kong.github.io/2018/05/01/vue的实例属性和方法/</id>
    <published>2018-05-01T14:31:14.000Z</published>
    <updated>2019-06-16T08:32:49.288Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[TOC]</p><h1 id="vue实例的属性和方法"><a href="#vue实例的属性和方法" class="headerlink" title="vue实例的属性和方法"></a>vue实例的属性和方法</h1><p>仅记录部分<br>大部分时候是随学随用，但是学到了就来记录。</p><blockquote><p>实例属性和方法 == 组件实例和方法 != 全局属性和方法</p></blockquote><ul><li>另外，在组件实例的<code>methods方法</code>中不能使用全局Vue方法</li></ul><a id="more"></a><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h4 id="vm-属性名-获取data中的属性"><a href="#vm-属性名-获取data中的属性" class="headerlink" title="vm.属性名 获取data中的属性"></a>vm.属性名 获取data中的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//console.log(vm.msg);</span><br></pre></td></tr></table></figure><h4 id="vm-el-获取vue实例关联的元素"><a href="#vm-el-获取vue实例关联的元素" class="headerlink" title="vm.$el 获取vue实例关联的元素"></a>vm.$el 获取vue实例关联的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// console.log(vm.$el); //DOM对象</span><br><span class="line">// vm.$el.style.color=&apos;red&apos;;</span><br></pre></td></tr></table></figure><h4 id="vm-data-获取数据对象data"><a href="#vm-data-获取数据对象data" class="headerlink" title="vm.$data 获取数据对象data"></a>vm.$data 获取数据对象data</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// console.log(vm.$data);</span><br><span class="line">// console.log(vm.$data.msg);</span><br></pre></td></tr></table></figure><h4 id="vm-options-获取自定义属性"><a href="#vm-options-获取自定义属性" class="headerlink" title="vm.$options 获取自定义属性"></a>vm.$options 获取自定义属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// console.log(vm.$options.name);</span><br><span class="line">// console.log(vm.$options.age);</span><br><span class="line">// vm.$options.show();</span><br></pre></td></tr></table></figure><h4 id="vm-refs-获取所有添加ref属性的元素"><a href="#vm-refs-获取所有添加ref属性的元素" class="headerlink" title="vm.$refs 获取所有添加ref属性的元素"></a>vm.$refs 获取所有添加ref属性的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// console.log(vm.$refs);</span><br><span class="line">// console.log(vm.$refs.hello); //DOM对象</span><br><span class="line">// vm.$refs.hello.style.color=&apos;blue&apos;;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="vm-mount-手动挂载vue实例"><a href="#vm-mount-手动挂载vue实例" class="headerlink" title="vm.$mount()  手动挂载vue实例"></a>vm.$mount()  手动挂载vue实例</h4><pre><code>// vm.$mount(&apos;#itany&apos;);var vm=new Vue({    data:{        msg:&apos;欢迎来到南京网博&apos;,        name:&apos;tom&apos;    }}).$mount(&apos;#itany&apos;);</code></pre><h4 id="vm-destroy-销毁实例"><a href="#vm-destroy-销毁实例" class="headerlink" title="vm.$destroy() 销毁实例"></a>vm.$destroy() 销毁实例</h4><p>这个列出来只是了解一下，官方也建议使用<code>v-if</code>或<code>v-for</code>以数据驱动的方式控制子组件和生命周期</p><pre><code>// vm.$destroy();</code></pre><h4 id="vm-nextTick-callback-在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM"><a href="#vm-nextTick-callback-在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM" class="headerlink" title="vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM"></a>vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM</h4><pre><code>//修改数据vm.name=&apos;汤姆&apos;;//DOM还没更新完，Vue实现响应式并不是数据发生改变之后DOM立即变化，需要按一定的策略进行DOM更新，需要时间！！// console.log(vm.$refs.title.textContent);vm.$nextTick(function(){    //DOM更新完成，更新完成后再执行此代码    console.log(vm.$refs.title.textContent);});</code></pre><h4 id="vm-set-target-key-value-添加对象的属性和值"><a href="#vm-set-target-key-value-添加对象的属性和值" class="headerlink" title="vm.$set(target,key,value) 添加对象的属性和值"></a>vm.$set(target,key,value) 添加对象的属性和值</h4><p><a href="https://github.com/stone0090/javascript-lessons/tree/master/2.2-DOM" target="_blank" rel="noopener">关于dom</a></p><p>// vm.$set(this.food, ‘count’, 1);<br>// 注意：在<code>methods方法</code>中不能使用<code>Vue.set</code><br>// 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新<br>// Tip:Vue.set()在methods中可以写成this.$set()</p><h4 id="vm-delete-target-key-删除对象的属性"><a href="#vm-delete-target-key-删除对象的属性" class="headerlink" title="vm.$delete(target,key) 删除对象的属性"></a>vm.$delete(target,key) 删除对象的属性</h4><p>// vm.$delete(this.food, ‘count’);<br>// 注意：在<code>methods方法</code>中不能使用<code>Vue.delete</code></p><h4 id="vm-watch-expOrFn-callback-options-观察者模式"><a href="#vm-watch-expOrFn-callback-options-观察者模式" class="headerlink" title="vm.$watch( expOrFn, callback, [options] ) 观察者模式"></a>vm.$watch( expOrFn, callback, [options] ) 观察者模式</h4><p>参数：监听对象，回调方法，选项（deep/immediate）</p><p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。<br>表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p><p>实例使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式1：使用vue实例提供的$watch()方法</span><br><span class="line">vm.$watch(&apos;name&apos;,function(newValue,oldValue)&#123;</span><br><span class="line">console.log(&apos;name被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>vue提供的选项方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123; //方式2：使用vue实例提供的watch选项</span><br><span class="line">age:(newValue,oldValue) =&gt; &#123;</span><br><span class="line">console.log(&apos;age被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue);</span><br><span class="line">&#125;,</span><br><span class="line">    // 对对象监视，需要使用深度监视</span><br><span class="line">user:&#123;</span><br><span class="line">handler:(newValue,oldValue) =&gt; &#123;</span><br><span class="line">console.log(&apos;user被修改啦，原值：&apos;+oldValue.name+&apos;，新值：&apos;+newValue.name);</span><br><span class="line">&#125;,</span><br><span class="line">deep:true //深度监视，当对象中的属性发生变化时也会监视</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="vm-emit-event-…args-触发当前实例上的事件。附加参数都会传给监听器回调。"><a href="#vm-emit-event-…args-触发当前实例上的事件。附加参数都会传给监听器回调。" class="headerlink" title="vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。"></a>vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;vue实例的属性和方法&quot;&gt;&lt;a href=&quot;#vue实例的属性和方法&quot; class=&quot;headerlink&quot; title=&quot;vue实例的属性和方法&quot;&gt;&lt;/a&gt;vue实例的属性和方法&lt;/h1&gt;&lt;p&gt;仅记录部分&lt;br&gt;大部分时候是随学随用，但是学到了就来记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实例属性和方法 == 组件实例和方法 != 全局属性和方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;另外，在组件实例的&lt;code&gt;methods方法&lt;/code&gt;中不能使用全局Vue方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端 vue" scheme="http://blak-kong.github.io/categories/%E5%89%8D%E7%AB%AF-vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
      <category term="vue实例属性 计算属性" scheme="http://blak-kong.github.io/tags/vue%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>vue生命周期和计算属性</title>
    <link href="http://blak-kong.github.io/2018/05/01/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <id>http://blak-kong.github.io/2018/05/01/vue生命周期和计算属性/</id>
    <published>2018-05-01T14:30:52.000Z</published>
    <updated>2019-06-16T08:32:35.106Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="vue有八个生命周期，但只有两个是常用的"><a href="#vue有八个生命周期，但只有两个是常用的" class="headerlink" title="vue有八个生命周期，但只有两个是常用的"></a>vue有八个生命周期，但只有两个是常用的</h2><p>新手阶段只需要掌握created()和mounted()即可</p><a id="more"></a><h4 id="created-实例已经创建完成，并且已经进行数据观测和事件配置"><a href="#created-实例已经创建完成，并且已经进行数据观测和事件配置" class="headerlink" title="created(): 实例已经创建完成，并且已经进行数据观测和事件配置"></a>created(): 实例已经创建完成，并且已经进行数据观测和事件配置</h4><p>此时可用于添加数据、配置事件</p><h4 id="mounted-模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示"><a href="#mounted-模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示" class="headerlink" title="mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示"></a>mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示</h4><p>此时可用于操作html和dom元素</p><!-- more --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate()&#123;</span><br><span class="line">alert(&apos;组件实例刚刚创建，还未进行数据观测和事件配置&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">created()&#123;  //常用！！！</span><br><span class="line">alert(&apos;实例已经创建完成，并且已经进行数据观测和事件配置&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">beforeMount()&#123;</span><br><span class="line">alert(&apos;模板编译之前，还没挂载&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123; //常用！！！</span><br><span class="line">alert(&apos;模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">beforeUpdate()&#123;</span><br><span class="line">alert(&apos;组件更新之前&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">updated()&#123;</span><br><span class="line">alert(&apos;组件更新之后&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy()&#123;</span><br><span class="line">alert(&apos;组件销毁之前&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">destroyed()&#123;</span><br><span class="line">alert(&apos;组件销毁之后&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 <code>computed</code></h1><p><code>computed</code>：对于两个以上操作的复杂逻辑，应当使用计算属性（不建议仅有一个操作的简单逻辑）。</p><p>一个简单实例-反转字符串<br>html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt; 这里会输出olleh</span><br></pre></td></tr></table></figure></p><p>js代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos; // 绑定的字符串</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">      // split(&apos;&apos;)把每个字符分割，形成数组</span><br><span class="line">      // reverse()反转数组</span><br><span class="line">      // join(&apos;&apos;)拼接数组元素，返回字符串</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>通过上面的实例，我们看到在计算属性中，当我们定义方法时，是使用了计算属性的一个getter。<br>但是getter和setter往往是一对的，分别是只读只写。<br>所以这个实例，是不是漏了什么呢？</p><p>没错，它还不足以讲解计算属性，<br>这里只是说明了它可以通过调用使用。</p><p>另外，我们可以像绑定普通属性一样在模板中绑定计算属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // =&gt; &apos;olleH&apos;</span><br><span class="line">vm.message = &apos;Goodbye&apos;</span><br><span class="line">console.log(vm.reversedMessage) // =&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure></p><h2 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h2><p>我们可以将同一函数定义为一个方法而不是一个计算属性。<br>两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。</p><h4 id="computed计算属性-必须有计算"><a href="#computed计算属性-必须有计算" class="headerlink" title="computed计算属性 必须有计算"></a><code>computed计算属性</code> 必须有计算</h4><h4 id="methods方法-一般用于处理事件、改变状态。"><a href="#methods方法-一般用于处理事件、改变状态。" class="headerlink" title="methods方法 一般用于处理事件、改变状态。"></a><code>methods方法</code> 一般用于处理事件、改变状态。</h4><h4 id="计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。"><a href="#计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。" class="headerlink" title="计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。"></a>计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。</h4><p>这就意味着只要<code>数据</code>还没有发生改变，即便多次访问<code>方法</code>，计算属性也会立即返回之前的计算结果，而不必再次执行函数。<br>这也意味着计算属性将不再更新。</p><h2 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。<br>当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch</p><p>然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p><h2 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h2><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter。<br>通过给set传值，可以间接改变该计算属性的值。</p><h4 id="（绝对不能直接给计算属性赋值）"><a href="#（绝对不能直接给计算属性赋值）" class="headerlink" title="（绝对不能直接给计算属性赋值）"></a>（绝对不能直接给计算属性赋值）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">data:&#123; //普通属性</span><br><span class="line">num1:8</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123; //计算属性</span><br><span class="line">num2:&#123;</span><br><span class="line">get:function()&#123;</span><br><span class="line">console.log(&apos;num2：&apos;+new Date());</span><br><span class="line">return this.num1-1;</span><br><span class="line">&#125;,</span><br><span class="line">set:function(val)&#123; // val=111</span><br><span class="line">// console.log(&apos;修改num2值&apos;);</span><br><span class="line">// this.num2=val; 不能直接赋值num2，那不是计算,会死循环溢出</span><br><span class="line">this.num1=val;// 赋值修改num1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">change()&#123;</span><br><span class="line">// this.msg=&apos;i love you&apos;;</span><br><span class="line">this.num1=666;// 赋值修改num1</span><br><span class="line">&#125;,</span><br><span class="line">getNum2()&#123;</span><br><span class="line">console.log(new Date());</span><br><span class="line">return this.num1-1;</span><br><span class="line">&#125;,</span><br><span class="line">change2()&#123;</span><br><span class="line">this.num2=111; //传入set</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>一旦发生改变，就会运行，watch中可以自定义函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    obj: &apos;&apos;,</span><br><span class="line">    answer: &apos;请输入!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    // 如果 `obj` 发生改变，这个函数就会运行</span><br><span class="line">    obj: function (新的值, 旧的值) &#123;</span><br><span class="line">      this.answer = &apos;每次监听到getAnswer()发生变化，就把这句话赋值给answer，反正还是会被getAnswer()覆盖&apos;</span><br><span class="line">      this.getAnswer()// 还在methods方法里自定义要监听调用的函数。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h1&gt;&lt;h2 id=&quot;vue有八个生命周期，但只有两个是常用的&quot;&gt;&lt;a href=&quot;#vue有八个生命周期，但只有两个是常用的&quot; class=&quot;headerlink&quot; title=&quot;vue有八个生命周期，但只有两个是常用的&quot;&gt;&lt;/a&gt;vue有八个生命周期，但只有两个是常用的&lt;/h2&gt;&lt;p&gt;新手阶段只需要掌握created()和mounted()即可&lt;/p&gt;
    
    </summary>
    
      <category term="前端 vue" scheme="http://blak-kong.github.io/categories/%E5%89%8D%E7%AB%AF-vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
      <category term="生命周期 计算属性" scheme="http://blak-kong.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ajax学习</title>
    <link href="http://blak-kong.github.io/2018/05/01/ajax%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blak-kong.github.io/2018/05/01/ajax学习/</id>
    <published>2018-05-01T06:46:04.000Z</published>
    <updated>2019-06-16T08:30:59.389Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><h2 id="XMLHttpRequest-是-AJAX-的基础。"><a href="#XMLHttpRequest-是-AJAX-的基础。" class="headerlink" title="XMLHttpRequest 是 AJAX 的基础。"></a>XMLHttpRequest 是 AJAX 的基础。</h2><ul><li>XMLHttpRequest 对象</li></ul><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。<br>它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。<br>这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p><blockquote><p>通过它，你可以很容易的取回一个 URL 上的资源数据。</p></blockquote><p>尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。<br>而且除了 HTTP ，它还支持 file 和 ftp 协议。<br><a id="more"></a></p><h2 id="构造函数-XMLHttpRequest"><a href="#构造函数-XMLHttpRequest" class="headerlink" title="构造函数 XMLHttpRequest()"></a>构造函数 XMLHttpRequest()</h2><p>构造函数初始化一个 XMLHttpRequest 对象。必须在所有其他方法被调用前调用构造函数。</p><p>语法：</p><blockquote><p>var myRequest = new XMLHttpRequest();</p></blockquote><p>此时 myRequest 已经成为一个XMLHttpRequest 对象，可以使用XMLHttpRequest的方法。</p><h2 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class="line">xmlhttp.send(null);</span><br></pre></td></tr></table></figure></p><ul><li><p>open(method,url,async) //<br>规定请求的类型、URL 以及是否异步处理请求。</p><ul><li>method：请求的类型；GET 或 POST</li><li>url：文件在服务器上的位置</li><li>async：true（异步）或 false（同步）</li></ul></li><li><p>send(string) // 将请求发送到服务器。</p><ul><li>string：仅用于 POST 请求（如果不需要发送请求，则必须传入Null）</li></ul></li></ul><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>如果您希望通过 GET 方法发送信息，请向 URL 添加信息（在地址后面加问号，然后再添加）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure></p><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。<br>然后在 send() 方法中规定您希望发送的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);</span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br></pre></td></tr></table></figure></p><p>方法:</p><blockquote><p>setRequestHeader(header,value)</p></blockquote><ul><li>向请求添加 HTTP 头。<ul><li>header: 规定头的名称</li><li>value: 规定头的值</li></ul></li></ul><h2 id="我们使用-GET-还是-POST？"><a href="#我们使用-GET-还是-POST？" class="headerlink" title="我们使用 GET 还是 POST？"></a>我们使用 GET 还是 POST？</h2><p>GET 更简单也更快，并且在大部分情况下都能用。<br>然而，在以下情况中，请使用 POST 请求：</p><ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><h2 id="异步如何设置-True-或-False？"><a href="#异步如何设置-True-或-False？" class="headerlink" title="异步如何设置 - True 或 False？"></a>异步如何设置 - True 或 False？</h2><p>AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。<br>XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true。</p><p>通过 AJAX，JavaScript 无需等待服务器的响应，而是：</p><ul><li>在等待服务器响应时执行其他脚本</li><li>当响应就绪后对响应进行处理</li></ul><h2 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h2><p>一个完整的http响应是由状态码，响应头集合，和响应主题组成。<br>在收到响应的消息后，这些都是可以通过xhr对象的属性和方法所使用。<br>它们主要有以下4个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">responseText;作为相应主题返回的文本，（文本形式）</span><br><span class="line">responseXML;如果响应的内容是‘text/xml’或者是哦application/xml;属性中将会保存，响应数据的xml形式。DOM文档形式。</span><br><span class="line"></span><br><span class="line">status: http的状态码（数字形式）</span><br><span class="line">statusText;http状态说明，（文本形式）</span><br></pre></td></tr></table></figure><h2 id="ajax原生"><a href="#ajax原生" class="headerlink" title="ajax原生"></a>ajax原生</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//**********第一步, 获得一个xhr对象*************</span><br><span class="line"></span><br><span class="line">       var xmlHttpReq = null;// 声明一个空对象用来装入XMLHttpRequest</span><br><span class="line"></span><br><span class="line">       if (window.XMLHttpRequest)&#123;// ie7 以上的浏览器XMLHttpRequest是window的子对象</span><br><span class="line"></span><br><span class="line">              xmlHttpReq = new XMLHttpRequest();// 实例化一个XMLHttpRequest</span><br><span class="line"></span><br><span class="line">       &#125;else (window.ActiveXObject)&#123;// IE5 IE6是以ActiveXObject的方式引入XMLHttpRequest的</span><br><span class="line"></span><br><span class="line">              xmlHttpReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(xhr != null)&#123;  // 如果对象实例化成功</span><br><span class="line">              //设置回调函数</span><br><span class="line">              xhr.onreadystatechange = function()&#123;</span><br><span class="line"></span><br><span class="line">                  if(xhr.readyState == 4)&#123;  // 确定响应已经成功返回</span><br><span class="line">                       // 200可作为成功标志, 304表示请求资源没有修改, 可直接使用浏览器缓存</span><br><span class="line">                       if ((xhr.status&gt;=200 &amp;&amp; xhr.status &lt; 300 ) || xhr.status == 304)&#123;</span><br><span class="line">                             alert(xhr.responseText); // 请求成功，服务器返回的数据</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                             alert( &quot;请求失败: &quot; + xhr.status);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">//************第二步: 启动请求.******************</span><br><span class="line">              // open方法接收三个参数: 要发送的请求类型(get,post等), 请求的url和是否异步发送请求的布尔值</span><br><span class="line">              xhr.open(&quot;get&quot;,&quot;test.php&quot;,true);</span><br><span class="line">              // 调用open()方法并采用异步方式. 如果第三个参数是false, 同步执行, 则js代码会等到服务器响应之后再继续执行</span><br><span class="line"></span><br><span class="line">//*************第三步: 发送数据*******************</span><br><span class="line">              // send方法接收一个参数,即要作为请求主体发送的数据. 如果不需要通过请求主体发送数据, 则必须传入null. 因为这个参数对有些浏览器是必须的</span><br><span class="line">              xhr.send(null);</span><br><span class="line">              // 因为使用get方式提交，所以可以使用null参调用</span><br><span class="line"></span><br><span class="line">// 如果要设置请求头部信息,必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()</span><br></pre></td></tr></table></figure><ul><li>readyStatus的五个阶段<ul><li>0：未初始化。尚未调用open()方法</li><li>1：启动。已经调用open()方法，尚未调用send()方法</li><li>2：发送。已经调用send()方法，尚未接收到响应</li><li>3：接收。已经接收部分响应数据。</li><li>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。【一般只需检查这个阶段】</li></ul></li><li>获得的数据在responseText或responseXML属性中, 后者需要XML解析</li></ul><h2 id="ajax跨域"><a href="#ajax跨域" class="headerlink" title="ajax跨域"></a>ajax跨域</h2><p>三种跨域方法：<br>一、一般使用封装好的jsonp</p><p>jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。<br>普通方法: 给html标签添加脚本属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  // 创建script元素标签，设置其属性</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  // 给script标签，设置标签属性</span><br><span class="line">  script.src = src;</span><br><span class="line">  // 把script标签添加成为body的子标签</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">// 提供jsonp服务的url地址，并调用foo函数</span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>jqurey方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> $.ajax(&#123;</span><br><span class="line">    url: &quot;url&quot;,</span><br><span class="line">    type: &quot;GET&quot;,</span><br><span class="line">    dataType: &quot;jsonp&quot;,  //指定服务器返回的数据类型</span><br><span class="line">    jsonp: &quot;cb&quot;,   //指定参数名称</span><br><span class="line">    jsonpCallback: &quot;showData&quot;,  //指定回调函数名称</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">        console.log(&quot;调用success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>二、CORS是跨源资源分享（在后端设置头部支持，允许跨域）</p><ul><li>Access-Control-Allow-Origin:*</li></ul><p>三、设置代理请求（不会）</p><h1 id="vue使用Ajax"><a href="#vue使用Ajax" class="headerlink" title="vue使用Ajax"></a>vue使用Ajax</h1><p>本身不支持发送AJAX请求，需要使用vue-resource、axios等插件实现</p><h2 id="axios使用Ajax"><a href="#axios使用Ajax" class="headerlink" title="axios使用Ajax"></a>axios使用Ajax</h2><p>注意：axios不支持跨域</p><p>参考github上的官方文档，[options]是可以使用的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios([options])  </span><br><span class="line">axios.get(url[,options]);</span><br><span class="line">    传参方式：</span><br><span class="line">        1.通过url传参</span><br><span class="line">        2.通过params选项传参</span><br><span class="line">axios.post(url,data,[options]);</span><br><span class="line">    axios默认发送数据时，数据格式是Request Payload，并非我们常用的Form Data格式，</span><br><span class="line">    所以参数必须要以键值对形式传递，不能以json形式传参</span><br><span class="line">    传参方式：</span><br><span class="line">        1.自己拼接为键值对</span><br><span class="line">        2.使用transformRequest，在请求发送前将请求数据进行转换</span><br><span class="line">        3.如果使用模块化开发，可以使用qs模块进行转换</span><br><span class="line"></span><br><span class="line">axios本身并不支持发送跨域的请求，没有提供相应的API，作者也暂没计划在axios添加支持发送跨域请求，所以只能使用第三方库</span><br></pre></td></tr></table></figure></p><p>get请求示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">写法一（只能用这个，参考上面的传参方式）</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then(function (response) &#123;// 成功</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;// 失败</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">写法二</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="使用vue-resource发送跨域请求"><a href="#使用vue-resource发送跨域请求" class="headerlink" title="使用vue-resource发送跨域请求"></a>使用vue-resource发送跨域请求</h2><p>基本用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用this.$http发送请求  </span><br><span class="line">    this.$http.get(url, [options])</span><br><span class="line">    this.$http.head(url, [options])</span><br><span class="line">    this.$http.delete(url, [options])</span><br><span class="line">    this.$http.jsonp(url, [options])</span><br><span class="line">    this.$http.post(url, [body], [options])</span><br><span class="line">    this.$http.put(url, [body], [options])</span><br><span class="line">    this.$http.patch(url, [body], [options])</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.$http.jsonp(&apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&apos;,&#123;</span><br><span class="line">params:&#123;</span><br><span class="line">wd:this.keyword</span><br><span class="line">&#125;,</span><br><span class="line">jsonp:&apos;cb&apos;</span><br><span class="line">&#125;).then(resp =&gt; &#123;</span><br><span class="line">this.myData=resp.data.s;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;ajax&quot;&gt;&lt;a href=&quot;#ajax&quot; class=&quot;headerlink&quot; title=&quot;ajax&quot;&gt;&lt;/a&gt;ajax&lt;/h1&gt;&lt;h2 id=&quot;XMLHttpRequest-是-AJAX-的基础。&quot;&gt;&lt;a href=&quot;#XMLHttpRequest-是-AJAX-的基础。&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest 是 AJAX 的基础。&quot;&gt;&lt;/a&gt;XMLHttpRequest 是 AJAX 的基础。&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;XMLHttpRequest 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。&lt;br&gt;它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。&lt;br&gt;这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过它，你可以很容易的取回一个 URL 上的资源数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。&lt;br&gt;而且除了 HTTP ，它还支持 file 和 ftp 协议。&lt;br&gt;
    
    </summary>
    
      <category term="JS学习笔记 vue学习" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-vue%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ajax 网络请求 js" scheme="http://blak-kong.github.io/tags/ajax-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-js/"/>
    
  </entry>
  
  <entry>
    <title>js面向对象（原型链）</title>
    <link href="http://blak-kong.github.io/2018/05/01/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%89/"/>
    <id>http://blak-kong.github.io/2018/05/01/js面向对象（原型链）/</id>
    <published>2018-04-30T18:38:44.000Z</published>
    <updated>2019-06-16T08:31:46.401Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h1 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h1><p>原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 <strong>proto</strong> 属性指向创建它的构造函数的 prototype（原型）属性。<br>原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、<strong>proto</strong> 这五个概念入手。</p><a id="more"></a><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。<br>比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。<br>下面示例代码对「普通对象」和「函数对象」进行了区分。</p><p>普通对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = new Object();</span><br></pre></td></tr></table></figure></p><p>函数对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;&#125;;</span><br><span class="line">var f2 = function()&#123;&#125;;</span><br><span class="line">var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);</span><br></pre></td></tr></table></figure></p><p>简单的说，凡是使用 function 关键字或 Function 构造函数创建的对象都是函数对象。<br>而且，只有函数对象才拥有 <code>prototype</code> （原型）属性。</p><h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a><code>constructor</code> 构造函数</h2><p>函数还有一种用法，就是把它作为构造函数使用。<br>像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。<br>此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。</p><p>构造原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 构造函数首字母应大写，便于区分普通函数</span><br><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class="line">&lt;script/&gt;</span><br></pre></td></tr></table></figure></p><h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><code>new</code> 操作符</h2><p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象。</li></ol><p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。</p><blockquote><p>归根结底，使用 <code>new</code> 关键字，可以在后面跟随一个<code>函数调用</code>。</p></blockquote><p>只要通过 new 操作符来调用，那它就可以作为构造函数；<br>而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。</p><h2 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h2><p>构造函数模式虽然好用，但也并非没有缺点。<br>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</p><blockquote><p>函数名是指针，使用<code>构造函数调用</code>创建新对象，解决了内存覆盖问题：<br>但所有对象都是深拷贝，并没有变方便。没有必要创建两个完成同样任务的 Function 实例</p></blockquote><h2 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype 原型"></a><code>prototype</code> 原型</h2><p>我们创建的每个函数都有一个 prototype（原型）属性。<br>使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。<br>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &quot;Stone&quot;;</span><br><span class="line">Person.prototype.age = 28;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();   // &quot;Stone&quot;</span><br><span class="line"></span><br><span class="line">var person2 = new Person();</span><br><span class="line">person2.sayName();   // &quot;Stone&quot;</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName == person2.sayName);  // true</span><br></pre></td></tr></table></figure><p>此例子有缺陷，因为共享了内存。</p><p>若是原型链中存在引用类型，那么一个值改变，所有值都会跟着改变。</p><h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p>在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针（<strong>potor</strong>）。就拿前面的例子来说，Person.prototype.constructor 指向 Person。<br>而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p><p>此时，我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。<br>如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。</p><p>这就是js的屏蔽方法。<br>当为对象实例添加一个属性时，这个属性就会屏蔽原型中保存的同名属性</p><h2 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h2><p>为了摆脱每添加一个属性和方法就要敲一遍 <code>Person.prototype</code><br>为了减少不必要的输入，也为了从视觉上更好地封装原型的功能<br>常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意：此时 <code>constructor</code> 属性不再指向 Person 了。尽管仍能使用。</p><p>解决办法是把它加回去<code>constructor : Person</code></p><p>注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。<br>默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器</span><br><span class="line">// Object.defineProperty(obj, prop, descriptor)</span><br><span class="line">// 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</span><br><span class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>obj: 要在其上定义属性的对象。<br>prop: 要定义或修改的属性的名称。<br>descriptor: 将被定义或修改的属性描述符。</p><h2 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h2><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var friend = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = function()&#123;</span><br><span class="line">    console.log(&quot;hi&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">friend.sayHi();   // &quot;hi&quot;（没有问题！）</span><br></pre></td></tr></table></figure></p><p>其原因可以归结为实例与原型之间的松散连接关系。<br>因为实例与原型之间的连接只不过是一个指针，而非一个副本.</p><p>但如果是重写整个原型对象，那么情况就不一样了。<br>我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]的 <code>__potoy__</code> 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p><blockquote><p>请记住：实例中的指针仅指向原型，而不指向构造函数。</p></blockquote><h2 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h2><p>原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，问题很突出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    friends : [&quot;ZhangSan&quot;, &quot;LiSi&quot;],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;WangWu&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person2.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person1.friends === person2.friends);  // true</span><br></pre></td></tr></table></figure><blockquote><p>引用类型单独占一块堆内存,连原型也只是指针指向数组</p></blockquote><h2 id="构造函数和原型结合"><a href="#构造函数和原型结合" class="headerlink" title="构造函数和原型结合"></a>构造函数和原型结合</h2><h4 id="构造函数用于定义实例属性，而原型用于定义方法和共享的属性。"><a href="#构造函数用于定义实例属性，而原型用于定义方法和共享的属性。" class="headerlink" title="构造函数用于定义实例属性，而原型用于定义方法和共享的属性。"></a>构造函数用于定义实例属性，而原型用于定义方法和共享的属性。</h4><p>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。<br>下面的代码重写了前面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;ZhangSan&quot;, &quot;LiSi&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;WangWu&quot;);</span><br><span class="line">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person2.friends);    // &quot;ZhangSan,LiSi&quot;</span><br><span class="line">console.log(person1.friends === person2.friends);    // false</span><br></pre></td></tr></table></figure><p>构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 <strong>proto</strong> , 指向构造函数的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure></p><p>Object.<strong>proto</strong> = Object.prototype;</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>JavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。<br>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>简单回顾一下构造函数、原型和实例的关系：</p><p>每个构造函数都有一个原型对象(调用对象)<br>原型对象都包含一个指向构造函数的指针(prototype)<br>而实例都包含一个指向原型对象的内部指针。(<strong>proto</strong>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;原型及原型链&quot;&gt;&lt;a href=&quot;#原型及原型链&quot; class=&quot;headerlink&quot; title=&quot;原型及原型链&quot;&gt;&lt;/a&gt;原型及原型链&lt;/h1&gt;&lt;p&gt;原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 &lt;strong&gt;proto&lt;/strong&gt; 属性指向创建它的构造函数的 prototype（原型）属性。&lt;br&gt;原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、&lt;strong&gt;proto&lt;/strong&gt; 这五个概念入手。&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象 原型链 js" scheme="http://blak-kong.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%E9%93%BE-js/"/>
    
  </entry>
  
  <entry>
    <title>基本包装类型</title>
    <link href="http://blak-kong.github.io/2018/04/30/%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blak-kong.github.io/2018/04/30/基本包装类型/</id>
    <published>2018-04-30T10:16:23.000Z</published>
    <updated>2019-06-16T08:33:32.456Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：Boolean、Number 和 String。<br>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。<br>来看下面的例子。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 = &quot;some text&quot;;</span><br><span class="line">var s2 = s1.substring(2);</span><br></pre></td></tr></table></figure><p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。<br>而下一行调用了 s1 的 substring() 方法，并将返回的结果保存在了 s2 中。<br>我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。</p><!-- more --><p>其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。<br>当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。<br>而在读取模式中访问字符串时，后台都会自动完成下列处理。</p><ol><li>创建 String 类型的一个实例；</li><li>在实例上调用指定的方法；</li><li>销毁这个实例。</li><li>可以将以上三个步骤想象成是执行了下列 JavaScript 代码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new String(&quot;some text&quot;);</span><br><span class="line">var s2 = s1.substring(2);</span><br><span class="line">s1 = null;</span><br></pre></td></tr></table></figure><p>经过此番处理，基本的字符串值就变得跟对象一样了。<br>而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。</p><ul><li>引用类型与基本包装类型的主要区别就是对象的生存期。</li></ul><p>使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。<br>而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</p><p>（使用 new 操作符创建的String引用类型的实例，优于自动创建的基本包装类型）</p><p>这意味着我们不能在运行时为基本类型值添加属性和方法。</p><hr><p>以下为简略概括，关于基本包装类型</p><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>任何时候，我们都不建议直接实例化Boolean类型。<br>它虽然是与布尔值对应的引用类型，但是他无法用作布尔值判断，意义不明。</p><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>大多数时候，我们不建议直接实例化Number类型，原因和Boolean类型一样，影响类型判断。<br>Number类型是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时，向其中传递相应的数值。</p><p>例子：var numberObject = new Number(10)  // 十进制</p><p>关于Number类型，我们可以进行数制转换、字符转换。</p><p>但一般不建议使用，我们应该尽量使用Number对象及其方法。（需要用到时，百度即可）<br>（Number类型和Number对象是不一样的，Number对象是基本类型的实例）<br>（Number类型是与<code>数字值</code>对应的引用类型，它只是基本类型的数值的实例。）</p><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String 类型是字符串的<code>对象包装类型</code>，可以像下面这样使用 String 构造函数来创建。</p><blockquote><p>var stringObject = new String(“hello world”);</p></blockquote><p>String 对象的方法也可以在所有基本的字符串值中访问到。<br>其中，继承的 valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。</p><blockquote><p>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。</p></blockquote><p>来看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">console.log(stringValue.length);     // 11</span><br></pre></td></tr></table></figure></p><p>应该注意的是，即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;大家好&quot;;</span><br><span class="line">console.log(stringValue.length);     // 3</span><br></pre></td></tr></table></figure><p>String 类型提供了很多方法，用于辅助完成对 JavaScript 中字符串的解析和操作。</p><p><a href="https://github.com/stone0090/javascript-lessons/tree/master/1.11-PrimitiveWrapperObjects" target="_blank" rel="noopener">方法</a></p><h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4><h5 id="访问字符串中特定位置的字符：charAt-和-charCodeAt"><a href="#访问字符串中特定位置的字符：charAt-和-charCodeAt" class="headerlink" title="访问字符串中特定位置的字符：charAt() 和 charCodeAt()"></a>访问字符串中特定位置的字符：charAt() 和 charCodeAt()</h5><p>这两个方法都接收一个参数，即基于0的字符位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">console.log(stringValue.charAt(1));  // &quot;e&quot;</span><br></pre></td></tr></table></figure><p>charAt(): 以单字符字符串的形式返回给定位置的那个字符<br>charCodeAt(): 返回字符编码</p><p>ECMAScript 5 还定义了另一个访问个别字符的方法。<br>在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello world&quot;;</span><br><span class="line">console.log(stringValue[1]);   // &quot;e&quot;</span><br></pre></td></tr></table></figure></p><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><h5 id="concat-用于将一或多个字符串拼接起来"><a href="#concat-用于将一或多个字符串拼接起来" class="headerlink" title="concat() 用于将一或多个字符串拼接起来"></a><code>concat()</code> 用于将一或多个字符串拼接起来</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &quot;hello &quot;;</span><br><span class="line">var result = stringValue.concat(&quot;world&quot;, &quot;!&quot;);</span><br><span class="line"></span><br><span class="line">console.log(result);        // &quot;hello world!&quot;</span><br><span class="line">console.log(stringValue);   // &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>基于子字符串创建新字符串的方法：slice()、substr() 和 substring()<br>slice(start,end) 从已有的<code>数组</code>中返回选定的元素。<br>substr(start,length) 在<code>字符串</code>中抽取从 start 下标开始的指定数目的字符。<br>substring(start,stop) 提取<code>字符串</code>中介于两个指定下标之间的字符。</p><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><p>从字符串中查找子字符串的方法：indexOf() 和 lastIndexOf()<br>这两个方法都接收两个参数：要<code>查找的项</code>和（可选的）<code>查找起点位置的索引</code></p><p>indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。<br>lastIndexOf() 返回一个指定的字符串值最后出现的位置。</p><p>前面学过，indexOf()查找时会判断是否全等，详情氪查看js循环的笔记。</p><blockquote><p>它们在比较第一个参数与数组中的每一项时，会使用全等操作符；</p></blockquote><h4 id="trim-方法–清除前后空格"><a href="#trim-方法–清除前后空格" class="headerlink" title="trim() 方法–清除前后空格"></a>trim() 方法–清除前后空格</h4><p>这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p><h4 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h4><p>toLowerCase() 和 toUpperCase()</p><p>小写和大写</p><h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4><p><code>replace()</code> 在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;a blue and a blue car&quot;;</span><br><span class="line">var n=str.replace(/blue/g,&quot;red&quot;); // a red and a red car</span><br></pre></td></tr></table></figure></p><p><code>split()</code> 用于把一个字符串分割成字符串数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;2:3:4:5&quot;.split(&quot;:&quot;)//将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">&quot;|a|b|c&quot;.split(&quot;|&quot;)    //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p><h4 id="localeCompare-方法–比较两个字符串"><a href="#localeCompare-方法–比较两个字符串" class="headerlink" title="localeCompare() 方法–比较两个字符串"></a>localeCompare() 方法–比较两个字符串</h4><h4 id="fromCharCode-方法–接收一或多个字符编码，然后将它们转换成一个字符串。"><a href="#fromCharCode-方法–接收一或多个字符编码，然后将它们转换成一个字符串。" class="headerlink" title="fromCharCode() 方法–接收一或多个字符编码，然后将它们转换成一个字符串。"></a>fromCharCode() 方法–接收一或多个字符编码，然后将它们转换成一个字符串。</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本包装类型&quot;&gt;&lt;a href=&quot;#基本包装类型&quot; class=&quot;headerlink&quot; title=&quot;基本包装类型&quot;&gt;&lt;/a&gt;基本包装类型&lt;/h2&gt;&lt;p&gt;为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：Boolean、Number 和 String。&lt;br&gt;实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。&lt;br&gt;来看下面的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基本包装类型 js" scheme="http://blak-kong.github.io/tags/%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B-js/"/>
    
  </entry>
  
  <entry>
    <title>js函数理解</title>
    <link href="http://blak-kong.github.io/2018/04/30/js%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3/"/>
    <id>http://blak-kong.github.io/2018/04/30/js函数理解/</id>
    <published>2018-04-30T08:43:47.000Z</published>
    <updated>2019-06-16T08:31:35.795Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数是一段代码，它只定义一次，但可以被执行或调用任意次。<br>在 JavaScript 里，函数即对象，程序可以随意操控它们。<br>（万物皆对象）</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>在 JavaScript 中，函数实际上是对象，每个函数都是 Function 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p><p>函数通常有以下3中定义方式。例如：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 写法一：函数声明（推荐写法）</span><br><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二：函数表达式（推荐写法）</span><br><span class="line">var sum = function(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三：Function 构造函数（不推荐写法）</span><br><span class="line">var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。</p></blockquote><p>换句话说，一个函数可能会有多个名字。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(10,10));        // 20</span><br><span class="line"></span><br><span class="line">var anotherSum = sum;</span><br><span class="line">console.log(anotherSum(10,10)); // 20</span><br><span class="line"></span><br><span class="line">sum = null;</span><br><span class="line">console.log(anotherSum(10,10)); // 20</span><br></pre></td></tr></table></figure><h2 id="没有重载–函数名是指针"><a href="#没有重载–函数名是指针" class="headerlink" title="没有重载–函数名是指针"></a>没有重载–函数名是指针</h2><p>将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。<br>(因为改变函数体内容，只是指向改变，内存并没有清空)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function addSomeNumber(num)&#123;</span><br><span class="line">    return num + 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addSomeNumber(num, num2) &#123;</span><br><span class="line">    return num + 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = addSomeNumber(100);    // 300</span><br></pre></td></tr></table></figure></p><p>显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。<br>以上代码实际上与下面的代码没有什么区别：<br>(因为改变函数体内容，只是指向改变，内存并没有清空)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var addSomeNumber = function (num)&#123;</span><br><span class="line">    return num + 100;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">addSomeNumber = function (num, num2) &#123;</span><br><span class="line">    return num + 200;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var result = addSomeNumber(100);    // 300</span><br></pre></td></tr></table></figure></p><h2 id="函数声明与函数表达式–变量提升"><a href="#函数声明与函数表达式–变量提升" class="headerlink" title="函数声明与函数表达式–变量提升"></a>函数声明与函数表达式–变量提升</h2><p>解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。<br>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；—-变量提升<br>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(10,10)); // 20</span><br><span class="line">function sum(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(10,10)); // Uncaught TypeError: sum is not a function</span><br><span class="line">var sum = function(num1, num2)&#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。<br>也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callSomeFunction(someFunction, someArgument)&#123;</span><br><span class="line">    return someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。<br>然后，就可以像下面的例子一样传递函数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function add10(num)&#123;</span><br><span class="line">    return num + 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result1 = callSomeFunction(add10, 10);</span><br><span class="line">console.log(result1);   // 20</span><br><span class="line"></span><br><span class="line">function getGreeting(name)&#123;</span><br><span class="line">    return &quot;Hello, &quot; + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;);</span><br><span class="line">console.log(result2);   // &quot;Hello, Nicholas&quot;</span><br></pre></td></tr></table></figure></p><h2 id="函数的形参和实参"><a href="#函数的形参和实参" class="headerlink" title="函数的形参和实参"></a>函数的形参和实参</h2><p>在函数内部，有两个特殊的对象：arguments 和 this。<br>其中，arguments 是一个类数组对象，包含着传入函数中的所有参数。<br>虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。<br>请看下面这个非常经典的阶乘函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">if (num &lt;= 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * factorial(num-1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。<br>但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。<br>为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(num)&#123;</span><br><span class="line">    if (num &lt;=1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * arguments.callee(num-1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个重写后的 factorial() 函数的函数体内，没有再引用函数名 factorial。<br>这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这里需要结合上一段代码</span><br><span class="line">var trueFactorial = factorial;</span><br><span class="line"></span><br><span class="line">factorial = function()&#123;// 重置了factorial函数指向</span><br><span class="line">    return 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(trueFactorial(5));  // 120</span><br><span class="line">console.log(factorial(5));      // 0</span><br></pre></td></tr></table></figure></p><h4 id="arguments用法：使用在函数体中，可用-arguments-callee-指向拥有这个-arguments-对象的函数。"><a href="#arguments用法：使用在函数体中，可用-arguments-callee-指向拥有这个-arguments-对象的函数。" class="headerlink" title="arguments用法：使用在函数体中，可用 arguments.callee 指向拥有这个 arguments 对象的函数。"></a>arguments用法：使用在函数体中，可用 <code>arguments.callee</code> 指向拥有这个 arguments 对象的函数。</h4><h2 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h2><p>JavaScript 中的函数是对象，因此函数也有属性和方法。<br>每个函数都包含两个属性：length 和 prototype。<br>其中，length 属性表示函数希望接收的命名参数的个数，也就是形参个数。</p><p>不过这不重要。</p><p>接下来要说的才是属性与方法。<br>JavaScript中的每一个Function对象都有一个apply()方法和一个call()方法，它们的语法分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*apply()方法*/</span><br><span class="line">function.apply(thisObj[, argArray])</span><br><span class="line"></span><br><span class="line">/*call()方法*/</span><br><span class="line">function.call(thisObj[, arg1[, arg2[, [,...argN]]]]);</span><br></pre></td></tr></table></figure><p>它们各自的定义：</p><h4 id="apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。"><a href="#apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。" class="headerlink" title="apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。"></a>apply：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象应用B对象的方法。</h4><blockquote><p>例如：B.apply(A, arguments);即A对象应用B对象的方法。</p></blockquote><h4 id="call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。"><a href="#call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。" class="headerlink" title="call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。"></a>call：调用一个对象的一个方法，用另一个对象替换当前对象。即A对象调用B对象的方法。</h4><blockquote><p>例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p></blockquote><p>它们的共同之处：<br>都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。</p><p>它们的不同之处：</p><p>apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。<br>如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。</p><p>call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。 </p><p>实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。</p><p>基本用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">  return a+b;  </span><br><span class="line">&#125;</span><br><span class="line">function sub(a,b)&#123;</span><br><span class="line">  return a-b;  </span><br><span class="line">&#125;</span><br><span class="line">var a1 = add.apply(sub,[4,2]);　　//sub应用add的方法</span><br><span class="line">var a2 = sub.apply(add,[4,2]);</span><br><span class="line">alert(a1);  //6     </span><br><span class="line">alert(a2);  //2</span><br><span class="line"></span><br><span class="line">/*call的用法*/</span><br><span class="line">var a2 = add.call(sub,4,2); //sub调用add的方法</span><br><span class="line">alert(a2); //6</span><br></pre></td></tr></table></figure></p><h2 id="关卡："><a href="#关卡：" class="headerlink" title="关卡："></a>关卡：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 挑战一，合并任意个数的字符串</span><br><span class="line">var concat = function()&#123;</span><br><span class="line">    var result = &apos;&apos;;</span><br><span class="line">    for(var i = 0; i &lt; arguments.length; i ++)&#123; // 遍历arguments实参长度</span><br><span class="line">        result += arguments[i]; // 把所有实参元素累加</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(concat(&apos;st&apos;,&apos;on&apos;,&apos;e&apos;));  // stone</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;p&gt;函数是一段代码，它只定义一次，但可以被执行或调用任意次。&lt;br&gt;在 JavaScript 里，函数即对象，程序可以随意操控它们。&lt;br&gt;（万物皆对象）&lt;/p&gt;
&lt;h2 id=&quot;函数定义&quot;&gt;&lt;a href=&quot;#函数定义&quot; class=&quot;headerlink&quot; title=&quot;函数定义&quot;&gt;&lt;/a&gt;函数定义&lt;/h2&gt;&lt;p&gt;在 JavaScript 中，函数实际上是对象，每个函数都是 Function 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。&lt;/p&gt;
&lt;p&gt;函数通常有以下3中定义方式。例如：&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="函数 js" scheme="http://blak-kong.github.io/tags/%E5%87%BD%E6%95%B0-js/"/>
    
  </entry>
  
  <entry>
    <title>js数组方法</title>
    <link href="http://blak-kong.github.io/2018/04/29/js%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>http://blak-kong.github.io/2018/04/29/js数组方法/</id>
    <published>2018-04-29T08:55:21.000Z</published>
    <updated>2019-04-07T14:56:55.707Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h2 id="使用数组字面量创建数组（推荐）"><a href="#使用数组字面量创建数组（推荐）" class="headerlink" title="使用数组字面量创建数组（推荐）"></a>使用数组字面量创建数组（推荐）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var empty = [];</span><br></pre></td></tr></table></figure><h2 id="使用-new-关键字创建数组"><a href="#使用-new-关键字创建数组" class="headerlink" title="使用 new 关键字创建数组"></a>使用 <code>new</code> 关键字创建数组</h2><p>使用 new 关键字调用构造函数 Array() 是创建数组的另一种方法。<br>我们可以用三种方式调用构造函数。例如：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 调用时没有参数</span><br><span class="line">var a = new Array();</span><br><span class="line"></span><br><span class="line">// 调用时有一个数值参数，它指定长度</span><br><span class="line">var a = new Array(10); </span><br><span class="line"></span><br><span class="line">// 显式指定多个数组元素或者数组的一个非数值元素</span><br><span class="line">var a = new Array(5, 4, 3, 2, 1, &quot;testing&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><h4 id="稀疏数组就是包含从0开始的不连续索引的数组。"><a href="#稀疏数组就是包含从0开始的不连续索引的数组。" class="headerlink" title="稀疏数组就是包含从0开始的不连续索引的数组。"></a>稀疏数组就是包含从0开始的不连续索引的数组。</h4><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><p>经典for循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.keys(o);   // 获得 o 对象属性名组成的数组</span><br><span class="line">var values = []              // 在数组中存储匹配属性的值</span><br><span class="line">for(var i = 0; i &lt; keys.length; i++) &#123;  // 对于数组中每个索引</span><br><span class="line">    var key = keys[i];                  // 获得索引处的键值</span><br><span class="line">    values[i] = o[key];                 // 在 values 数组中保存属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。<br>forEach(值,索引,数组对象本身) 循环所有元素并回调，传入的参数仅表示是否回调<br>具体案例参考另一篇博客，<a href="https://blak-kong.github.io/2018/04/28/javascript%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/#forEach-遍历所有元素并回调">javascript循环语句</a></p><h2 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a>数组检测</h2><h4 id="Array-isArray-es5语法：给定一个未知的对象，判定它是否为数组。"><a href="#Array-isArray-es5语法：给定一个未知的对象，判定它是否为数组。" class="headerlink" title="Array.isArray() es5语法：给定一个未知的对象，判定它是否为数组。"></a><code>Array.isArray()</code> es5语法：给定一个未知的对象，判定它是否为数组。</h4><h2 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h2><p>转换方法<code>toString()</code>：当调用数组的 toString() 方法，会返回以逗号分隔数组中每个值的字符串。为了创建这个字符串会调用数组每一项的 toString() 方法。</p><p>转换方法<code>toLocaleString()</code>：基本同上。但内置本地字符串格式转换功能（时间格式转换）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sd=new Date()</span><br><span class="line">sd.toLocaleString() //&quot;2017/2/15 上午11:21:31&quot;</span><br><span class="line">sd.toString() //&quot;Wed Feb 15 2017 11:21:31 GMT+0800 (CST)&quot;</span><br></pre></td></tr></table></figure></p><h4 id="join-可以使用不同的分隔符来构建字符串数组。"><a href="#join-可以使用不同的分隔符来构建字符串数组。" class="headerlink" title="join() 可以使用不同的分隔符来构建字符串数组。"></a><code>join()</code> 可以使用不同的分隔符来构建字符串数组。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">console.log(colors.join(&quot;,&quot;));    // red,green,blue</span><br><span class="line">console.log(colors.join(&quot;||&quot;));   // red||green||blue</span><br></pre></td></tr></table></figure><h4 id="split-用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。"><a href="#split-用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。" class="headerlink" title="split() 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。"></a><code>split()</code> 用于把一个字符串分割成字符串数组。用于把一个字符串分割成字符串数组。</h4><p>第一个参数是指定字符串或正则表达式。若传入第二个参数，可以指定数组长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;2:3:4:5&quot;.split(&quot;:&quot;)//将返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">&quot;|a|b|c&quot;.split(&quot;|&quot;)    //将返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure></p><h2 id="栈方法和队列方法"><a href="#栈方法和队列方法" class="headerlink" title="栈方法和队列方法"></a>栈方法和队列方法</h2><h3 id="栈方法（后进先出）：push-和-pop"><a href="#栈方法（后进先出）：push-和-pop" class="headerlink" title="栈方法（后进先出）：push() 和 pop()"></a>栈方法（后进先出）：<code>push()</code> 和 <code>pop()</code></h3><p>// 越后面加入数组的，越先被<code>pop()</code>移除<br><code>push()</code> 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。<br><code>pop()</code> 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var colors = [];                            // 创建一个数组</span><br><span class="line">var count = colors.push(&quot;red&quot;, &quot;green&quot;);    // 推入两项</span><br><span class="line">console.log(count);                         // 2，数组的长度</span><br><span class="line"></span><br><span class="line">count = colors.push(&quot;black&quot;);               // 推入另一项</span><br><span class="line">console.log(count);                         // 3，数组的长度</span><br><span class="line"></span><br><span class="line">var item = colors.pop();                    // 取得最后一项</span><br><span class="line">console.log(item);                          // &quot;black&quot;,返回移除的项</span><br><span class="line">console.log(colors.length);                 // 2，数组的长度</span><br></pre></td></tr></table></figure><h3 id="队列方法（先进先出）push-和-shift"><a href="#队列方法（先进先出）push-和-shift" class="headerlink" title="队列方法（先进先出）push() 和 shift()"></a>队列方法（先进先出）<code>push()</code> 和 <code>shift()</code></h3><p><code>push()</code> 把任意数量参数逐个添加到数组末尾，并返回修改后数组的长度。<br><code>shift()</code> 从数组前端移除第一项，减少数组的 length 值，然后返回移除的项。</p><h3 id="反向队列方法（反方向先进先出）unshift-和pop"><a href="#反向队列方法（反方向先进先出）unshift-和pop" class="headerlink" title="反向队列方法（反方向先进先出）unshift()和pop()"></a>反向队列方法（反方向先进先出）<code>unshift()</code>和<code>pop()</code></h3><p><code>unshift()</code> 把任意数量参数逐个添加到数组前端，然后返回length 值<br><code>pop()</code> 从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</p><h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><p>数组中有两个重排序的方法：reverse() 和 sort()。</p><h4 id="reverse-方法可以反转数组元素的顺序。"><a href="#reverse-方法可以反转数组元素的顺序。" class="headerlink" title="reverse() 方法可以反转数组元素的顺序。"></a>reverse() 方法可以反转数组元素的顺序。</h4><h4 id="sort-方法可以按升序或降序排列数组元素。"><a href="#sort-方法可以按升序或降序排列数组元素。" class="headerlink" title="sort() 方法可以按升序或降序排列数组元素。"></a>sort() 方法可以按升序或降序排列数组元素。</h4><p>sort具体用法，可以查看<a href="https://blak-kong.github.io/2018/04/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjs%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/#more">深入理解js对象排序-sort()</a></p><p>通用代码演示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line"></span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure></p><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h4 id="concat-基于当前数组中的所有项创建一个新数组。"><a href="#concat-基于当前数组中的所有项创建一个新数组。" class="headerlink" title="concat() 基于当前数组中的所有项创建一个新数组。"></a><code>concat()</code> 基于当前数组中的所有项创建一个新数组。</h4><p>这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">var b = a.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);//基于a创建新数组</span><br><span class="line"></span><br><span class="line">console.log(a);     // red,green,blue</span><br><span class="line">console.log(b);    // red,green,blue,yellow,black,brown</span><br></pre></td></tr></table></figure><h4 id="slice-它能够基于当前数组中的一或多个项创建一个新数组。"><a href="#slice-它能够基于当前数组中的一或多个项创建一个新数组。" class="headerlink" title="slice() 它能够基于当前数组中的一或多个项创建一个新数组。"></a><code>slice()</code> 它能够基于当前数组中的一或多个项创建一个新数组。</h4><p>slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。</p><p>在只有一个参数的情况下，slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。<br>如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。</p><ul><li>注意，slice() 方法不会影响原始数组。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];</span><br><span class="line">var a1 = a.slice(1);</span><br><span class="line">var a2 = a.slice(1,4);</span><br><span class="line"></span><br><span class="line">console.log(a1);   // green,blue,yellow,purple</span><br><span class="line">console.log(a2);   // green,blue,yellow</span><br></pre></td></tr></table></figure><h4 id="splice-它的主要用途是向数组的中部插入元素-或者进行删除、替换"><a href="#splice-它的主要用途是向数组的中部插入元素-或者进行删除、替换" class="headerlink" title="splice() 它的主要用途是向数组的中部插入元素,或者进行删除、替换"></a><code>splice()</code> 它的主要用途是向数组的中部插入元素,或者进行删除、替换</h4><p>写法：Array.splice(起始位置，删除数量，插入)</p><p>只写前两项，是从指定位置开始删除<br>不写第二项，写第三项，是插入元素<br>三个都写，则是替换指定位置的元素</p><h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>ECMAScript 5 为数组实例添加了两个位置方法：<br>indexOf() 和 lastIndexOf()。<br>这两个方法都接收两个参数：要<code>查找的项</code>和（可选的）<code>查找起点位置的索引</code></p><h4 id="indexOf-方法从数组的开头（位置0）开始向后查找"><a href="#indexOf-方法从数组的开头（位置0）开始向后查找" class="headerlink" title="indexOf() 方法从数组的开头（位置0）开始向后查找"></a><code>indexOf()</code> 方法从数组的开头（位置0）开始向后查找</h4><h4 id="lastIndexOf-方法则从数组的末尾开始向前查找。"><a href="#lastIndexOf-方法则从数组的末尾开始向前查找。" class="headerlink" title="lastIndexOf() 方法则从数组的末尾开始向前查找。"></a><code>lastIndexOf()</code> 方法则从数组的末尾开始向前查找。</h4><p>注意：最终返回的索引，都是数组开头往后算。</p><p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1。<br>它们在比较第一个参数与数组中的每一项时，会使用全等操作符；<br>也就是说，要求查找的项必须严格相等（就像使用 === 一样）。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">console.log(numbers.indexOf(4));          // 3 从前往后，查找数组第一个4</span><br><span class="line">console.log(numbers.lastIndexOf(4));      // 5 从后往前，查找数组第一个4</span><br><span class="line">console.log(numbers.indexOf(4, 4));       // 5 从前往后，从索引4开始查找元素4</span><br><span class="line">console.log(numbers.lastIndexOf(4, 4));   // 3 从后往前，从索引-4开始往前查找元素4</span><br><span class="line"></span><br><span class="line">var person = &#123; name: &quot;Nicholas&quot; &#125;;</span><br><span class="line">var people = [&#123; name: &quot;Nicholas&quot; &#125;];</span><br><span class="line">var morePeople = [person];</span><br><span class="line">console.log(people.indexOf(person));      // -1  没找到 -1</span><br><span class="line">console.log(morePeople.indexOf(person));  // 0   找到索引 0</span><br></pre></td></tr></table></figure></p><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript 5 为数组定义了5个迭代方法。</p><p>每个方法都接收两个参数：要在每一项上运行的<code>函数</code>和（可选的）<code>运行该函数的作用域对象</code>。<br>传入这些方法中的函数会接收三个参数：<code>值</code>、<code>索引</code>和<code>数组对象本身</code>。<br>根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。</p><p>通用使用方法</p><ul><li>array1.xxxx(callbackfn[, thisArg])</li></ul><p>array1<br>必需。一个数组对象。</p><p>callbackfn<br>必需。一个接受最多三个参数的函数。对于数组中的每个元素，filter 方法都会调用 callbackfn 函数一次。</p><p>thisArg<br>可选。可在 callbackfn 函数中为其引用 this 关键字的对象。如果省略 thisArg，则 undefined 将用作 this 值。</p><p>以下是这5个迭代方法的作用。</p><ul><li><code>every()</code> 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true。</li><li><code>filter()</code> 过滤器：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li><li><code>forEach()</code> 元素遍历：对数组中的每一项运行给定函数。这个方法没有返回值。</li><li><code>map()</code> 数组映射：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li><li><code>some()</code> 对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true。</li></ul><p>5个迭代方法的用法：</p><h4 id="every-确定数组的所有成员是否满足指定的测试。"><a href="#every-确定数组的所有成员是否满足指定的测试。" class="headerlink" title="every() 确定数组的所有成员是否满足指定的测试。"></a><code>every()</code> 确定数组的所有成员是否满足指定的测试。</h4><p>array1.every(callbackfn[, thisArg])</p><ul><li>判断数组元素是否全部都能整除2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 定义回调函数</span><br><span class="line">function CheckIfEven(value, index, ar) &#123; // CheckIfEven(值，索引，数组本身)</span><br><span class="line"></span><br><span class="line">    if (value % 2 == 0) &#123; // 取余，检查是否能整除2</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建数组 Create an array.</span><br><span class="line">var numbers = [2, 4, 5, 6, 8];</span><br><span class="line"></span><br><span class="line">// 检查回调函数是否返回所有的数组值</span><br><span class="line">if (numbers.every(CheckIfEven)) &#123;</span><br><span class="line">        console.log(&quot;All are even.&quot;); // true,满足指定的测试时运行</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;Some are not even.&quot;); // false,不满足指定的测试时运行</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 输出(Output):  Some are not even.</span><br></pre></td></tr></table></figure><h4 id="filter-返回数组中的满足回调函数中指定的条件的元素"><a href="#filter-返回数组中的满足回调函数中指定的条件的元素" class="headerlink" title="filter() 返回数组中的满足回调函数中指定的条件的元素"></a><code>filter()</code> 返回数组中的满足回调函数中指定的条件的元素</h4><p>array1.filter(callbackfn[, thisArg])</p><ul><li>以下代码为，使用过滤器判断数组中的质数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 定义回调函数</span><br><span class="line">function CheckIfPrime(value, index, ar) &#123;</span><br><span class="line">    // Math.floor向下取整</span><br><span class="line">    // Math.sqrt() 方法可返回一个数的平方根。</span><br><span class="line">    high = Math.floor(Math.sqrt(value)) + 1; // 平方根向下取整再加一</span><br><span class="line"></span><br><span class="line">    for (var div = 2; div &lt;= high; div++) &#123; // 判断是否能否被2以上的数整除</span><br><span class="line">        if (value % div == 0) &#123; // 如果能被整除，则不是质数</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建初始数组</span><br><span class="line">var numbers = [31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53];</span><br><span class="line"></span><br><span class="line">// 获取原始数组中的质数</span><br><span class="line">var primes = numbers.filter(CheckIfPrime);</span><br><span class="line"></span><br><span class="line">console.log(primes);  // [31,37,41,43,47,53]</span><br></pre></td></tr></table></figure><h4 id="forEach-为数组中的每个元素执行指定操作。"><a href="#forEach-为数组中的每个元素执行指定操作。" class="headerlink" title="forEach() 为数组中的每个元素执行指定操作。"></a><code>forEach()</code> 为数组中的每个元素执行指定操作。</h4><p>array1.forEach(callbackfn[, thisArg])</p><p>若不写回调函数，则默认操作为遍历所有元素。</p><ul><li>以下代码为，数组求和</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建数组</span><br><span class="line">var numbers = [10, 11, 12];</span><br><span class="line"></span><br><span class="line">// 调用每个数组元素，并回调函数</span><br><span class="line">var sum = 0;</span><br><span class="line">numbers.forEach(</span><br><span class="line">    function addNumber(value) &#123; sum += value; &#125; // 所有元素加起来</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(sum);  // 输出(Output): 33</span><br></pre></td></tr></table></figure><h4 id="map-对数组的每个元素调用定义的回调函数，并返回包含结果的数组。"><a href="#map-对数组的每个元素调用定义的回调函数，并返回包含结果的数组。" class="headerlink" title="map() 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。"></a><code>map()</code> 对数组的每个元素调用定义的回调函数，并返回包含结果的数组。</h4><p>array1.map(callbackfn[, thisArg])</p><ul><li>以下代码为，数组取余</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个包含取余属性的对象</span><br><span class="line">// 原型方法定义</span><br><span class="line">var obj = &#123;</span><br><span class="line">    divisor: 10, // 除以10</span><br><span class="line">    remainder: function (value) &#123;</span><br><span class="line">        return value % this.divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建数组</span><br><span class="line">var numbers = [6, 12, 25, 30];</span><br><span class="line"></span><br><span class="line">// 获取余数</span><br><span class="line">var result = numbers.map(obj.remainder, obj);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">// 输出(Output):  [6,2,5,0]</span><br></pre></td></tr></table></figure><h4 id="some-确定指定的回调函数是否为数组中的任何元素均返回-true。"><a href="#some-确定指定的回调函数是否为数组中的任何元素均返回-true。" class="headerlink" title="some() 确定指定的回调函数是否为数组中的任何元素均返回 true。"></a><code>some()</code> 确定指定的回调函数是否为数组中的任何元素均返回 true。</h4><p>array1.some(callbackfn[, thisArg])</p><ul><li>some()判断是否存在至少一个数符合条件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个函数，如果值为true，则返回true。</span><br><span class="line">var isOutsideRange = function (value) &#123;</span><br><span class="line">    // 检测是否超出范围</span><br><span class="line">    return value &lt; this.minimum || value &gt; this.maximum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建数组.</span><br><span class="line">var numbers = [6, 12, 16, 22, -12];</span><br><span class="line"></span><br><span class="line">// 范围对象是“这个”对象。</span><br><span class="line">var range = &#123; minimum: 10, maximum: 20 &#125;;</span><br><span class="line"></span><br><span class="line">console.log(numbers.some(isOutsideRange, range));  // true 存在小于10和大于20的数</span><br></pre></td></tr></table></figure><h2 id="挑战-数组去重"><a href="#挑战-数组去重" class="headerlink" title="挑战 数组去重"></a>挑战 数组去重</h2><p>// 挑战一，一维数组</p><ul><li>思路<br>使用indexOf(i)检测新数组newArr里有没有包含Arr里的i项<br>如果没有则向newArr里添加Aii[i]项<br>如果有则跳过；不做任何操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,4,2,3,5,6,4,3,2];</span><br><span class="line">var unique = function(arr)&#123;</span><br><span class="line">    var result = []; // 创建空数组，用于存放新数组</span><br><span class="line">    arr.forEach(function(item)&#123;</span><br><span class="line"></span><br><span class="line">        // indexOf()会使用全等操作符,判断item索引与遍历数组中所有元素都不相等，才运行</span><br><span class="line">        if(result.indexOf(item) &lt; 0)&#123;</span><br><span class="line"></span><br><span class="line">        // 此处代码，只有数组索引小于0（数组中不存在），才会运行</span><br><span class="line">        // 所以可以达到去重效果</span><br><span class="line">            result.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique(arr)); // [2,3,4,5,6]</span><br></pre></td></tr></table></figure><p>// 挑战二（二维数组）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,3,4,[2,3,4,5],3,5,[2,3,4,2],4,3,6,2];</span><br><span class="line">var unique = function(arr)&#123;</span><br><span class="line">    var result = []; // 创建空数组，用于存放新数组</span><br><span class="line">    arr.forEach(function(item) &#123; // 遍历数组元素给item</span><br><span class="line">        if (Array.isArray(item)) &#123; // 判定item是否为数组，只有数组才能往下运行</span><br><span class="line">            item.forEach(function(i) &#123; // 把item中的数组，遍历给i</span><br><span class="line">                // indexOf()会使用全等操作符,判断i索引与遍历数组中所有元素都不相等，才能往下运行</span><br><span class="line">                if (result.indexOf(i) &lt; 0) &#123;</span><br><span class="line">                    result.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (result.indexOf(item) &lt; 0) &#123;</span><br><span class="line">                result.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique(arr)); // [2,3,4,5,6]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;使用数组字面量创建数组（推荐）&quot;&gt;&lt;a href=&quot;#使用数组字面量创建数组（推荐）&quot; class=&quot;headerlink&quot; title=&quot;使用数组字面量创建数组（推荐）&quot;&gt;&lt;/a&gt;使用数组字面量创建数组（推荐）&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var empty = [];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;使用-new-关键字创建数组&quot;&gt;&lt;a href=&quot;#使用-new-关键字创建数组&quot; class=&quot;headerlink&quot; title=&quot;使用 new 关键字创建数组&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;new&lt;/code&gt; 关键字创建数组&lt;/h2&gt;&lt;p&gt;使用 new 关键字调用构造函数 Array() 是创建数组的另一种方法。&lt;br&gt;我们可以用三种方式调用构造函数。例如：&lt;br&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数组 js" scheme="http://blak-kong.github.io/tags/%E6%95%B0%E7%BB%84-js/"/>
    
  </entry>
  
  <entry>
    <title>js对象理解</title>
    <link href="http://blak-kong.github.io/2018/04/29/js%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3/"/>
    <id>http://blak-kong.github.io/2018/04/29/js对象理解/</id>
    <published>2018-04-29T06:52:23.000Z</published>
    <updated>2019-04-07T14:56:55.706Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。</p><p> JavaScript 的「三类对象」和「两类属性」进行区分：</p><p>内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。<br>宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。<br>自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。</p><p>自有属性（own property），是直接在对象中定义的属性。<br>继承属性（inherited property），是在对象的原型对象中定义的属性。<br><a id="more"></a></p><h2 id="使用对象字面量创建对象（推荐）"><a href="#使用对象字面量创建对象（推荐）" class="headerlink" title="使用对象字面量创建对象（推荐）"></a>使用对象字面量创建对象（推荐）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 推荐写法</span><br><span class="line">var person = &#123;</span><br><span class="line">    name : &quot;stone&quot;,</span><br><span class="line">    age : 28</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 也可以写成</span><br><span class="line">var person = &#123;&#125;;</span><br><span class="line">person.name = &quot;stone&quot;;</span><br><span class="line">person.age = 28;</span><br></pre></td></tr></table></figure><h2 id="使用-new-关键字创建对象"><a href="#使用-new-关键字创建对象" class="headerlink" title="使用 new 关键字创建对象"></a>使用 <code>new</code> 关键字创建对象</h2><p><code>new</code> 关键字<code>创建并初始化</code>一个新对象。关键字 new 后跟随一个<code>函数调用</code>。<br>这里的函数称做构造函数（constructor），<code>构造函数用以初始化一个新创建的对象</code>。<br>JavaScript 语言核心中的原始类型都包含内置构造函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = &quot;stone&quot;;</span><br><span class="line">person.age = 28;</span><br></pre></td></tr></table></figure></p><ul><li>只要在 <code>new</code> 后面跟随一个已创建的对象，就可以继承它的原型属性。 </li></ul><h2 id="使用-Object-create-函数创建对象"><a href="#使用-Object-create-函数创建对象" class="headerlink" title="使用 Object.create() 函数创建对象"></a>使用 <code>Object.create()</code> 函数创建对象</h2><p><code>Object.create()</code> 创建一个具有指定原型且可选择性地包含指定属性的对象。</p><blockquote><p>Object.create(prototype, descriptors)</p></blockquote><p>参数<br>prototype<br>必需。  要用作原型的对象。  可以为 null。<br>descriptors<br>可选。  包含一个或多个属性描述符的 JavaScript 对象。<br>“数据属性”是可获取且可设置值的属性。<br>数据属性描述符包含 value(值) 特性，以及 writable(可写)、enumerable（可枚举） 和 configurable（可配置） 特性。<br>如果未指定最后三个特性，则它们默认为 false。<br>只要检索或设置该值，“访问器属性”就会调用用户提供的函数。<br>访问器属性描述符包含 set 特性和/或 get 特性。</p><p>下面的示例创建使用 null 原型的对象并添加两个可枚举的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var newObj = Object.create(null, &#123;</span><br><span class="line">            size: &#123;</span><br><span class="line">                value: &quot;large&quot;,</span><br><span class="line">                enumerable: true</span><br><span class="line">            &#125;,</span><br><span class="line">            shape: &#123;</span><br><span class="line">                value: &quot;round&quot;,</span><br><span class="line">                enumerable: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">console.log(newObj.size + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">console.log(newObj.shape + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">console.log(Object.getPrototypeOf(newObj));</span><br><span class="line"></span><br><span class="line">// Object.getPrototypeOf 函数可获取原始对象的原型。</span><br><span class="line"></span><br><span class="line">// 输出(Output):</span><br><span class="line">// large</span><br><span class="line">// round</span><br><span class="line">// null</span><br></pre></td></tr></table></figure><h2 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h2><p>所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。<br>Object.prototype 是所有对象的原型对象，也是原型链终点，但是它默认是null的。<br>Object.prototype.<strong>proto</strong>为null （普通的对象）<br>Object.prototype 的存在价值就是象征Object类型本身,是根对象</p><p>通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。</p><p>因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。<br>同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。</p><p>没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。<br>其他原型对象都是普通对象，普通对象都具有原型。</p><p>所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。<br>例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。</p><p>这一系列链接的原型对象就是所谓的「原型链（prototype chain）」。</p><h4 id="注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性"><a href="#注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性" class="headerlink" title="注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（proto）属性"></a>注意：只有函数才有显式原型属性（prototype），对象只有隐式原型（<strong>proto</strong>）属性</h4><p>函数的prototype属性:在定义函数时自动添加的,默认值是一个空的Object对象<br>对象的<strong>proto</strong>属性:创建对象是自动创建、添加的,默认值为其对应构造函数的prototype属性值</p><h2 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置</span><br><span class="line">person.name = &quot;sophie&quot;; // 赋值</span><br><span class="line">//查询</span><br><span class="line">console.log(person.name);   // &quot;sophie&quot;</span><br></pre></td></tr></table></figure><h2 id="属性的访问错误"><a href="#属性的访问错误" class="headerlink" title="属性的访问错误"></a>属性的访问错误</h2><p>查询一个不存在的属性并不会报错，如果不存在，则返回undefined</p><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p>JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。。可以通过 in 运算符、hasOwnPreperty() 和 propertyIsEnumerable() 来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p><p>in 运算符的左侧是属性名（字符串），右侧是对象。<br>如果对象的自有属性或继承属性中包含这个属性则返回 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; x: 1 &#125;</span><br><span class="line">console.log(&quot;x&quot; in o);          // true，x是o的属性</span><br><span class="line">console.log(&quot;y&quot; in o);          // false，y不是o的属性</span><br><span class="line">console.log(&quot;toString&quot; in o);   // true，toString是继承属性</span><br></pre></td></tr></table></figure><p>除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined</p><p> <code>hasOwnProperty()</code> 方法用来检测给定的名字是否是对象的<code>自有属性</code>。<br>对于继承属性它将返回 false。</p><p><code>propertyIsEnumerable()</code> 检测对象有<code>自有属性</code>且<code>可枚举性</code>为 true 时它才返回 true。</p><h2 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h2><p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 for-in 循环遍历，ECMAScript 5 提供了两个更好用的替代方案。</p><p>for-in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。<br>对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;x:1, y:2, z:3&#125;;            // 三个可枚举的自有属性</span><br><span class="line">o.propertyIsEnumerable(&quot;toString&quot;); // false，内置方法不可枚举</span><br><span class="line">for (p in o) &#123;          // 遍历属性</span><br><span class="line">    console.log(p);     // 输出x、y和z，不会输出toString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有许多实用工具库给 Object.prototype 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。</p><p>为了过滤继承的属性，我们可以对 for-in 进行改造<br>只许加入两个判断<br>hasOwnProperty()<br>这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。<br>typeof 判断对象类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(p in o) &#123;</span><br><span class="line">   if (!o.hasOwnProperty(p)) continue;          // 跳过继承的属性</span><br><span class="line">   if (typeof o[p] === &quot;function&quot;) continue;    // 跳过函数方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了 for-in 循环之外，ECMAScript 5 定义了两个用以枚举属性名称的函数。</p><p>第一个是 Object.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。</p><p>第二个是 Object.getOwnPropertyNames()，它和 Ojbect.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。</p><h2 id="属性的-getter-和-setter"><a href="#属性的-getter-和-setter" class="headerlink" title="属性的 getter 和 setter"></a>属性的 getter 和 setter</h2><p>由 getter 和 setter 定义的属性称做「存取器属性（accessor property）」<br>它不同于「数据属性（data property）」，数据属性只有一个简单的值。<br>并且和数据属性不同，存取器属性不具有可写性（writable attribute）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    // 普通的数据属性</span><br><span class="line">    data_prop: value,</span><br><span class="line"></span><br><span class="line">    // 存取器属性都是成对定义的函数</span><br><span class="line">    get accessor_prop() &#123; /*这里是函数体 */ &#125;,</span><br><span class="line">    set accessor_prop(value) &#123; /* 这里是函数体*/ &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 或 set。<br>注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。</p><h2 id="序列化对象（JSON）"><a href="#序列化对象（JSON）" class="headerlink" title="序列化对象（JSON）"></a>序列化对象（JSON）</h2><p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。<br>JSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串<br>JSON.parse() 用于将一个 JSON 字符串转换为对象。</p><h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p><a href="https://github.com/stone0090/javascript-lessons/blob/master/1.7-ObjectObjects/Answer.md" target="_blank" rel="noopener">枚举题</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>创建对象的三种方式，在默认情况下，都一样。<br>但是在涉及原型的情况下 new 和 create() ，就产生了区别。至于字面量方法，则是无法继承原型。</p><p><code>new</code> 关键字<code>创建并初始化</code>一个新对象。<br>关键字 <code>new</code> 后跟随一个<code>函数调用</code>，新对象会继承它的原型属性。</p><p>工厂模式、构造函数模式、原型模式等……面向对象常用语法</p><p><code>Object.create()</code> 创建一个具有<code>指定原型</code>且<code>可选择性地包含指定属性</code>的对象。</p><p>new的高级应用？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h1&gt;&lt;p&gt;对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。&lt;/p&gt;
&lt;p&gt; JavaScript 的「三类对象」和「两类属性」进行区分：&lt;/p&gt;
&lt;p&gt;内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。&lt;br&gt;宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。&lt;br&gt;自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。&lt;/p&gt;
&lt;p&gt;自有属性（own property），是直接在对象中定义的属性。&lt;br&gt;继承属性（inherited property），是在对象的原型对象中定义的属性。&lt;br&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="对象 js" scheme="http://blak-kong.github.io/tags/%E5%AF%B9%E8%B1%A1-js/"/>
    
  </entry>
  
  <entry>
    <title>函数内部的特殊对象</title>
    <link href="http://blak-kong.github.io/2018/04/29/%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blak-kong.github.io/2018/04/29/函数内部的特殊对象/</id>
    <published>2018-04-28T16:28:25.000Z</published>
    <updated>2019-04-07T14:56:55.749Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解js对象排序-sort()</title>
    <link href="http://blak-kong.github.io/2018/04/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjs%E5%AF%B9%E8%B1%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://blak-kong.github.io/2018/04/28/深入浅出js对象排序/</id>
    <published>2018-04-28T09:35:26.000Z</published>
    <updated>2019-06-16T08:33:39.303Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。</p><p>我们可以使用<code>sort()</code>方法</p><a id="more"></a><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p><code>sort()</code> 方法用于<code>对数组的元素进行排序,并返回数组</code>。<br>默认排序顺序是根据字符串Unicode码点。</p><!-- more --><p>语法：<code>arrayObject.sort(参数)</code><br>参数可选，用于规定排序顺序。必须是函数。</p><p>注：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序。<br>准确的说：是按照字符编码的顺序进行排序。</p><p>但要实现默认按字母顺序排序，必须先把数组的元素都转换成字符串。</p><p>例1：我们将创建一个数组，并按字母顺序进行排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(4)</span><br><span class="line">arr[0] = &quot;G&quot;</span><br><span class="line">arr[1] = &quot;J&quot;</span><br><span class="line">arr[2] = &quot;T&quot;</span><br><span class="line">arr[3] = &quot;A&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr.sort())  //A G J T</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>例2：我们将创建一个数组，并按字母顺序进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(6)</span><br><span class="line">arr[0] = &quot;10&quot;</span><br><span class="line">arr[1] = &quot;5&quot;</span><br><span class="line">arr[2] = &quot;40&quot;</span><br><span class="line">arr[3] = &quot;25&quot;</span><br><span class="line">arr[4] = &quot;1000&quot;</span><br><span class="line">arr[5] = &quot;1&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr.sort())  // 1 10 1000 25 40 5</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>至此，我们了解了<code>sort()</code>在没有函数传参的情况下：</p><h4 id="默认按照首字母A-Z、a-z排序，以及0-9排序。"><a href="#默认按照首字母A-Z、a-z排序，以及0-9排序。" class="headerlink" title="默认按照首字母A~Z、a~z排序，以及0~9排序。"></a>默认按照首字母A~Z、a~z排序，以及0~9排序。</h4><ul><li>原理：真正的默认排序顺序是根据字符串Unicode码点。字符串根据ASCII码进行排序。</li></ul><hr><p>我们注意到，上面的代码没有按照数值的大小对数字进行排序<br>要实现这一点，就必须使用一个排序函数。</p><h4 id="①-函数传参（a-b）-升序、降序排序"><a href="#①-函数传参（a-b）-升序、降序排序" class="headerlink" title="① 函数传参（a-b）-升序、降序排序"></a>① 函数传参（a-b）-升序、降序排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">function sortNumber(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    return a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = new Array(6)</span><br><span class="line">arr[0] = &quot;10&quot;</span><br><span class="line">arr[1] = &quot;5&quot;</span><br><span class="line">arr[2] = &quot;40&quot;</span><br><span class="line">arr[3] = &quot;25&quot;</span><br><span class="line">arr[4] = &quot;1000&quot;</span><br><span class="line">arr[5] = &quot;1&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr.sort(sortNumber)) // 1 5 10 25 40 10000</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上代码可知，升序排列方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sortNumber(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    return a - b //同理，如果是降序，则为b - a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>但如果想根据数组对象中的某个属性值进行排序呢？</p><h4 id="②-进阶：函数嵌套传参（自定义函数（属性名））"><a href="#②-进阶：函数嵌套传参（自定义函数（属性名））" class="headerlink" title="② 进阶：函数嵌套传参（自定义函数（属性名））"></a>② 进阶：函数嵌套传参（自定义函数（属性名））</h4><p>sort方法接收一个函数作为参数。<br>我们可以在参数中嵌套一层函数用来接收对象属性名，其他部分代码与正常使用sort方法相同。<br>意思是：根据xx属性的值进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">    &#123;name:&apos;zopp&apos;,age:0&#125;,</span><br><span class="line">    &#123;name:&apos;gpp&apos;,age:18&#125;,</span><br><span class="line">    &#123;name:&apos;yjj&apos;,age:8&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function compare(用于判断的属性名)&#123;</span><br><span class="line">    return function(a,b)&#123;</span><br><span class="line">        var value1 = a[用于判断的属性名];</span><br><span class="line">        var value2 = b[用于判断的属性名];</span><br><span class="line">        return value1 - value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr.sort(compare(&apos;age&apos;)))  //返回对象，age从小到大正向排序</span><br></pre></td></tr></table></figure><hr><h4 id="③-字母排序兼容"><a href="#③-字母排序兼容" class="headerlink" title="③ 字母排序兼容"></a>③ 字母排序兼容</h4><p>我们已经学会了字面量值的升序降序，以及根据属性名对对象数组进行的升序降序</p><p>但要是字母大小写不同，该如何来确定是升序排列，还是降序排序呢？</p><p>默认情况下，对字符串排序，是按照ASCII的大小比较的。<br>现在，我们提出排序应该忽略大小写，按照字母序排序。<br>要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：</p><p>toUpperCase() 方法：把字符串转换为大写。<br>以下算法基于js底层的JS引擎实现，严格意义上并非某种算法。</p><p>而是对于sort()函数的高阶应用！</p><p>(s1、s2)为升序，(s2、s1)为降序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;Google&apos;, &apos;apple&apos;, &apos;Microsoft&apos;];</span><br><span class="line"></span><br><span class="line">function english(s1, s2) &#123;</span><br><span class="line">    x1 = s1.toUpperCase();</span><br><span class="line">    x2 = s2.toUpperCase();</span><br><span class="line">    if (x1 &lt; x2) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x1 &gt; x2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.sort(english); // [&apos;apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;]</span><br></pre></td></tr></table></figure><p>原理解析：</p><blockquote><p>sort()会默认按照字符编码的顺序进行排序。</p></blockquote><p>字符编码的大小判断，会决定sort()方法的返回结果。</p><ul><li>然而，尽管如此，我们还是可以利用js本身的语法，去灵活使用sort()方法。</li></ul><hr><h2 id="sort-原理与通用方法"><a href="#sort-原理与通用方法" class="headerlink" title="sort()原理与通用方法"></a>sort()原理与通用方法</h2><p>参考字母排序方法</p><p>让我们来看看sort()是如何通过0，1，-1<br>来对不同的对象数组进行排序的。</p><p>关于前面的字母排序方法，我使用的廖雪峰大神的博客教学代码，接下来为了方便理解，我还会使用他的代码。</p><h3 id="sort-通用方法"><a href="#sort-通用方法" class="headerlink" title="sort()通用方法"></a>sort()通用方法</h3><h4 id="①通用简单升序"><a href="#①通用简单升序" class="headerlink" title="①通用简单升序"></a>①通用简单升序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line"></span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr); // [1, 2, 10, 20]</span><br></pre></td></tr></table></figure><h4 id="②-通用简单降序"><a href="#②-通用简单降序" class="headerlink" title="② 通用简单降序"></a>② 通用简单降序</h4><p>改变上一段代码的return返回值的1和-1的位置（位置对调）。</p><blockquote><p>闲话：记得廖雪峰大神的教学代码，看过三次，当时都以为看懂了一部分。其实完全没看懂，只是知道怎么用。</p></blockquote><p>接下来说说原理。</p><h3 id="sort-通用排序原理"><a href="#sort-通用排序原理" class="headerlink" title="sort()通用排序原理"></a>sort()通用排序原理</h3><p>原理很简单，但是初学者一般不会想得到：<br>那就是————JS引擎的判断机制！</p><p>想起很久以前看过的一张动漫对比图：</p><blockquote><p>天然呆看到看到苹果会想到“苹果很甜、好吃”，或者我们普通人就再加一个iphone。<br>而学霸看到苹果则是会想到牛顿的万有引力、以及各种相关知识……联想能力强到爆炸，学力满满</p></blockquote><p>咳，姑且不提这个悲伤的故事</p><p>我们来说说JS引擎的判断机制。<br>这是底层实现、但也不是什么非常厉害的东西。</p><ul><li>仅仅就是if判断语句！</li></ul><p>是不是很惊讶？然而，虽然仅仅是if判断语句，但灵活的把不同的东西一起用，还是要对js有一定了解才行，否则除非非常专注去想要钻研问题，或者运气好。</p><p>不然一般还是无法理解。</p><ul><li>讲解部分</li></ul><p>这里廖雪峰大神的代码，通过对字符比较的大小判断，以及return返回……<br>判断了到底执行哪一条代码。</p><p>本质上，排序原理还是<code>sort()</code>方法进行排序（参考最前面的代码）<br>只是加入if判断。</p><p>实际上，-1和0的返回值，都是可以忽略的。<br>因为那代表false</p><blockquote><p>致命魔术：靠近一点，因为你自以为看到的越多，就越容易被欺骗！</p></blockquote><p>所以知识面广很重要！</p><p>在刚开始学习一门新技术时，最好对其有相对全面的认识再深入了解！</p><p>（这正是我一开始学了很久，技术也很菜的原因！）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;p&gt;假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;sort()&lt;/code&gt;方法&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="排序 js" scheme="http://blak-kong.github.io/tags/%E6%8E%92%E5%BA%8F-js/"/>
    
  </entry>
  
  <entry>
    <title>javascript循环语句</title>
    <link href="http://blak-kong.github.io/2018/04/28/javascript%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <id>http://blak-kong.github.io/2018/04/28/javascript循环语句/</id>
    <published>2018-04-27T16:07:03.000Z</published>
    <updated>2019-04-07T14:56:53.540Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[TOC]</p><p>学习和记录循环语句需要注意的重要细节，深入理解js的循环语句</p><h2 id="for（条件循环）"><a href="#for（条件循环）" class="headerlink" title="for（条件循环）"></a>for（条件循环）</h2><p>一般for循环的语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(语句1;语句2;语句3)&#123;</span><br><span class="line">    被执行的代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>语句 1 在循环（代码块）开始前执行<br>语句 2 定义运行循环（代码块）的条件<br>语句 3 在循环（代码块）已被执行之后执行</p> <a id="more"></a><p>干巴巴的说明有点无聊，不方便记忆，我们来做一道经典题型</p><p>以面试题级别的题型为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 挑战一</span><br><span class="line">var k;</span><br><span class="line">for(i=0, j=0; i&lt;10, j&lt;6; i++, j++)&#123;</span><br><span class="line">    k = i + j;</span><br><span class="line">&#125;</span><br><span class="line">console.log(k);  // ？？？</span><br></pre></td></tr></table></figure><p>偶不！它一次定义了很多条语句！这不是for循环！<br>等等……仔细一看，它只有三个分号。冷静，这是我们刚才学习的for循环！</p><p>毕竟也没有谁规定一个语句之中，只能写一个判断，这样做是可以的。<br>那么，答案会是多少呢？</p><p>一开始，i和j都等于零。<br>条件判断后，i和j都自加一。</p><p>但条件判断是以谁为基准？分别循环？不可能！</p><p>所幸，我们不是真的在面试，直接用浏览器运行便能一窥究竟。<br>答案是10</p><p>而如果把i&lt;10 和 j&lt;6 的位置对调<br>则会输出18</p><blockquote><p>由此可见，for循环的条件判断<code>停止条件</code>，由最接近第二个分号的条件为准。</p></blockquote><ul><li>顺便一提，当循环遍历一个数组，并且数组的长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率</li></ul><p>例：</p><blockquote><p>const arr = [1, 2, 3];<br>for(let i = 0, len = arr.length; i &lt; len; i++)</p></blockquote><hr><h2 id="for-in-遍历所有可枚举的属性"><a href="#for-in-遍历所有可枚举的属性" class="headerlink" title="for-in (遍历所有可枚举的属性)"></a>for-in (遍历所有可枚举的属性)</h2><p>for-in语句用于对数组或者对象的<code>属性</code>进行循环操作。</p><p>for-in 循环中的代码每执行一次，就会对<code>数组的元素</code>或者<code>对象的属性</code>进行一次操作。</p><p>Tip:</p><blockquote><p>for-in循环应该用在<code>非数组对象</code>的遍历上，使用for-in进行循环也被称为“枚举”。因为它真正遍历的是对象<code>“可枚举的属性”</code></p></blockquote><p>注意：</p><blockquote><p>for-in 遍历属性的顺序并不确定。<br>即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</p></blockquote><h3 id="Array-的真相"><a href="#Array-的真相" class="headerlink" title="Array 的真相"></a>Array 的真相</h3><p>Array 在 Javascript 中是一个对象， Array 的索引是属性名。</p><p>事实上， Javascript 中的 “array” 有些误导性， Javascript 中的 Array 并不像大部分其他语言的数组。首先， Javascript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。</p><p>实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 Javascript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。</p><p>有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？</p><p>那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p><p>现在我们来看看用 for-in 来循环数组的特殊例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">arr.name = &quot;Hello world&quot;;</span><br><span class="line">let index;</span><br><span class="line">for(index in arr) &#123;</span><br><span class="line">    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);</span><br><span class="line">&#125;</span><br><span class="line">//运行结果</span><br><span class="line">//arr[0] = 1</span><br><span class="line">//arr[1] = 2</span><br><span class="line">//arr[2] = 3</span><br><span class="line">//arr[name] = Hello world</span><br></pre></td></tr></table></figure><p>我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。</p><p>同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。</p><p>那是不是说，只要我们不在 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。</p><ul><li>因为 for-in 不仅仅遍历 array 自身的属性，它还遍历 array 原型链上的所有可枚举的属性。</li></ul><p>下面我们看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.fatherName = &quot;Father&quot;;</span><br><span class="line">const arr = [1, 2, 3];</span><br><span class="line">arr.name = &quot;Hello world&quot;;</span><br><span class="line">let index;</span><br><span class="line">for(index in arr) &#123;</span><br><span class="line">    console.log(&quot;arr[&quot; + index + &quot;] = &quot; + arr[index]);</span><br><span class="line">&#125;</span><br><span class="line">//arr[0] = 1</span><br><span class="line">//arr[1] = 2</span><br><span class="line">//arr[2] = 3</span><br><span class="line">//arr[name] = Hello world</span><br><span class="line">//arr[fatherName] = Father</span><br></pre></td></tr></table></figure><p>写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。</p><ul><li>但是有一种情况例外，那就是稀疏数组。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let key;</span><br><span class="line">const arr = [];</span><br><span class="line">arr[0] = &quot;a&quot;;</span><br><span class="line">arr[100] = &quot;b&quot;;</span><br><span class="line">arr[10000] = &quot;c&quot;;</span><br><span class="line">for(key in arr) &#123;</span><br><span class="line">    if(arr.hasOwnProperty(key) &amp;&amp; </span><br><span class="line">    /^0$|^[1-9]\d*$/.test(key) &amp;&amp; </span><br><span class="line">    key &lt;= 4294967294 </span><br><span class="line">    ) &#123;</span><br><span class="line">     console.log(arr[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for-in 只会遍历存在的实体.</li></ul><p>上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，而普通 for 循环则会遍历 10001 次）。<br>所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。</p><p>for-in 性能<br>正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。<br>因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。</p><p>如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line"> &quot;prop1&quot;: &quot;value1&quot;,</span><br><span class="line"> &quot;prop2&quot;: &quot;value2&quot;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">const props = [&quot;prop1&quot;, &quot;prop2&quot;];</span><br><span class="line">for(let i = 0; i &lt; props.length; i++) &#123;</span><br><span class="line"> console.log(obj[props[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，将对象的属性都存入一个数组中，相对于 for-in 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。</p><h4 id="for-in总结："><a href="#for-in总结：" class="headerlink" title="for-in总结："></a>for-in总结：</h4><p>最后来一个面试题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var nums = [12,32,54,56,78,89];</span><br><span class="line">for(var n in nums)&#123;</span><br><span class="line">    console.log(n);  // 0,1,2,3,4,5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为for-in的真正作用已经解释了很多，所以我们只需要梳理一下知识点，即可轻松解答</p><p>总结：<br>①：Array实际上不存在索引（但存在类似的属性）<br>②：for-in只能遍历可枚举属性（几乎所有属性）<br>③：for-in并不直接获取数组元素（获取元素方法：数组[索引属性]）<br>④：for-in输出顺序不确定（不会自动排列）</p><p>由此可得：<br>①：console.log(n)不可能输出元素<br>②：n是索引属性</p><ul><li>所以，Array不存在索引，但for-in遍历索引属性（普通的for循环是遍历数组长度）。</li></ul><p>补充：（过滤不想要的属性）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i in a) &#123;</span><br><span class="line">    // 跳过继承的属性</span><br><span class="line">    if (!a.hasOwnProperty(i)) continue; // continue结束本次循环</span><br><span class="line"></span><br><span class="line">    // 跳过不是非负整数的 i</span><br><span class="line">    if (String(Math.floor(Math.abs(Number(i)))) !== i) continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="forEach-遍历所有元素并回调"><a href="#forEach-遍历所有元素并回调" class="headerlink" title="forEach (遍历所有元素并回调)"></a>forEach (遍历所有元素并回调)</h2><p>在 ES5 中，引入了新的循环，即 forEach 循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">arr.forEach((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//3</span><br></pre></td></tr></table></figure><p>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数。<br>那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 </p><p>callback 函数会被依次传入三个参数：</p><p>forEach(值,索引,数组对象本身)，默认只遍历值</p><ul><li>数组当前项的值；</li><li>数组当前项的索引；</li><li>数组对象本身；</li></ul><p>需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。<br>调用forEach 后添加到数组中的项不会被 callback 访问到。</p><p>如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。<br>已删除的项不会被遍历到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [];</span><br><span class="line">arr[0] = &quot;a&quot;;</span><br><span class="line">arr[3] = &quot;b&quot;;</span><br><span class="line">arr[10] = &quot;c&quot;;</span><br><span class="line">arr.name = &quot;Hello world&quot;;</span><br><span class="line">arr.forEach((data, index, array) =&gt; &#123;</span><br><span class="line">    console.log(data, index, array);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 0 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br><span class="line">b 3 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br><span class="line">c 10 [&quot;a&quot;, 3: &quot;b&quot;, 10: &quot;c&quot;, name: &quot;Hello world&quot;]</span><br></pre></td></tr></table></figure><p>这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。</p><p>所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。</p><p>另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：</p><ul><li>every: 循环在第一次 return false 后返回</li><li>some: 循环在第一次 return true 后返回</li><li>filter: 返回一个新的数组，该数组内的元素满足回调函数</li><li>map: 将原数组中的元素处理后再返回</li><li>reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。</li></ul><p>forEach 性能：一般<br>forEach 的速度不如 for ，因为forEach会遍历所有元素，并一一进行回调。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;学习和记录循环语句需要注意的重要细节，深入理解js的循环语句&lt;/p&gt;
&lt;h2 id=&quot;for（条件循环）&quot;&gt;&lt;a href=&quot;#for（条件循环）&quot; class=&quot;headerlink&quot; title=&quot;for（条件循环）&quot;&gt;&lt;/a&gt;for（条件循环）&lt;/h2&gt;&lt;p&gt;一般for循环的语法为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for(语句1;语句2;语句3)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    被执行的代码块；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;语句 1 在循环（代码块）开始前执行&lt;br&gt;语句 2 定义运行循环（代码块）的条件&lt;br&gt;语句 3 在循环（代码块）已被执行之后执行&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="循环语句 js" scheme="http://blak-kong.github.io/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5-js/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法学习</title>
    <link href="http://blak-kong.github.io/2018/04/13/ES6%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blak-kong.github.io/2018/04/13/ES6语法学习/</id>
    <published>2018-04-13T07:39:19.000Z</published>
    <updated>2019-06-16T08:31:22.961Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>在代码中，如果使用了ES6语法，那么强制开启严格模式</p><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><ul><li>let:使用let定义的变量，拥有块级作用域.</li></ul><p>注意：使用let定义变量，在同一块级作用域内，不能重复定义同一个名字。</p><a id="more"></a><ul><li>const:使用const定义的是常量，不可更改，且也拥有块级作用域。</li></ul><p>注意：const只能在定义赋值，因为它定义的是常量，不可更改。除非在定义时赋值的常量，是一个Object。因为Object是引用类型，赋值Object等于给const赋值了一个指针，指针不会变，Object改变不影响指向它的指针。</p><h3 id="涉及的JS基础知识"><a href="#涉及的JS基础知识" class="headerlink" title="涉及的JS基础知识"></a>涉及的JS基础知识</h3><p>基本类型（私人空间）：每定义一个变量，就会在栈内存中开辟一个存放这个变量的空间。</p><p>引用类型（公共空间）：如果有两个不同的变量指向同一个对象，则这个对象是唯一存在堆内存的。当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>示例：<br>数组解构赋值</p><pre><code>{    let a,b;    [a,b]=[1,2];    console.log(a,b); // 1 2}</code></pre><p>赋值展开平铺语法：…变量</p><pre><code>{    let a,b,rest;    [a,b,...rest]=[1,2,3,4,5,6];    console.log(a,b,rest); // 1 2 [3,4,5,6]}</code></pre><p>对象解构赋值：</p><pre><code>{    let a,b;    ({a,b}={a:1,b:2})    console.log(a,b); // 1 2}</code></pre><p>如果解构赋值没有在结构上成功配对，则赋值对象为未定义,否则设定默认值</p><pre><code>{    let a,b,c,rest;    [a,b,c=3]=[1,2]    console.log(a,b,c) //1 2 3}</code></pre><p>解构赋值的常用使用场景：<br>1.数值交换</p><pre><code>{    let a=1;    let b=2;    [a,b]=[b,a];    console.log(a,b); // 2 1}</code></pre><p>2.函数返回</p><pre><code>{    function f(){        return [1,2]    }    let a,b;    [a,b]=f();    console.log(a,b); // 1 2}</code></pre><p>3.函数选择返回</p><pre><code>{    function f(){        return [1,2,3,4,5,]    }    let a,b,c;    [a,,,b]=f();    console.log(a,b); // 1 4}</code></pre><p>4.函数平铺返回</p><pre><code>{    function f(){        return [1,2,3,4,5,]    }    let a,b,c;    [a,...b]=f();    console.log(a,b); // 1 [2,3,4,5]}</code></pre><p>5.对象解构赋值</p><pre><code>{    let o={p:42,q:true};    let {p,q}=o;    console.log(p,q); // 42 true}</code></pre><p>6,对象设置默认值</p><pre><code>{    let {a=10,b=5}={a:3}    console.log(a,b); // 3 5}</code></pre><h3 id="解构赋值：模拟后台json数据"><a href="#解构赋值：模拟后台json数据" class="headerlink" title="解构赋值：模拟后台json数据"></a>解构赋值：模拟后台json数据</h3><pre><code>{    let metaData={        title:&apos;abc&apos;,        test:[{            title:&apos;test&apos;,            desc:&apos;description&apos;        }]    }    let {title:esTitle,test:[{title:cnTitle}]}=metaData;    console.log(esTitle,cnTitle);}</code></pre><h2 id="Module模块化"><a href="#Module模块化" class="headerlink" title="Module模块化"></a>Module模块化</h2><p>导出：<br>export xxx()<br>export default {<br>    xxx,<br>    zzz<br>    yyy<br>}</p><p>引入：<br>import xxx from ‘./路径’</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h1&gt;&lt;p&gt;在代码中，如果使用了ES6语法，那么强制开启严格模式&lt;/p&gt;
&lt;h2 id=&quot;let和const&quot;&gt;&lt;a href=&quot;#let和const&quot; class=&quot;headerlink&quot; title=&quot;let和const&quot;&gt;&lt;/a&gt;let和const&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;let:使用let定义的变量，拥有块级作用域.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：使用let定义变量，在同一块级作用域内，不能重复定义同一个名字。&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ES6" scheme="http://blak-kong.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
