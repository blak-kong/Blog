<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>非黑非白の博客</title>
  
  <subtitle>重学前端,记录笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blak-kong.github.io/"/>
  <updated>2020-05-13T17:48:42.614Z</updated>
  <id>http://blak-kong.github.io/</id>
  
  <author>
    <name>blak-kong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【nestjs】控制器和路由</title>
    <link href="http://blak-kong.github.io/2020/05/14/%E3%80%90nestjs%E3%80%91%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%B7%AF%E7%94%B1/"/>
    <id>http://blak-kong.github.io/2020/05/14/【nestjs】控制器和路由/</id>
    <published>2020-05-13T17:23:08.000Z</published>
    <updated>2020-05-13T17:48:42.614Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[TOC]</p><h2 id="一、NestJS-中的控制器"><a href="#一、NestJS-中的控制器" class="headerlink" title="一、NestJS 中的控制器"></a>一、NestJS 中的控制器</h2><p>Nest 中的控制器层负责处理传入的请求, 并返回对客户端的响应。</p><p>控制器的目的是接收应用的特定请求。</p><p>路由机制控制哪个控制器接收哪些请求。</p><p>通常， 每个控制器有多个路由，不同的路由可以执行不同的操作。</p><blockquote><p>ps：express、koa 需要引入 router 中间件。而 nestjs 自己做了封装，可以直接使用控制器做路由。</p></blockquote><p>可以通过 NestCLi 创建控制器：</p><blockquote><p>nest g controller [控制器名字]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 补充：查看nest g 提供的所有方法</span><br><span class="line">nest g -help</span><br></pre></td></tr></table></figure><h2 id="二、NestJS-中的路由"><a href="#二、NestJS-中的路由" class="headerlink" title="二、NestJS 中的路由"></a>二、NestJS 中的路由</h2><p>Nestjs 中没有单独配置路由的地方。</p><p>定义好控制器后 nestjs 会自动给我们配置对应的路由。</p><p>下面代码定义了一个新闻控制器。装饰器为@Controller(‘article’)</p><p>装饰器参数里面的’article’ 就是我们的路由。</p><p>如果我们要返回 index 方法里面的内容我们在浏览器输入 <a href="http://localhost:3000/article" target="_blank" rel="noopener">http://localhost:3000/article</a></p><p>如果我们要返回 add 方法里面的内容我们在浏览器输入 <a href="http://localhost:3000/article/add" target="_blank" rel="noopener">http://localhost:3000/article/add</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Controller, Get &#125; from &apos;@nestjs/common&apos;;</span><br><span class="line"></span><br><span class="line">@Controller(&apos;article&apos;)</span><br><span class="line">export class ArticleController &#123;</span><br><span class="line">    @Get()</span><br><span class="line">    index(): string &#123;</span><br><span class="line">        return ‘这是 article 里面的 index’;</span><br><span class="line">    &#125;</span><br><span class="line">    @Get(‘add’)</span><br><span class="line">    add(): string &#123;</span><br><span class="line">        return ‘这是 article 里面的 index’;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 nest 的 return：</p><p>当请求处理程序返回 JavaScript 对象或数组时，它将自动序列化为 JSON。但是，当它返回一个字符串时，Nest 将只发送一个字符串而不是序列化它。</p><p>这使响应处理变得简单：只需要返回值，Nest 负责其余部分。</p><h2 id="三、NestJS-中的-Get-Post-以及通过方法参数装饰器获取传值"><a href="#三、NestJS-中的-Get-Post-以及通过方法参数装饰器获取传值" class="headerlink" title="三、NestJS 中的 Get Post 以及通过方法参数装饰器获取传值"></a>三、NestJS 中的 Get Post 以及通过方法参数装饰器获取传值</h2><h3 id="1、首先看一个-Get-Post-请求的例子"><a href="#1、首先看一个-Get-Post-请求的例子" class="headerlink" title="1、首先看一个 Get Post 请求的例子"></a>1、首先看一个 Get Post 请求的例子</h3><p>注意我们使用 nestjs 内置装饰器的时候必须得在 <code>@nestjs/common</code> 模块下面引入对应的装饰器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 引入装饰器</span><br><span class="line">import &#123; Controller, Get, Post &#125; from &apos;@nestjs/common&apos;;</span><br><span class="line"></span><br><span class="line">@Controller(&apos;cats&apos;)</span><br><span class="line">export class CatsController &#123;</span><br><span class="line">    @Post()</span><br><span class="line">    create(): string &#123;</span><br><span class="line">        return &apos;This action adds a new cat&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Get()</span><br><span class="line">    findAll(): string &#123;</span><br><span class="line">        return &apos;This action returns all cats&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nestjs 也提供了其他 <strong>HTTP 请求方法的装饰器</strong> <code>@Put()</code> 、<code>@Delete()</code>、<code>@Patch()</code>、 <code>@Options()</code>、 <code>@Head()</code>和 <code>@All()</code></p><h2 id="2、Nestjs-中获取请求参数"><a href="#2、Nestjs-中获取请求参数" class="headerlink" title="2、Nestjs 中获取请求参数"></a>2、Nestjs 中获取请求参数</h2><p>在 Nestjs 中获取 Get 传值或者 Post 提交的数据的话我们可以使用 Nestjs 中的装饰器来获取。</p><table><thead><tr><th>装饰器</th><th>使用方法</th></tr></thead><tbody><tr><td>@Request()</td><td>req</td></tr><tr><td>@Next()</td><td>next</td></tr><tr><td>@Session()</td><td>req.session</td></tr><tr><td>@Param(key?: string)</td><td>req.params / req.params[key]</td></tr><tr><td>@Body(key?: string)</td><td>req.body / req.body[key]</td></tr><tr><td>@Query(key?: string)</td><td>req.query / req.query[key]</td></tr><tr><td>@Headers(name?: string)</td><td>req.headers / req.headers[name]</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; Controller, Get, Post &#125; from &apos;@nestjs/common&apos;;</span><br><span class="line"></span><br><span class="line">@Controller(&apos;news&apos;)</span><br><span class="line">export class NewsController &#123;</span><br><span class="line">    @Get()</span><br><span class="line">    getAbout(@Query() query):string &#123;</span><br><span class="line">        console.log(query); //这里获取的就是所有的 Get 传值</span><br><span class="line">        return &apos;这是 getAbout&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    @Get(&apos;list&apos;)</span><br><span class="line">    getNews(@Query(‘id’) query):string &#123;</span><br><span class="line">        console.log(query); //这里获取的就是 Get 传值里面的 Id 的值</span><br><span class="line">        return &apos;这是 getNews&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    @Post(&apos;doAdd&apos;)</span><br><span class="line">    async addNews(@Body() newsData)&#123;</span><br><span class="line">        console.log(newsData);</span><br><span class="line">        return &apos;增加新闻&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、NestJS 中的动态路由</p><p>当您需要接受动态数据作为请求的一部分时，具有静态路径的路由将不起作用（例如，GET /cats/1)获取具有 id 的 cat 1）。</p><p>为了定义带参数的路由，我们可以在路由中添加路由参数标记，以捕获请求 URL 中该位置的动态值。</p><p>@Get() 下面的装饰器示例中的路由参数标记演示了此用法。</p><p>可以使用 @Param() 装饰器访问以这种方式声明的路由参数，该装饰器应添加到函数签名中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Get(&apos;:id&apos;)</span><br><span class="line">findOne(@Param() params): string &#123;</span><br><span class="line">    console.log(params.id);</span><br><span class="line">    return `This action returns a #$&#123;params.id&#125; cat`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;一、NestJS-中的控制器&quot;&gt;&lt;a href=&quot;#一、NestJS-中的控制器&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
    
      <category term="nestjs" scheme="http://blak-kong.github.io/tags/nestjs/"/>
    
      <category term="教程笔记" scheme="http://blak-kong.github.io/tags/%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【nestjs】创建nestjs项目</title>
    <link href="http://blak-kong.github.io/2020/05/14/%E3%80%90nestjs%E3%80%91%E5%88%9B%E5%BB%BAnestjs%E9%A1%B9%E7%9B%AE/"/>
    <id>http://blak-kong.github.io/2020/05/14/【nestjs】创建nestjs项目/</id>
    <published>2020-05-13T17:22:27.000Z</published>
    <updated>2020-05-13T17:28:32.398Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Nest 是一个渐进的 Node.js 框架，可以在 TypeScript 和 JavaScript (ES6、ES7、ES8)之上构 建高效、可伸缩的企业级服务器端应用程序。</p><p>Nest 基于 TypeScript 编写并且结合了 OOP（面向对象编程），FP（函数式编程）和 FRP （函数式响应编程）的相关理念。在设计上的很多灵感来自于 Angular，Angular 的很多模 式又来自于 Java 中的 Spring 框架，依赖注入、面向切面编程等，所以我们也可以认为： Nest 是 Node.js 版的 Spring 框架。</p><p>Nest 框架底层 HTTP 平台默认是基于 Express 实现的，所以无需担心第三方库的缺失。</p><p>Nest 旨在成为一个与平台无关的框架。 通过平台，可以创建可重用的逻辑部件，开发人员可以利用这些部件来跨越多种不同类型的应用程序。</p><p>从技术上讲，Nest 可以在创建适配器 后使用任何 Node HTTP 框架。 有两个支持开箱即用的 HTTP 平台：express 和 fastify。 您 可以选择最适合您需求的产品。 NestJs 的核心思想：就是提供了一个层与层直接的耦合度极小,抽象化极高的一个架构 体系。</p><p>Nestjs 目前在行业内具有很高的关注度，所以我们有必要学习一下</p><p>官网：<a href="https://nestjs.com/" target="_blank" rel="noopener">https://nestjs.com/</a></p><p>中文网站：<a href="https://docs.nestjs.cn/" target="_blank" rel="noopener">https://docs.nestjs.cn/</a></p><p>GitHub: <a href="https://github.com/nestjs/nest" target="_blank" rel="noopener">https://github.com/nestjs/nest</a></p><h1 id="nest-主要是学习，国内实际使用，还是优先选-eggjs（文档第一）"><a href="#nest-主要是学习，国内实际使用，还是优先选-eggjs（文档第一）" class="headerlink" title="nest 主要是学习，国内实际使用，还是优先选 eggjs（文档第一）"></a>nest 主要是学习，国内实际使用，还是优先选 eggjs（文档第一）</h1><p>[TOC]</p><h2 id="安装-nestjs"><a href="#安装-nestjs" class="headerlink" title="安装 nestjs"></a>安装 nestjs</h2><p>以下三种 nest 脚手架的全局安装方式，任选其一</p><blockquote><p>npm i -g @nestjs/cli</p></blockquote><blockquote><p>yarn global add @nestjs/cli</p></blockquote><blockquote><p>cnpm i -g @nestjs/cli</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><blockquote><p>nest new nestdemo</p></blockquote><p>接下来按提示，进入目录，运行即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;Nest 是一个渐进的 Node.js 框架，可以在 TypeScript 和 JavaScript (ES6、ES7、ES8)之上构 建高效、可伸缩的企业级服务器端应用程序
      
    
    </summary>
    
    
      <category term="nestjs" scheme="http://blak-kong.github.io/tags/nestjs/"/>
    
      <category term="教程笔记" scheme="http://blak-kong.github.io/tags/%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【docker】部署第一个应用doclever</title>
    <link href="http://blak-kong.github.io/2020/05/07/%E3%80%90docker%E3%80%91%E9%83%A8%E7%BD%B2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8doclever/"/>
    <id>http://blak-kong.github.io/2020/05/07/【docker】部署第一个应用doclever/</id>
    <published>2020-05-06T16:43:22.000Z</published>
    <updated>2020-05-06T16:48:26.813Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://github.com/sx1989827/DOClever/tree/master/docker" target="_blank" rel="noopener">doclever 开源接口管理平台的 github 地址</a></p><p>为了方便部署和使用，我们使用 docker-compose</p><p>用法：</p><p>① 在文件夹下创建<code>docker-compose.yml</code>，填入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;2&quot;</span><br><span class="line">services:</span><br><span class="line">  DOClever:</span><br><span class="line">    image: lw96/doclever</span><br><span class="line">    restart: always</span><br><span class="line">    container_name: &quot;DOClever&quot;</span><br><span class="line">    ports:</span><br><span class="line">    - 20080:10000</span><br><span class="line">    volumes:</span><br><span class="line">    - /svr/doclever/file:/root/DOClever/data/file</span><br><span class="line">    - /svr/doclever/img:/root/DOClever/data/img</span><br><span class="line">    - /svr/doclever/tmp:/root/DOClever/data/tmp</span><br><span class="line">    environment:</span><br><span class="line">    - DB_HOST=mongodb://mongo:27017/DOClever</span><br><span class="line">    - PORT=10000</span><br><span class="line">    links:</span><br><span class="line">    - mongo:mongo</span><br><span class="line"></span><br><span class="line">  mongo:</span><br><span class="line">    image: mongo:latest</span><br><span class="line">    restart: always</span><br><span class="line">    container_name: &quot;mongodb&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - /svr/doclever/db:/data/db</span><br></pre></td></tr></table></figure><p>② 运行 <code>docker-compose up -d</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/sx1989827/DOClever/tree/master/docker&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2</title>
    <link href="http://blak-kong.github.io/2020/05/07/2/"/>
    <id>http://blak-kong.github.io/2020/05/07/2/</id>
    <published>2020-05-06T16:41:41.000Z</published>
    <updated>2020-05-06T16:41:41.349Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【docker】centos安装docker和docker-compose</title>
    <link href="http://blak-kong.github.io/2020/05/07/%E3%80%90docker%E3%80%91centos%E5%AE%89%E8%A3%85docker%E5%92%8Cdocker-compose/"/>
    <id>http://blak-kong.github.io/2020/05/07/【docker】centos安装docker和docker-compose/</id>
    <published>2020-05-06T16:21:25.000Z</published>
    <updated>2020-05-06T17:06:10.115Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[TOC]</p><p><a href="https://docs.docker.com/engine/install/centos/" target="_blank" rel="noopener">docker 官方文档：centos 安装</a></p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="一、先运行卸载，确保环境安全"><a href="#一、先运行卸载，确保环境安全" class="headerlink" title="一、先运行卸载，确保环境安全"></a>一、先运行卸载，确保环境安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h3 id="二、使用储存库安装"><a href="#二、使用储存库安装" class="headerlink" title="二、使用储存库安装"></a>二、使用储存库安装</h3><p>在首次在新主机上安装 Docker 引擎之前，需要设置 Docker 存储库。之后，您可以从存储库中安装和更新 Docker。</p><p>设置存储库需要安装<code>yum-utils</code>包</p><p>它提供了<code>yum-config-manager</code>工具，并设置稳定储存库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="三、安装-docker"><a href="#三、安装-docker" class="headerlink" title="三、安装 docker"></a>三、安装 docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装最新版</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装指定版</span><br><span class="line"># 查看版本列表</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line"># 指定版本 有些版本有冒号</span><br><span class="line"># 例如docker-ce.x86_64  3:18.09.1-3.el7</span><br><span class="line"># 应该忽略冒号之前的内容，正确示例：docker-ce-18.09.1</span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure><h3 id="四、启动-docker"><a href="#四、启动-docker" class="headerlink" title="四、启动 docker"></a>四、启动 docker</h3><blockquote><p>sudo systemctl start docker</p></blockquote><h3 id="五、试运行-hello-world"><a href="#五、试运行-hello-world" class="headerlink" title="五、试运行 hello-world"></a>五、试运行 hello-world</h3><blockquote><p>sudo docker run hello-world<br>运行成功则安装成功，且能正常使用</p></blockquote><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>参考菜鸟教程：<a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-compose.html</a></p><p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：<a href="https://github.com/docker/compose/releases。" target="_blank" rel="noopener">https://github.com/docker/compose/releases。</a></p><p>运行以下命令以下载 Docker Compose 的指定版本 1.25.4，要安装其他版本的 Compose，请替换 1.24.1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>将可执行权限应用于二进制文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>创建软链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>测试是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br><span class="line"></span><br><span class="line"># 成功打印 docker-compose version 1.25.4, build 8d51620a</span><br></pre></td></tr></table></figure><h3 id="配置加速地址"><a href="#配置加速地址" class="headerlink" title="配置加速地址"></a>配置加速地址</h3><p>道客云：<a href="http://get.daocloud.io/" target="_blank" rel="noopener">http://get.daocloud.io/</a></p><p>道客云提供加速：<a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">https://www.daocloud.io/mirror</a></p><p>运行加速配置</p><blockquote><p>curl -sSL <a href="https://get.daocloud.io/daotools/set_mirror.sh" target="_blank" rel="noopener">https://get.daocloud.io/daotools/set_mirror.sh</a> | sh -s <a href="http://f1361db2.m.daocloud.io" target="_blank" rel="noopener">http://f1361db2.m.daocloud.io</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/install/centos/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="docker" scheme="http://blak-kong.github.io/tags/docker/"/>
    
      <category term="docker-compose" scheme="http://blak-kong.github.io/tags/docker-compose/"/>
    
      <category term="centos" scheme="http://blak-kong.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>【HTML】参考博客</title>
    <link href="http://blak-kong.github.io/2020/05/05/%E3%80%90HTML%E3%80%91%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2/"/>
    <id>http://blak-kong.github.io/2020/05/05/【HTML】参考博客/</id>
    <published>2020-05-05T13:10:39.000Z</published>
    <updated>2020-05-05T13:52:38.838Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h2 id="一、-网页排版"><a href="#一、-网页排版" class="headerlink" title="一、 网页排版"></a>一、 网页排版</h2><p>排版标签：</p><ul><li><p><code>&lt;h1&gt;</code></p></li><li><p><code>&lt;p&gt;</code></p></li><li><p><code>&lt;hr /&gt;</code> 水平分割线标签</p></li><li><p><code>&lt;br /&gt;</code> 换行标签</p></li><li><p><code>&lt;div&gt;</code></p></li><li><p><code>&lt;span&gt;</code></p></li><li><p><code>&lt;pre&gt;</code> 预定义标签：原样输出内容</p></li></ul><p>原文地址： <a href="https://github.com/qianguyihao/Web/blob/master/01-HTML/04-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E6%8E%92%E7%89%88%E6%A0%87%E7%AD%BE.md" target="_blank" rel="noopener">HTML 标签：排版标签</a></p><h2 id="二、字体与锚点链接"><a href="#二、字体与锚点链接" class="headerlink" title="二、字体与锚点链接"></a>二、字体与锚点链接</h2><p>个人简要笔记：</p><h3 id="2-1-字体"><a href="#2-1-字体" class="headerlink" title="2-1.字体"></a>2-1.字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// b s u i 都是已经废弃的，现在用左边更语义化的标签</span><br><span class="line">strong == b // strong 粗体标签 语义: 定义重要性强调的文字</span><br><span class="line">del == s // del 中划线/删除线 语义(deleted): 定义被删除的文字</span><br><span class="line">ins == u // ins 下划线 语义(inseted): 定义插入的文字</span><br><span class="line">em == i // em 斜体 语义(emphasized): 定义强调的文字</span><br></pre></td></tr></table></figure><h3 id="2-2-锚点链接"><a href="#2-2-锚点链接" class="headerlink" title="2-2.锚点链接"></a>2-2.锚点链接</h3><p>锚点链接即是通过给元素设置 id（设置标记），实现浏览器可以在链接访问网页的时候，在根据链接地址后面的<code>#id</code>参数，来自动定位到网页文档的对应位置。</p><blockquote><p>锚链接的作用是在本页面或者其他页面的的不同位置进行跳转。</p></blockquote><p>比如说，在网页底部有一个向上箭头，点击箭头后回到顶部，这个就可以利用锚链接。</p><p>不过锚链接没有动画，是立即跳转到对应位置。所以实际使用中，往往需要依赖别人封装好的插件。</p><p>例如<code>navScroll.ja</code></p><p>参考原文地址： <a href="https://github.com/qianguyihao/Web/blob/master/01-HTML/05-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%AD%97%E4%BD%93%E6%A0%87%E7%AD%BE%E5%92%8C%E8%B6%85%E9%93%BE%E6%8E%A5.md" target="_blank" rel="noopener">HTML 标签：字体标签和超链接</a></p><h2 id="三、图片标签"><a href="#三、图片标签" class="headerlink" title="三、图片标签"></a>三、图片标签</h2><p>主要注意 align 属性</p><p>图片的 align 属性：图片和周围文字的相对位置。</p><p>属性取值可以是：bottom（默认）、center、top、left、right。</p><p>如果想实现图文混排的效果，请使用 align 属性，取值为 left 或 right。</p><p>我们来分别看一下这 align 属性的这几个属性值的区别。</p><p>1、align=””，图片和文字低端对齐。即默认情况下的显示效果</p><p>2、align=”center”：图片和文字水平方向上居中对齐。 3、align=”top”：图片与文字顶端对齐。</p><p>4、align=”left”：图片在文字的左边。</p><p>5、align=”right”：图片在文字的右边。</p><p>原文地址： <a href="https://github.com/qianguyihao/Web/blob/master/01-HTML/06-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE.md" target="_blank" rel="noopener">HTML 标签：图片标签</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、-网页排版&quot;&gt;&lt;a href=&quot;#一、-网页排版&quot; class=&quot;headerlink&quot; title=&quot;一、 网页排版&quot;&gt;&lt;/a&gt;一、
      
    
    </summary>
    
    
      <category term="html" scheme="http://blak-kong.github.io/tags/html/"/>
    
      <category term="网页排版" scheme="http://blak-kong.github.io/tags/%E7%BD%91%E9%A1%B5%E6%8E%92%E7%89%88/"/>
    
      <category term="他人博客" scheme="http://blak-kong.github.io/tags/%E4%BB%96%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>【HEXO】hexo部署到阿里云</title>
    <link href="http://blak-kong.github.io/2020/05/05/%E3%80%90HEXO%E3%80%91hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <id>http://blak-kong.github.io/2020/05/05/【HEXO】hexo部署到阿里云/</id>
    <published>2020-05-05T13:02:54.000Z</published>
    <updated>2020-05-06T16:25:19.607Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>从零搭建 Hexo 博客并部署阿里云服务器（奶妈级教学）_运维_Object 的博客-CSDN 博客 <a href="https://blog.csdn.net/NoCortY/article/details/99631249" target="_blank" rel="noopener">https://blog.csdn.net/NoCortY/article/details/99631249</a></p><p>有一个修改文件权限的坑，不了解 linux，卡了几小时。</p><p>如果遇到了，参考下面这篇文章，chmod 这一步改成 777 即可</p><p>chmod 修改文件权限 777 和 754_运维_pythonw 的博客-CSDN 博客 <a href="https://blog.csdn.net/pythonw/article/details/80263428" target="_blank" rel="noopener">https://blog.csdn.net/pythonw/article/details/80263428</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;从零搭建 Hexo 博客并部署阿里云服务器（奶妈级教学）_运维_Object 的博客-CSDN 博客 &lt;a href=&quot;https://blog.csdn.net/NoCor
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://blak-kong.github.io/tags/nginx/"/>
    
      <category term="git" scheme="http://blak-kong.github.io/tags/git/"/>
    
      <category term="hexo" scheme="http://blak-kong.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>【HTTPS】记一次阿里云配置https</title>
    <link href="http://blak-kong.github.io/2020/05/05/%E3%80%90HTTPS%E3%80%91%E9%98%BF%E9%87%8C%E4%BA%91%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://blak-kong.github.io/2020/05/05/【HTTPS】阿里云配置https/</id>
    <published>2020-05-05T13:02:03.000Z</published>
    <updated>2020-05-05T14:20:00.878Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[TOC]</p><p>给阿里云配置 https 很简单，只需要申请证书、然后安装到云服务器内的 web 服务器中，配置一下即可。</p><p>阿里云有官方案例，这里选择 nginx</p><p><a href="https://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.6.587.84fd392cMbk2oO</a></p><h2 id="nginx-安装步骤"><a href="#nginx-安装步骤" class="headerlink" title="nginx 安装步骤"></a>nginx 安装步骤</h2><p>我的 nginx 是使用 yum 安装的，所以安装目录在<code>/etc/nginx</code></p><blockquote><p>yum install -y nginx</p></blockquote><p>强烈推荐使用这种方式安装，非常方便</p><h3 id="第一步：上传密钥到-nginx-目录下"><a href="#第一步：上传密钥到-nginx-目录下" class="headerlink" title="第一步：上传密钥到 nginx 目录下"></a>第一步：上传密钥到 nginx 目录下</h3><p>在 nginx 目录下运行</p><blockquote><p>mkdir cert</p></blockquote><p>创建密钥文件夹，把密钥文件都上传到该文件夹下。</p><h3 id="第二步：配置-nginx"><a href="#第二步：配置-nginx" class="headerlink" title="第二步：配置 nginx"></a>第二步：配置 nginx</h3><p>我们使用 nginx 不应该任何时候都直接改动 <code>nginx.conf</code>，这里我有一个<code>vhost/blog.conf</code>的文件夹，里面配置了一个代理的网站。参考配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">root</span> /home/www/blog-website;</span><br><span class="line">  <span class="attribute">server_name</span> www.lzwlook.fun lzwlook.fun;</span><br><span class="line">  <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://www.lzwlook.fun/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">  <span class="attribute">root</span> /home/www/blog-website;</span><br><span class="line">  <span class="attribute">server_name</span> www.lzwlook.fun lzwlook.fun;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">ssl_certificate</span> /etc/nginx/cert/3847437_www.lzwlook.fun.pem;</span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> /etc/nginx/cert/3847437_www.lzwlook.fun.key;</span><br><span class="line">  <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;</span><br><span class="line">  <span class="attribute">ssl_session_timeout</span>  <span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  <span class="comment">#使用此加密套件。</span></span><br><span class="line">  <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;   <span class="comment">#使用该协议进行配置。</span></span><br><span class="line">  <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、重启-nginx"><a href="#三、重启-nginx" class="headerlink" title="三、重启 nginx"></a>三、重启 nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="补充：使用-include-管理项目"><a href="#补充：使用-include-管理项目" class="headerlink" title="补充：使用 include 管理项目"></a>补充：使用 include 管理项目</h3><p>目前对于 nginx 不够了解，仅仅是文抄公。</p><p>这里再补一下，创建 vhost 文件夹后，nginx 中怎么生效。</p><p>我们还需要在 nginx.conf 中通过<code>include</code>，进行引入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>; <span class="comment"># 这个是自带的</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/vhost/<span class="regexp">*.conf</span>; <span class="comment"># 这是我们的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 nginx.conf 文件中使用 include 引入文件夹和配置，会让项目的管理方便很多，这样只要给每个新增项目建一个 <code>\*\*.conf</code> 文件就好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;给阿里云配置 https 很简单，只需要申请证书、然后安装到云服务器内的 web 服务器中，配置一下即可。&lt;/p&gt;
&lt;p&gt;阿里云有官方案例，这里选择
      
    
    </summary>
    
      <category term="云服务器" scheme="http://blak-kong.github.io/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="nginx" scheme="http://blak-kong.github.io/tags/nginx/"/>
    
      <category term="https" scheme="http://blak-kong.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://blak-kong.github.io/2020/04/15/test/"/>
    <id>http://blak-kong.github.io/2020/04/15/test/</id>
    <published>2020-04-14T18:40:01.195Z</published>
    <updated>2020-04-14T18:40:17.909Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
      <category term="test" scheme="http://blak-kong.github.io/categories/test/"/>
    
    
  </entry>
  
  <entry>
    <title>node+mongoodb学习</title>
    <link href="http://blak-kong.github.io/2019/04/07/node+mongoodb%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <id>http://blak-kong.github.io/2019/04/07/node+mongoodb学习(一)/</id>
    <published>2019-04-07T12:26:53.000Z</published>
    <updated>2019-06-16T08:32:20.105Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>此系列将在一周内更新完，不记细节，只记基础知识点</p><h4 id="1-服务器启动"><a href="#1-服务器启动" class="headerlink" title="1.服务器启动"></a>1.服务器启动</h4><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p><p>使用 Express 可以快速地搭建一个完整功能的网站。</p><a id="more"></a><p>Express 框架核心特性：</p><ul><li>可以设置中间件来响应 HTTP 请求。</li><li>定义了路由表用于执行不同的 HTTP 请求动作。</li><li>可以通过向模板传递参数来动态渲染 HTML 页面。</li></ul><p>启动文件：server.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);<span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express(); <span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> port = process.env.PORT || <span class="number">5000</span>; <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(<span class="string">"hello world!"</span>) <span class="comment">// 默认输出</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(port, () =&gt; &#123; <span class="comment">// 监听</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Server running on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>此时推荐安装插件nodemon，它默认会监听当前目录，重启Express</p><h4 id="2-mongodb创建数据库"><a href="#2-mongodb创建数据库" class="headerlink" title="2.mongodb创建数据库"></a>2.mongodb创建数据库</h4><p>数据库：config/keys.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 本地写法，无需登录</span></span><br><span class="line">    mongoURI: <span class="string">"mongodb://localhost:27017/testData"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 远程写法</span></span><br><span class="line">    mongoURI: <span class="string">"mongodb://名称:密码@远程 数据库地址/testData"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回到启动文件：server.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>) <span class="comment">// 引入mongo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DB config</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">"./config/keys"</span>).mongoURI; <span class="comment">// 引入数据库地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// connect to mongodb 链接mongodb</span></span><br><span class="line">mongoose.connect(db, &#123;<span class="attr">useNewUrlParser</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"MongoDB Connected 666"</span>)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></p><p>访问mongodb成功后，node命令行会输出MongoDB Connected 666</p><h4 id="3-创建接口"><a href="#3-创建接口" class="headerlink" title="3.创建接口"></a>3.创建接口</h4><p>接口目录:router/api/user.js<br>以下为最简单的router接口访问，只能输出消息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// login &amp; register</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $route   GET api/users/test</span></span><br><span class="line"><span class="comment">// @desc    返回的请求的json数据</span></span><br><span class="line"><span class="comment">// @access  public</span></span><br><span class="line">router.get(<span class="string">"/test"</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;<span class="attr">msg</span>: <span class="string">"login works"</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如果需要实现更多功能，则需要编写逻辑，甚至安装更多插件配合。<br>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">"bcrypt"</span>); <span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">const</span> gravatar = <span class="built_in">require</span>(<span class="string">'gravatar'</span>); <span class="comment">// 全球公共头像</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">"jsonwebtoken"</span>); <span class="comment">// 生成token</span></span><br></pre></td></tr></table></figure></p><h4 id="4-为什么接口要用到Schema"><a href="#4-为什么接口要用到Schema" class="headerlink" title="4.为什么接口要用到Schema"></a>4.为什么接口要用到Schema</h4><p>在数据库中，schema（模式）是数据库的组织和结构。<br>也就是数据结构。</p><p>1.在创建接口后，根据字段需要，创建schema（模式）。</p><p>2.该接口在前后端的字段传值，必须符合schema（模式）的定义。</p><p>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">"mongoose"</span>)</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Schema 模型</span></span><br><span class="line"><span class="keyword">const</span> UserSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    email: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    password: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    avatar: &#123;</span><br><span class="line">        type: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    date: &#123;</span><br><span class="line">        type: <span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">Date</span>.now</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = User = mongoose.model(<span class="string">"users"</span>, UserSchema);</span><br></pre></td></tr></table></figure></p><h4 id="5-接口调试工具：postman"><a href="#5-接口调试工具：postman" class="headerlink" title="5.接口调试工具：postman"></a>5.接口调试工具：postman</h4><p>1.谷歌应用商店搜索postman，安装使用</p><p>2.直接百度搜索，下载安装软件</p><h4 id="5-1-Express中间件body-parser"><a href="#5-1-Express中间件body-parser" class="headerlink" title="5.1.Express中间件body-parser"></a>5.1.Express中间件body-parser</h4><p>当express使用get以外的请求时，需要安装中间件body-parser处理不同类型的请求</p><p>body-parser实现的·要点如下：</p><ul><li>处理不同类型的请求体：<code>比如text、json、urlencoded等，对应的报文主体的格式不同</code>。</li><li>处理不同的编码：<code>比如utf8、gbk等</code>。</li><li>处理不同的压缩类型：<code>比如gzip、deflare等</code>。</li><li>其他边界、异常的处理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h4&gt;&lt;p&gt;此系列将在一周内更新完，不记细节，只记基础知识点&lt;/p&gt;
&lt;h4 id=&quot;1-服务器启动&quot;&gt;&lt;a href=&quot;#1-服务器启动&quot; class=&quot;headerlink&quot; title=&quot;1.服务器启动&quot;&gt;&lt;/a&gt;1.服务器启动&lt;/h4&gt;&lt;p&gt;Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。&lt;/p&gt;
&lt;p&gt;使用 Express 可以快速地搭建一个完整功能的网站。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blak-kong.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="http://blak-kong.github.io/tags/node/"/>
    
      <category term="mongoodb" scheme="http://blak-kong.github.io/tags/mongoodb/"/>
    
      <category term="实战笔记" scheme="http://blak-kong.github.io/tags/%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>组件间数据传递</title>
    <link href="http://blak-kong.github.io/2018/05/03/%E7%BB%84%E4%BB%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>http://blak-kong.github.io/2018/05/03/组件间数据传递/</id>
    <published>2018-05-03T07:16:02.000Z</published>
    <updated>2019-06-16T08:33:47.917Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h1><p>在一个组件内部定义另一个组件，称为父子组件<br>子组件只能在父组件内部使用<br>默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的</p><a id="more"></a><h1 id="组件间数据传递-（通信）"><a href="#组件间数据传递-（通信）" class="headerlink" title="组件间数据传递 （通信）"></a>组件间数据传递 （通信）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;food @add=&quot;addFood&quot; :food=&quot;selectedFood&quot; ref=&quot;food&quot;&gt;&lt;/food&gt;</span><br></pre></td></tr></table></figure><h2 id="子组件访问父组件的数据"><a href="#子组件访问父组件的数据" class="headerlink" title="子组件访问父组件的数据"></a>子组件访问父组件的数据</h2><ul><li><p>a)在调用子组件时，v-bind绑定想要获取的父组件中的数据</p></li><li><p>b)在子组件内部，使用props选项声明获取的数据，即接收来自父组件的数据</p><ul><li>总结：父组件通过props向下传递数据给子组件</li></ul></li></ul><p>注：组件中的数据共有三种形式：data、props、computed</p><h2 id="父组件访问子组件的数据"><a href="#父组件访问子组件的数据" class="headerlink" title="父组件访问子组件的数据"></a>父组件访问子组件的数据</h2><ul><li>a)在子组件中使用vm.$emit(事件名,数据)触发一个自定义事件，事件名自定义</li><li>b)父组件在使用子组件的地方监听子组件触发的事件，并在父组件中定义方法，用来获取数据<ul><li>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件</li></ul></li></ul><h4 id="父组件在标签使用-方法，监听子组件发射回来的函数"><a href="#父组件在标签使用-方法，监听子组件发射回来的函数" class="headerlink" title="父组件在标签使用@方法，监听子组件发射回来的函数"></a>父组件在标签使用@方法，监听子组件发射回来的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addFood(target) &#123;</span><br><span class="line">        this.$emit(&apos;add&apos;, target);//把事件传递到父组件@add所绑定的函数</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>props是单向绑定的，当父组件的属性变化时，将传导给子组件，但是不会反过来<br>而且不允许子组件直接修改父组件中的数据，报错</p><p>解决方式：</p><pre><code>- 方式1：如果子组件想把它作为局部数据来使用，可以将数据存入另一个变量中再操作，不影响父组件中的数据- 方式2：如果子组件想修改数据并且同步更新到父组件，两个方法：    - a.使用.sync（1.0版本中支持，2.0版本中不支持，2.3版本又开始支持）        需要显式地触发一个更新事件`this.$emit(&apos;update:name&apos;,&apos;alice&apos;)`    - b.可以将父组件中的数据包装成对象，然后在子组件中修改对象的属性(因为对象是引用类型，指向同一个内存空间)，推荐</code></pre><h2 id="非父子组件间的通信"><a href="#非父子组件间的通信" class="headerlink" title="非父子组件间的通信"></a>非父子组件间的通信</h2><p>非父子组件间的通信，可以通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Event=new Vue();// 定义空实例（其他实例都会挂载到它上面）</span><br><span class="line">Event.$emit(事件名,数据); // 触发当前实例上的事件。附加参数都会传给监听器回调。</span><br><span class="line">Event.$on(事件名,data =&gt; &#123;&#125;); // 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;父子组件&quot;&gt;&lt;a href=&quot;#父子组件&quot; class=&quot;headerlink&quot; title=&quot;父子组件&quot;&gt;&lt;/a&gt;父子组件&lt;/h1&gt;&lt;p&gt;在一个组件内部定义另一个组件，称为父子组件&lt;br&gt;子组件只能在父组件内部使用&lt;br&gt;默认情况下，子组件无法访问父组件中的数据，每个组件实例的作用域是独立的&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue组件" scheme="http://blak-kong.github.io/tags/vue%E7%BB%84%E4%BB%B6/"/>
    
      <category term="数据传递" scheme="http://blak-kong.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>组件component</title>
    <link href="http://blak-kong.github.io/2018/05/03/%E7%BB%84%E4%BB%B6component/"/>
    <id>http://blak-kong.github.io/2018/05/03/组件component/</id>
    <published>2018-05-03T03:55:47.000Z</published>
    <updated>2019-04-07T14:56:55.760Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h2 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h2><p>组件（Component）是 Vue.js 最强大的功能之一。<br>组件可以扩展 HTML 元素，封装可重用的代码<br>组件是自定义元素（对象）</p><a id="more"></a><h2 id="定义组件的方式"><a href="#定义组件的方式" class="headerlink" title="定义组件的方式"></a>定义组件的方式</h2><h4 id="方式1：先创建组件构造器，然后由组件构造器创建组件（全局）"><a href="#方式1：先创建组件构造器，然后由组件构造器创建组件（全局）" class="headerlink" title="方式1：先创建组件构造器，然后由组件构造器创建组件（全局）"></a>方式1：先创建组件构造器，然后由组件构造器创建组件（全局）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.使用Vue.extend()创建一个组件构造器</span><br><span class="line">var MyComponent=Vue.extend(&#123;</span><br><span class="line">template:&apos;&lt;h3&gt;Hello World&lt;/h3&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">2.使用Vue.component(标签名,组件构造器)，根据组件构造器来创建组件</span><br><span class="line">Vue.component(&apos;hello&apos;,MyComponent);</span><br></pre></td></tr></table></figure><h4 id="方式2：直接创建组件（全局）"><a href="#方式2：直接创建组件（全局）" class="headerlink" title="方式2：直接创建组件（全局）"></a>方式2：直接创建组件（全局）</h4><p>直接把组件构造器写在{}里定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;my-world&apos;,&#123;</span><br><span class="line">template:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="方式3：局部组件（常用）"><a href="#方式3：局部组件（常用）" class="headerlink" title="方式3：局部组件（常用）"></a>方式3：局部组件（常用）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 挂载到单页面里，只在当前页有效</span><br><span class="line">components:&#123;</span><br><span class="line">    &apos;my-world&apos;,&#123;</span><br><span class="line">template:&apos;&lt;h1&gt;你好，世界&lt;/h1&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件中添加数据"><a href="#组件中添加数据" class="headerlink" title="组件中添加数据"></a>组件中添加数据</h2><p>在组件中存储数据时，必须以函数形式，函数返回一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">components:&#123; //局部组件</span><br><span class="line">&apos;my-world&apos;:&#123;</span><br><span class="line">template:&apos;&lt;h3&gt;&#123;&#123;age&#125;&#125;&lt;/h3&gt;&apos;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">age:25</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="引用模板"><a href="#引用模板" class="headerlink" title="引用模板"></a>引用模板</h2><p>组件化开发中，引用模板为直接创建新文件，作为组件。<br>组件名为文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template id=&quot;wbs&quot;&gt;</span><br><span class="line">&lt;!-- &lt;template&gt;必须有且只有一个根元素 --&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">components:&#123;</span><br><span class="line">&apos;my-hello&apos;:&#123;</span><br><span class="line">name:&apos;wbs17022&apos;,  //指定组件的名称，默认为标签名，可以不设置</span><br><span class="line">template:&apos;#wbs&apos;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">msg:&apos;欢迎来到南京网博&apos;,</span><br><span class="line">arr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态加载组件"><a href="#动态加载组件" class="headerlink" title="动态加载组件"></a>动态加载组件</h2><p><code>&lt;component :is=&quot;挂载点&quot;&gt;</code><br>    多个组件使用同一个挂载点，然后动态的在它们之间切换    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;flag=&apos;my-hello&apos;&quot;&gt;显示hello组件&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;flag=&apos;my-world&apos;&quot;&gt;显示world组件&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;component :is=&quot;flag&quot;&gt;&lt;/component&gt;</span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">flag:&apos;my-hello&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lt-keep-alive-gt-缓存组件"><a href="#lt-keep-alive-gt-缓存组件" class="headerlink" title="&lt;keep-alive&gt;缓存组件"></a><code>&lt;keep-alive&gt;</code>缓存组件</h2><p>标签的组件实例能够被在它们第一次被创建的时候缓存下来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;什么是组件？&quot;&gt;&lt;a href=&quot;#什么是组件？&quot; class=&quot;headerlink&quot; title=&quot;什么是组件？&quot;&gt;&lt;/a&gt;什么是组件？&lt;/h2&gt;&lt;p&gt;组件（Component）是 Vue.js 最强大的功能之一。&lt;br&gt;组件可以扩展 HTML 元素，封装可重用的代码&lt;br&gt;组件是自定义元素（对象）&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue组件" scheme="http://blak-kong.github.io/tags/vue%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>练习：vue自定义指令</title>
    <link href="http://blak-kong.github.io/2018/05/02/%E7%BB%83%E4%B9%A0%EF%BC%9Avue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
    <id>http://blak-kong.github.io/2018/05/02/练习：vue自定义指令/</id>
    <published>2018-05-02T07:57:07.000Z</published>
    <updated>2019-04-07T14:56:55.757Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这是很少会更新的附带完整代码的博客。<br>究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;练习：自定义指令&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#itany div&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">position:absolute;</span><br><span class="line">&#125;</span><br><span class="line">#itany .hello&#123;</span><br><span class="line">background-color:red;</span><br><span class="line">top:0;</span><br><span class="line">left:0;</span><br><span class="line">&#125;</span><br><span class="line">#itany .world&#123;</span><br><span class="line">background-color:blue;</span><br><span class="line">top:0;</span><br><span class="line">right:0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;itany&quot;&gt;</span><br><span class="line">&lt;div class=&quot;hello&quot; v-drag&gt;itany&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;world&quot; v-drag&gt;网博&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">        // vue全局自定义指令</span><br><span class="line">Vue.directive(&apos;drag&apos;,function(el)&#123;</span><br><span class="line">el.onmousedown=function(e)&#123;</span><br><span class="line">// 获取鼠标点击处分别与div左边和上边的距离：鼠标位置-div位置</span><br><span class="line">var disX=e.clientX-el.offsetLeft;</span><br><span class="line">var disY=e.clientY-el.offsetTop;</span><br><span class="line">// console.log(disX,disY);</span><br><span class="line"></span><br><span class="line">//包含在onmousedown里面，表示点击后才移动，为防止鼠标移出div，使用document.onmousemove</span><br><span class="line">document.onmousemove=function(e)&#123;</span><br><span class="line">// 获取移动后div的位置：鼠标位置-disX/disY</span><br><span class="line">// 因为offset获取的是左边和上边，所以移动需使用减法</span><br><span class="line">var l=e.clientX-disX;</span><br><span class="line">var t=e.clientY-disY;</span><br><span class="line">el.style.left=l+&apos;px&apos;;// 记得要加px像素单位,否则不移动</span><br><span class="line">el.style.top=t+&apos;px&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//停止移动，鼠标抬起触发</span><br><span class="line">document.onmouseup=function(e)&#123;</span><br><span class="line">                    // 清空鼠标按住状态</span><br><span class="line">document.onmousemove=null;</span><br><span class="line">                    // 销毁自身</span><br><span class="line">document.onmouseup=null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var vm=new Vue(&#123;</span><br><span class="line">el:&apos;#itany&apos;,</span><br><span class="line">data:&#123;</span><br><span class="line">msg:&apos;welcome to itany&apos;,</span><br><span class="line">username:&apos;alice&apos;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">change()&#123;</span><br><span class="line">this.msg=&apos;欢迎来到南京网博&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是很少会更新的附带完整代码的博客。&lt;br&gt;究其原因，有些并不复杂，但不方便总结的知识点，直接看源码更方便。&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>CSSOM视图模式</title>
    <link href="http://blak-kong.github.io/2018/05/02/CSSOM%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blak-kong.github.io/2018/05/02/CSSOM视图模式/</id>
    <published>2018-05-02T05:26:18.000Z</published>
    <updated>2019-04-07T14:56:53.530Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="CSSOM视图模块-CSSOM-View-Module"><a href="#CSSOM视图模块-CSSOM-View-Module" class="headerlink" title="CSSOM视图模块(CSSOM View Module)"></a>CSSOM视图模块(CSSOM View Module)</h1><p>它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性</p><p>包括布局框定位、视区宽度和元素滚动。</p><p>以下就是一些API属性的相关内容，包括兼容性，使用，测试等。</p><a id="more"></a><h2 id="window视图属性（几乎没用）"><a href="#window视图属性（几乎没用）" class="headerlink" title="window视图属性（几乎没用）"></a>window视图属性（几乎没用）</h2><p>这些属性可以hold住整个浏览器窗体大小。微软则将这些API称为“Screenview 接口”。</p><blockquote><p>语法：window.xxxxx</p></blockquote><p>它们一般没什么用，仅作了解：</p><ul><li>innerWidth 属性和 innerHeight 属性<ul><li>表示获取window窗体的内部宽高，不包括用户界面元素，比如窗框。</li></ul></li><li>pageXOffset 属性和 pageYOffset 属性<ul><li>表示整个浏览器窗体的大小，包括任务栏等。</li></ul></li><li>screenX 属性和 screenY 属性<ul><li>表示整个页面滚动的像素值（水平方向的和垂直方向的）</li></ul></li><li>outerWidth 属性和 outerHeight 属性<ul><li>浏览器窗口在显示器中的位置，screenX表示水平位置，screenY表示垂直位置。</li></ul></li></ul><h2 id="Screen视图属性（几乎没用）"><a href="#Screen视图属性（几乎没用）" class="headerlink" title="Screen视图属性（几乎没用）"></a>Screen视图属性（几乎没用）</h2><blockquote><p>语法：screen.xxxxx</p></blockquote><ul><li>availWidth和availHeight<ul><li>显示器可用宽高，不包括任务栏之类的东东。</li></ul></li><li>width和height<ul><li>表示显示器屏幕的宽高。</li></ul></li></ul><h2 id="元素视图属性-重点"><a href="#元素视图属性-重点" class="headerlink" title="元素视图属性 (重点)"></a>元素视图属性 (重点)</h2><p>使用方法，自己获取页面元素，然后对元素应用方法。</p><ul><li>clientLeft和clientTop（事件内容的位置）<ul><li>表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。</li></ul></li></ul><ul><li><p>clientWidth和clientHeight（事件内容的大小）</p><ul><li>表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。</li></ul></li><li><p>offsetLeft和offsetTop（检测位置）</p><ul><li>表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。</li></ul></li></ul><ul><li><p>offsetWidth和offsetHeight（检测大小）</p><ul><li>整个元素的尺寸（包括边框）。</li></ul></li><li><p>scrollLeft和scrollTop（用于滚动）</p><ul><li>表示元素滚动的像素大小。可读可写。</li></ul></li><li><p>scrollWidth和scrollHeight（整个内容的宽高-包括滚动）</p><ul><li>表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。</li></ul></li></ul><h2 id="鼠标位置-（重要）"><a href="#鼠标位置-（重要）" class="headerlink" title="鼠标位置 （重要）"></a>鼠标位置 （重要）</h2><blockquote><p>语法：event.clientX</p></blockquote><ul><li>clientX,clientY<ul><li>相对于window，为鼠标相对于window的偏移。</li></ul></li></ul><blockquote><p>用于点击移动</p></blockquote><ul><li>offsetX, offsetY<ul><li>表示鼠标相对于当前被点击元素padding box的左上偏移值，各个浏览器的兼容性五花八门.</li></ul></li></ul><blockquote><p>获取鼠标在元素内的位置</p></blockquote><ul><li><p>pageX, pageY（兼容性不好）</p><ul><li>为鼠标相对于document的坐标。</li></ul></li><li><p>screenX, screenY</p><ul><li>鼠标相对于显示器屏幕的偏移坐标。</li></ul></li></ul><h4 id="clientXY-offsetXY组合用法"><a href="#clientXY-offsetXY组合用法" class="headerlink" title="clientXY+offsetXY组合用法"></a>clientXY+offsetXY组合用法</h4><blockquote><p>clienX-offsetX = 元素不超出页面</p></blockquote><p>因为window宽度就是浏览器宽度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSSOM视图模块-CSSOM-View-Module&quot;&gt;&lt;a href=&quot;#CSSOM视图模块-CSSOM-View-Module&quot; class=&quot;headerlink&quot; title=&quot;CSSOM视图模块(CSSOM View Module)&quot;&gt;&lt;/a&gt;CSSOM视图模块(CSSOM View Module)&lt;/h1&gt;&lt;p&gt;它定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性&lt;/p&gt;
&lt;p&gt;包括布局框定位、视区宽度和元素滚动。&lt;/p&gt;
&lt;p&gt;以下就是一些API属性的相关内容，包括兼容性，使用，测试等。&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="浏览器视图属性" scheme="http://blak-kong.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%86%E5%9B%BE%E5%B1%9E%E6%80%A7/"/>
    
      <category term="页面内元素移动和滚动" scheme="http://blak-kong.github.io/tags/%E9%A1%B5%E9%9D%A2%E5%86%85%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%BB%9A%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>vue动画</title>
    <link href="http://blak-kong.github.io/2018/05/01/vue%E5%8A%A8%E7%94%BB%E4%B8%8Eanimations%E5%8A%A8%E7%94%BB%E5%BA%93/"/>
    <id>http://blak-kong.github.io/2018/05/01/vue动画与animations动画库/</id>
    <published>2018-05-01T14:32:07.000Z</published>
    <updated>2019-04-07T14:56:55.728Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h2><p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p><ul><li>条件渲染 (使用 v-if)</li><li>条件展示 (使用 v-show)</li><li>动态组件</li><li>组件根节点</li></ul><p>vue的动画也是使用css3实现的。<br>只是写法有些不一样，我们需要将代码嵌套在<transition>中</transition></p><a id="more"></a><h2 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h2><p>而与css动画最大的区别，我们需要使用vue自带的模板语法<br>通过Vue自带的类名，我们可以定义css动画的触发时机</p><p>在进入/离开的过渡中，会有 6 个 class 切换。</p><ul><li><p>v-enter：定义进入过渡的开始状态。</p><ul><li>在元素被插入之前生效，在元素被插入之后的下一帧移除。</li></ul></li><li><p>v-enter-active：定义进入过渡生效时的状态。</p><ul><li>在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li></ul></li><li><p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。</p><ul><li>在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</li></ul></li><li><p>v-leave: 定义离开过渡的开始状态。</p><ul><li>在离开过渡被触发时立刻生效，下一帧被移除。</li></ul></li><li><p>v-leave-active：定义离开过渡生效时的状态。</p><ul><li>在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li></ul></li><li><p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。</p><ul><li>在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.fade-enter-active,.fade-leave-active&#123;</span><br><span class="line">transition:all 3s ease;</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter-active&#123;</span><br><span class="line">opacity:1;// 动画开始状态</span><br><span class="line">width:300px;</span><br><span class="line">height:300px;</span><br><span class="line">&#125;</span><br><span class="line">.fade-leave-active&#123;</span><br><span class="line">opacity:0;</span><br><span class="line">width:50px;</span><br><span class="line">height:50px;</span><br><span class="line">&#125;</span><br><span class="line">/* .fade-enter需要放在.fade-enter-active的后面 */</span><br><span class="line">.fade-enter&#123;</span><br><span class="line">opacity:0; /*初始状态（css重叠样式表，属性覆盖，必须放后面）*/</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="javaScript-钩子"><a href="#javaScript-钩子" class="headerlink" title="javaScript 钩子"></a>javaScript 钩子</h2><p>可以在属性中声明 JavaScript 钩子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;fade&quot; </span><br><span class="line">@before-enter=&quot;beforeEnter&quot;// 动画进入之前</span><br><span class="line">@enter=&quot;enter&quot;// 动画进入</span><br><span class="line">@after-enter=&quot;afterEnter&quot;// 动画进入之后</span><br><span class="line"></span><br><span class="line">@before-leave=&quot;beforeLeave&quot;// 动画即将离开之前</span><br><span class="line">@leave=&quot;leave&quot;// 动画离开</span><br><span class="line">@after-leave=&quot;afterLeave&quot;// 动画离开之后</span><br><span class="line">&gt;</span><br><span class="line">&lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>钩子函数的触发时机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">beforeEnter(el)&#123;</span><br><span class="line">// alert(&apos;动画进入之前&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">enter()&#123;</span><br><span class="line">// alert(&apos;动画进入&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">afterEnter(el)&#123;</span><br><span class="line">// alert(&apos;动画进入之后&apos;);</span><br><span class="line">el.style.background=&apos;blue&apos;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">beforeLeave()&#123;</span><br><span class="line">// alert(&apos;动画即将之前&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">leave()&#123;</span><br><span class="line">// alert(&apos;动画离开&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">afterLeave(el)&#123;</span><br><span class="line">// alert(&apos;动画离开之后&apos;);</span><br><span class="line">el.style.background=&apos;red&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。</p><blockquote><p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。<br>否则，它们会被同步调用，过渡会立即完成。</p></blockquote><blockquote><p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。<br>这也可以避免过渡过程中 CSS 的影响。</p></blockquote><h1 id="在vue中使用animations-css动画库"><a href="#在vue中使用animations-css动画库" class="headerlink" title="在vue中使用animations.css动画库"></a>在vue中使用animations.css动画库</h1><p>只需要引入animations.css，然后写法如下，在标签中直接定义开始动画和离开动画即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition enter-active-class=&quot;animated fadeInLeft&quot; leave-active-class=&quot;animated fadeOutRight&quot;&gt;</span><br><span class="line">&lt;p v-show=&quot;flag&quot;&gt;网博&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><h2 id="多元素动画"><a href="#多元素动画" class="headerlink" title="多元素动画"></a>多元素动画</h2><p>对于原生标签可以使用 v-if/v-else 。</p><p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。<br>即使在技术上没有必要，给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key 也是一个更好的实践。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt;</span><br><span class="line">&lt;p v-show=&quot;flag&quot; :key=&quot;1&quot;&gt;itany&lt;/p&gt;</span><br><span class="line">&lt;p v-show=&quot;flag&quot; :key=&quot;2&quot;&gt;网博&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></p><p>我们也可以通过给同一个元素的 key 特性设置不同的状态<br>来代替 v-if 和 v-else</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</span><br><span class="line">    &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>或者使用多个if</p><h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p>同时渲染整个列表<code>&lt;transition-group&gt;</code></p><ul><li>不同于 <transition>，它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。</span></transition></li><li>内部元素 总是需要 提供唯一的 key 属性值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;itany&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;transition-group enter-active-class=&quot;animated bounceInLeft&quot; leave-active-class=&quot;animated bounceOutRight&quot;&gt;</span><br><span class="line">&lt;p v-for=&quot;(v,k) in arr2&quot; :key=&quot;k&quot; v-show=&quot;flag&quot;&gt;</span><br><span class="line">&#123;&#123;v&#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm=new Vue(&#123;</span><br><span class="line">el:&apos;#itany&apos;,</span><br><span class="line">data:&#123;</span><br><span class="line">flag:true,</span><br><span class="line">arr:[&apos;tom&apos;,&apos;jack&apos;,&apos;mike&apos;,&apos;alice&apos;,&apos;alex&apos;,&apos;mark&apos;],</span><br><span class="line">name:&apos;&apos;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">arr2:function()&#123;</span><br><span class="line">var temp=[];</span><br><span class="line">this.arr.forEach(val =&gt; &#123;</span><br><span class="line">// Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</span><br><span class="line">if(val.includes(this.name))&#123; // 判断是否存在传入字符，存在则push元素</span><br><span class="line">temp.push(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>检测元素数组元素是否存在：<br>Array.prototype.includes(): 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单元素-组件的过渡&quot;&gt;&lt;a href=&quot;#单元素-组件的过渡&quot; class=&quot;headerlink&quot; title=&quot;单元素/组件的过渡&quot;&gt;&lt;/a&gt;单元素/组件的过渡&lt;/h2&gt;&lt;p&gt;Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件渲染 (使用 v-if)&lt;/li&gt;
&lt;li&gt;条件展示 (使用 v-show)&lt;/li&gt;
&lt;li&gt;动态组件&lt;/li&gt;
&lt;li&gt;组件根节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vue的动画也是使用css3实现的。&lt;br&gt;只是写法有些不一样，我们需要将代码嵌套在&lt;transition&gt;中&lt;/transition&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue自定义指定</title>
    <link href="http://blak-kong.github.io/2018/05/01/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E5%AE%9A/"/>
    <id>http://blak-kong.github.io/2018/05/01/vue自定义指定/</id>
    <published>2018-05-01T14:31:39.000Z</published>
    <updated>2019-06-16T08:32:57.309Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[TOC]</p><h1 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>/**</p><ul><li>自定义全局指令</li><li>注：使用指令时必须在指名名称前加前缀v-，即v-指令名称<br>*/</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;hello&apos;,&#123;</span><br><span class="line">bind()&#123; //常用！！</span><br><span class="line">alert(&apos;指令第一次绑定到元素上时调用，只调用一次，可执行初始化操作&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">inserted()&#123;</span><br><span class="line">alert(&apos;被绑定元素插入到DOM中时调用&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">update()&#123;</span><br><span class="line">alert(&apos;被绑定元素所在模板更新时调用&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">componentUpdated()&#123;</span><br><span class="line">alert(&apos;被绑定元素所在模板完成一次更新周期时调用&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">unbind()&#123;</span><br><span class="line">alert(&apos;指令与元素解绑时调用，只调用一次&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="全局注册自定义指令"><a href="#全局注册自定义指令" class="headerlink" title="全局注册自定义指令"></a>全局注册自定义指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注册一个全局自定义指令 `v-focus`</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当被绑定的元素插入到 DOM 中时调用</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">// 自定义指令名</span><br><span class="line">  focus: &#123;</span><br><span class="line">    // 指令的定义</span><br><span class="line">    inserted: function (el) &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在模板中使用"><a href="#在模板中使用" class="headerlink" title="在模板中使用"></a>在模板中使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure><h2 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h2><ul><li>常用参数为<code>el</code>和<code>binding</code></li></ul><p>钩子函数        参数1  参数2   参数3<br>bind: function (el, binding, vnode)</p><p>指令钩子函数会被传入以下参数：</p><ul><li>el：指令所绑定的元素，可以用来直接操作 DOM 。可以为它绑定事件、也可以直接修改dom属性。</li><li>binding：一个对象。包含以下属性：<ul><li>name：指令名，不包括 v- 前缀。</li><li>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</li><li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li><li>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</li><li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li><li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li></ul></li><li>vnode：Vue 编译生成的虚拟节点。</li><li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;demo&apos;, &#123;// demo为指令名</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;自定义属性&quot;&gt;&lt;a href=&quot;#自定义属性&quot; class=&quot;headerlink&quot; title=&quot;自定义属性&quot;&gt;&lt;/a&gt;自定义属性&lt;/h1&gt;&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义全局指令&lt;/li&gt;
&lt;li&gt;注：使用指令时必须在指名名称前加前缀v-，即v-指令名称&lt;br&gt;*/&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="vue" scheme="http://blak-kong.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue的实例属性和方法</title>
    <link href="http://blak-kong.github.io/2018/05/01/vue%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://blak-kong.github.io/2018/05/01/vue的实例属性和方法/</id>
    <published>2018-05-01T14:31:14.000Z</published>
    <updated>2019-06-16T08:32:49.288Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[TOC]</p><h1 id="vue实例的属性和方法"><a href="#vue实例的属性和方法" class="headerlink" title="vue实例的属性和方法"></a>vue实例的属性和方法</h1><p>仅记录部分<br>大部分时候是随学随用，但是学到了就来记录。</p><blockquote><p>实例属性和方法 == 组件实例和方法 != 全局属性和方法</p></blockquote><ul><li>另外，在组件实例的<code>methods方法</code>中不能使用全局Vue方法</li></ul><a id="more"></a><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h4 id="vm-属性名-获取data中的属性"><a href="#vm-属性名-获取data中的属性" class="headerlink" title="vm.属性名 获取data中的属性"></a>vm.属性名 获取data中的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//console.log(vm.msg);</span><br></pre></td></tr></table></figure><h4 id="vm-el-获取vue实例关联的元素"><a href="#vm-el-获取vue实例关联的元素" class="headerlink" title="vm.$el 获取vue实例关联的元素"></a>vm.$el 获取vue实例关联的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// console.log(vm.$el); //DOM对象</span><br><span class="line">// vm.$el.style.color=&apos;red&apos;;</span><br></pre></td></tr></table></figure><h4 id="vm-data-获取数据对象data"><a href="#vm-data-获取数据对象data" class="headerlink" title="vm.$data 获取数据对象data"></a>vm.$data 获取数据对象data</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// console.log(vm.$data);</span><br><span class="line">// console.log(vm.$data.msg);</span><br></pre></td></tr></table></figure><h4 id="vm-options-获取自定义属性"><a href="#vm-options-获取自定义属性" class="headerlink" title="vm.$options 获取自定义属性"></a>vm.$options 获取自定义属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// console.log(vm.$options.name);</span><br><span class="line">// console.log(vm.$options.age);</span><br><span class="line">// vm.$options.show();</span><br></pre></td></tr></table></figure><h4 id="vm-refs-获取所有添加ref属性的元素"><a href="#vm-refs-获取所有添加ref属性的元素" class="headerlink" title="vm.$refs 获取所有添加ref属性的元素"></a>vm.$refs 获取所有添加ref属性的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// console.log(vm.$refs);</span><br><span class="line">// console.log(vm.$refs.hello); //DOM对象</span><br><span class="line">// vm.$refs.hello.style.color=&apos;blue&apos;;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="vm-mount-手动挂载vue实例"><a href="#vm-mount-手动挂载vue实例" class="headerlink" title="vm.$mount()  手动挂载vue实例"></a>vm.$mount()  手动挂载vue实例</h4><pre><code>// vm.$mount(&apos;#itany&apos;);var vm=new Vue({    data:{        msg:&apos;欢迎来到南京网博&apos;,        name:&apos;tom&apos;    }}).$mount(&apos;#itany&apos;);</code></pre><h4 id="vm-destroy-销毁实例"><a href="#vm-destroy-销毁实例" class="headerlink" title="vm.$destroy() 销毁实例"></a>vm.$destroy() 销毁实例</h4><p>这个列出来只是了解一下，官方也建议使用<code>v-if</code>或<code>v-for</code>以数据驱动的方式控制子组件和生命周期</p><pre><code>// vm.$destroy();</code></pre><h4 id="vm-nextTick-callback-在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM"><a href="#vm-nextTick-callback-在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM" class="headerlink" title="vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM"></a>vm.$nextTick(callback) 在DOM更新完成后再执行回调函数，一般在修改数据之后使用该方法，以便获取更新后的DOM</h4><pre><code>//修改数据vm.name=&apos;汤姆&apos;;//DOM还没更新完，Vue实现响应式并不是数据发生改变之后DOM立即变化，需要按一定的策略进行DOM更新，需要时间！！// console.log(vm.$refs.title.textContent);vm.$nextTick(function(){    //DOM更新完成，更新完成后再执行此代码    console.log(vm.$refs.title.textContent);});</code></pre><h4 id="vm-set-target-key-value-添加对象的属性和值"><a href="#vm-set-target-key-value-添加对象的属性和值" class="headerlink" title="vm.$set(target,key,value) 添加对象的属性和值"></a>vm.$set(target,key,value) 添加对象的属性和值</h4><p><a href="https://github.com/stone0090/javascript-lessons/tree/master/2.2-DOM" target="_blank" rel="noopener">关于dom</a></p><p>// vm.$set(this.food, ‘count’, 1);<br>// 注意：在<code>methods方法</code>中不能使用<code>Vue.set</code><br>// 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新<br>// Tip:Vue.set()在methods中可以写成this.$set()</p><h4 id="vm-delete-target-key-删除对象的属性"><a href="#vm-delete-target-key-删除对象的属性" class="headerlink" title="vm.$delete(target,key) 删除对象的属性"></a>vm.$delete(target,key) 删除对象的属性</h4><p>// vm.$delete(this.food, ‘count’);<br>// 注意：在<code>methods方法</code>中不能使用<code>Vue.delete</code></p><h4 id="vm-watch-expOrFn-callback-options-观察者模式"><a href="#vm-watch-expOrFn-callback-options-观察者模式" class="headerlink" title="vm.$watch( expOrFn, callback, [options] ) 观察者模式"></a>vm.$watch( expOrFn, callback, [options] ) 观察者模式</h4><p>参数：监听对象，回调方法，选项（deep/immediate）</p><p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。<br>表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p><p>实例使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式1：使用vue实例提供的$watch()方法</span><br><span class="line">vm.$watch(&apos;name&apos;,function(newValue,oldValue)&#123;</span><br><span class="line">console.log(&apos;name被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>vue提供的选项方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123; //方式2：使用vue实例提供的watch选项</span><br><span class="line">age:(newValue,oldValue) =&gt; &#123;</span><br><span class="line">console.log(&apos;age被修改啦，原值：&apos;+oldValue+&apos;，新值：&apos;+newValue);</span><br><span class="line">&#125;,</span><br><span class="line">    // 对对象监视，需要使用深度监视</span><br><span class="line">user:&#123;</span><br><span class="line">handler:(newValue,oldValue) =&gt; &#123;</span><br><span class="line">console.log(&apos;user被修改啦，原值：&apos;+oldValue.name+&apos;，新值：&apos;+newValue.name);</span><br><span class="line">&#125;,</span><br><span class="line">deep:true //深度监视，当对象中的属性发生变化时也会监视</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="vm-emit-event-…args-触发当前实例上的事件。附加参数都会传给监听器回调。"><a href="#vm-emit-event-…args-触发当前实例上的事件。附加参数都会传给监听器回调。" class="headerlink" title="vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。"></a>vm.$emit( event, […args] ) 触发当前实例上的事件。附加参数都会传给监听器回调。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;vue实例的属性和方法&quot;&gt;&lt;a href=&quot;#vue实例的属性和方法&quot; class=&quot;headerlink&quot; title=&quot;vue实例的属性和方法&quot;&gt;&lt;/a&gt;vue实例的属性和方法&lt;/h1&gt;&lt;p&gt;仅记录部分&lt;br&gt;大部分时候是随学随用，但是学到了就来记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实例属性和方法 == 组件实例和方法 != 全局属性和方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;另外，在组件实例的&lt;code&gt;methods方法&lt;/code&gt;中不能使用全局Vue方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端 vue" scheme="http://blak-kong.github.io/categories/%E5%89%8D%E7%AB%AF-vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
      <category term="vue实例属性 计算属性" scheme="http://blak-kong.github.io/tags/vue%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>vue生命周期和计算属性</title>
    <link href="http://blak-kong.github.io/2018/05/01/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <id>http://blak-kong.github.io/2018/05/01/vue生命周期和计算属性/</id>
    <published>2018-05-01T14:30:52.000Z</published>
    <updated>2019-06-16T08:32:35.106Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="vue有八个生命周期，但只有两个是常用的"><a href="#vue有八个生命周期，但只有两个是常用的" class="headerlink" title="vue有八个生命周期，但只有两个是常用的"></a>vue有八个生命周期，但只有两个是常用的</h2><p>新手阶段只需要掌握created()和mounted()即可</p><a id="more"></a><h4 id="created-实例已经创建完成，并且已经进行数据观测和事件配置"><a href="#created-实例已经创建完成，并且已经进行数据观测和事件配置" class="headerlink" title="created(): 实例已经创建完成，并且已经进行数据观测和事件配置"></a>created(): 实例已经创建完成，并且已经进行数据观测和事件配置</h4><p>此时可用于添加数据、配置事件</p><h4 id="mounted-模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示"><a href="#mounted-模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示" class="headerlink" title="mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示"></a>mounted(): 模板编译之后，已经挂载元素，此时才会渲染页面，才能看到页面上数据的展示</h4><p>此时可用于操作html和dom元素</p><!-- more --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate()&#123;</span><br><span class="line">alert(&apos;组件实例刚刚创建，还未进行数据观测和事件配置&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">created()&#123;  //常用！！！</span><br><span class="line">alert(&apos;实例已经创建完成，并且已经进行数据观测和事件配置&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">beforeMount()&#123;</span><br><span class="line">alert(&apos;模板编译之前，还没挂载&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123; //常用！！！</span><br><span class="line">alert(&apos;模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">beforeUpdate()&#123;</span><br><span class="line">alert(&apos;组件更新之前&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">updated()&#123;</span><br><span class="line">alert(&apos;组件更新之后&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy()&#123;</span><br><span class="line">alert(&apos;组件销毁之前&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">destroyed()&#123;</span><br><span class="line">alert(&apos;组件销毁之后&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 <code>computed</code></h1><p><code>computed</code>：对于两个以上操作的复杂逻辑，应当使用计算属性（不建议仅有一个操作的简单逻辑）。</p><p>一个简单实例-反转字符串<br>html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt; 这里会输出olleh</span><br></pre></td></tr></table></figure></p><p>js代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#example&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos; // 绑定的字符串</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">      // split(&apos;&apos;)把每个字符分割，形成数组</span><br><span class="line">      // reverse()反转数组</span><br><span class="line">      // join(&apos;&apos;)拼接数组元素，返回字符串</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>通过上面的实例，我们看到在计算属性中，当我们定义方法时，是使用了计算属性的一个getter。<br>但是getter和setter往往是一对的，分别是只读只写。<br>所以这个实例，是不是漏了什么呢？</p><p>没错，它还不足以讲解计算属性，<br>这里只是说明了它可以通过调用使用。</p><p>另外，我们可以像绑定普通属性一样在模板中绑定计算属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // =&gt; &apos;olleH&apos;</span><br><span class="line">vm.message = &apos;Goodbye&apos;</span><br><span class="line">console.log(vm.reversedMessage) // =&gt; &apos;eybdooG&apos;</span><br></pre></td></tr></table></figure></p><h2 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h2><p>我们可以将同一函数定义为一个方法而不是一个计算属性。<br>两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。</p><h4 id="computed计算属性-必须有计算"><a href="#computed计算属性-必须有计算" class="headerlink" title="computed计算属性 必须有计算"></a><code>computed计算属性</code> 必须有计算</h4><h4 id="methods方法-一般用于处理事件、改变状态。"><a href="#methods方法-一般用于处理事件、改变状态。" class="headerlink" title="methods方法 一般用于处理事件、改变状态。"></a><code>methods方法</code> 一般用于处理事件、改变状态。</h4><h4 id="计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。"><a href="#计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。" class="headerlink" title="计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。"></a>计算属性只有在它的相关依赖发生改变时才会重新求值（设计初衷是为了缓存）。</h4><p>这就意味着只要<code>数据</code>还没有发生改变，即便多次访问<code>方法</code>，计算属性也会立即返回之前的计算结果，而不必再次执行函数。<br>这也意味着计算属性将不再更新。</p><h2 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。<br>当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch</p><p>然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。</p><h2 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h2><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter。<br>通过给set传值，可以间接改变该计算属性的值。</p><h4 id="（绝对不能直接给计算属性赋值）"><a href="#（绝对不能直接给计算属性赋值）" class="headerlink" title="（绝对不能直接给计算属性赋值）"></a>（绝对不能直接给计算属性赋值）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">data:&#123; //普通属性</span><br><span class="line">num1:8</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123; //计算属性</span><br><span class="line">num2:&#123;</span><br><span class="line">get:function()&#123;</span><br><span class="line">console.log(&apos;num2：&apos;+new Date());</span><br><span class="line">return this.num1-1;</span><br><span class="line">&#125;,</span><br><span class="line">set:function(val)&#123; // val=111</span><br><span class="line">// console.log(&apos;修改num2值&apos;);</span><br><span class="line">// this.num2=val; 不能直接赋值num2，那不是计算,会死循环溢出</span><br><span class="line">this.num1=val;// 赋值修改num1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">change()&#123;</span><br><span class="line">// this.msg=&apos;i love you&apos;;</span><br><span class="line">this.num1=666;// 赋值修改num1</span><br><span class="line">&#125;,</span><br><span class="line">getNum2()&#123;</span><br><span class="line">console.log(new Date());</span><br><span class="line">return this.num1-1;</span><br><span class="line">&#125;,</span><br><span class="line">change2()&#123;</span><br><span class="line">this.num2=111; //传入set</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>一旦发生改变，就会运行，watch中可以自定义函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    obj: &apos;&apos;,</span><br><span class="line">    answer: &apos;请输入!&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    // 如果 `obj` 发生改变，这个函数就会运行</span><br><span class="line">    obj: function (新的值, 旧的值) &#123;</span><br><span class="line">      this.answer = &apos;每次监听到getAnswer()发生变化，就把这句话赋值给answer，反正还是会被getAnswer()覆盖&apos;</span><br><span class="line">      this.getAnswer()// 还在methods方法里自定义要监听调用的函数。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h1&gt;&lt;h2 id=&quot;vue有八个生命周期，但只有两个是常用的&quot;&gt;&lt;a href=&quot;#vue有八个生命周期，但只有两个是常用的&quot; class=&quot;headerlink&quot; title=&quot;vue有八个生命周期，但只有两个是常用的&quot;&gt;&lt;/a&gt;vue有八个生命周期，但只有两个是常用的&lt;/h2&gt;&lt;p&gt;新手阶段只需要掌握created()和mounted()即可&lt;/p&gt;
    
    </summary>
    
      <category term="前端 vue" scheme="http://blak-kong.github.io/categories/%E5%89%8D%E7%AB%AF-vue/"/>
    
    
      <category term="vue" scheme="http://blak-kong.github.io/tags/vue/"/>
    
      <category term="生命周期 计算属性" scheme="http://blak-kong.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ajax学习</title>
    <link href="http://blak-kong.github.io/2018/05/01/ajax%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blak-kong.github.io/2018/05/01/ajax学习/</id>
    <published>2018-05-01T06:46:04.000Z</published>
    <updated>2019-06-16T08:30:59.389Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h1 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h1><h2 id="XMLHttpRequest-是-AJAX-的基础。"><a href="#XMLHttpRequest-是-AJAX-的基础。" class="headerlink" title="XMLHttpRequest 是 AJAX 的基础。"></a>XMLHttpRequest 是 AJAX 的基础。</h2><ul><li>XMLHttpRequest 对象</li></ul><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。<br>它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。<br>这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p><blockquote><p>通过它，你可以很容易的取回一个 URL 上的资源数据。</p></blockquote><p>尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。<br>而且除了 HTTP ，它还支持 file 和 ftp 协议。<br><a id="more"></a></p><h2 id="构造函数-XMLHttpRequest"><a href="#构造函数-XMLHttpRequest" class="headerlink" title="构造函数 XMLHttpRequest()"></a>构造函数 XMLHttpRequest()</h2><p>构造函数初始化一个 XMLHttpRequest 对象。必须在所有其他方法被调用前调用构造函数。</p><p>语法：</p><blockquote><p>var myRequest = new XMLHttpRequest();</p></blockquote><p>此时 myRequest 已经成为一个XMLHttpRequest 对象，可以使用XMLHttpRequest的方法。</p><h2 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class="line">xmlhttp.send(null);</span><br></pre></td></tr></table></figure></p><ul><li><p>open(method,url,async) //<br>规定请求的类型、URL 以及是否异步处理请求。</p><ul><li>method：请求的类型；GET 或 POST</li><li>url：文件在服务器上的位置</li><li>async：true（异步）或 false（同步）</li></ul></li><li><p>send(string) // 将请求发送到服务器。</p><ul><li>string：仅用于 POST 请求（如果不需要发送请求，则必须传入Null）</li></ul></li></ul><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>如果您希望通过 GET 方法发送信息，请向 URL 添加信息（在地址后面加问号，然后再添加）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure></p><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。<br>然后在 send() 方法中规定您希望发送的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);</span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;);</span><br></pre></td></tr></table></figure></p><p>方法:</p><blockquote><p>setRequestHeader(header,value)</p></blockquote><ul><li>向请求添加 HTTP 头。<ul><li>header: 规定头的名称</li><li>value: 规定头的值</li></ul></li></ul><h2 id="我们使用-GET-还是-POST？"><a href="#我们使用-GET-还是-POST？" class="headerlink" title="我们使用 GET 还是 POST？"></a>我们使用 GET 还是 POST？</h2><p>GET 更简单也更快，并且在大部分情况下都能用。<br>然而，在以下情况中，请使用 POST 请求：</p><ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><h2 id="异步如何设置-True-或-False？"><a href="#异步如何设置-True-或-False？" class="headerlink" title="异步如何设置 - True 或 False？"></a>异步如何设置 - True 或 False？</h2><p>AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。<br>XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true。</p><p>通过 AJAX，JavaScript 无需等待服务器的响应，而是：</p><ul><li>在等待服务器响应时执行其他脚本</li><li>当响应就绪后对响应进行处理</li></ul><h2 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h2><p>一个完整的http响应是由状态码，响应头集合，和响应主题组成。<br>在收到响应的消息后，这些都是可以通过xhr对象的属性和方法所使用。<br>它们主要有以下4个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">responseText;作为相应主题返回的文本，（文本形式）</span><br><span class="line">responseXML;如果响应的内容是‘text/xml’或者是哦application/xml;属性中将会保存，响应数据的xml形式。DOM文档形式。</span><br><span class="line"></span><br><span class="line">status: http的状态码（数字形式）</span><br><span class="line">statusText;http状态说明，（文本形式）</span><br></pre></td></tr></table></figure><h2 id="ajax原生"><a href="#ajax原生" class="headerlink" title="ajax原生"></a>ajax原生</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//**********第一步, 获得一个xhr对象*************</span><br><span class="line"></span><br><span class="line">       var xmlHttpReq = null;// 声明一个空对象用来装入XMLHttpRequest</span><br><span class="line"></span><br><span class="line">       if (window.XMLHttpRequest)&#123;// ie7 以上的浏览器XMLHttpRequest是window的子对象</span><br><span class="line"></span><br><span class="line">              xmlHttpReq = new XMLHttpRequest();// 实例化一个XMLHttpRequest</span><br><span class="line"></span><br><span class="line">       &#125;else (window.ActiveXObject)&#123;// IE5 IE6是以ActiveXObject的方式引入XMLHttpRequest的</span><br><span class="line"></span><br><span class="line">              xmlHttpReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(xhr != null)&#123;  // 如果对象实例化成功</span><br><span class="line">              //设置回调函数</span><br><span class="line">              xhr.onreadystatechange = function()&#123;</span><br><span class="line"></span><br><span class="line">                  if(xhr.readyState == 4)&#123;  // 确定响应已经成功返回</span><br><span class="line">                       // 200可作为成功标志, 304表示请求资源没有修改, 可直接使用浏览器缓存</span><br><span class="line">                       if ((xhr.status&gt;=200 &amp;&amp; xhr.status &lt; 300 ) || xhr.status == 304)&#123;</span><br><span class="line">                             alert(xhr.responseText); // 请求成功，服务器返回的数据</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                             alert( &quot;请求失败: &quot; + xhr.status);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">//************第二步: 启动请求.******************</span><br><span class="line">              // open方法接收三个参数: 要发送的请求类型(get,post等), 请求的url和是否异步发送请求的布尔值</span><br><span class="line">              xhr.open(&quot;get&quot;,&quot;test.php&quot;,true);</span><br><span class="line">              // 调用open()方法并采用异步方式. 如果第三个参数是false, 同步执行, 则js代码会等到服务器响应之后再继续执行</span><br><span class="line"></span><br><span class="line">//*************第三步: 发送数据*******************</span><br><span class="line">              // send方法接收一个参数,即要作为请求主体发送的数据. 如果不需要通过请求主体发送数据, 则必须传入null. 因为这个参数对有些浏览器是必须的</span><br><span class="line">              xhr.send(null);</span><br><span class="line">              // 因为使用get方式提交，所以可以使用null参调用</span><br><span class="line"></span><br><span class="line">// 如果要设置请求头部信息,必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()</span><br></pre></td></tr></table></figure><ul><li>readyStatus的五个阶段<ul><li>0：未初始化。尚未调用open()方法</li><li>1：启动。已经调用open()方法，尚未调用send()方法</li><li>2：发送。已经调用send()方法，尚未接收到响应</li><li>3：接收。已经接收部分响应数据。</li><li>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。【一般只需检查这个阶段】</li></ul></li><li>获得的数据在responseText或responseXML属性中, 后者需要XML解析</li></ul><h2 id="ajax跨域"><a href="#ajax跨域" class="headerlink" title="ajax跨域"></a>ajax跨域</h2><p>三种跨域方法：<br>一、一般使用封装好的jsonp</p><p>jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。<br>普通方法: 给html标签添加脚本属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  // 创建script元素标签，设置其属性</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  // 给script标签，设置标签属性</span><br><span class="line">  script.src = src;</span><br><span class="line">  // 把script标签添加成为body的子标签</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">// 提供jsonp服务的url地址，并调用foo函数</span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>jqurey方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> $.ajax(&#123;</span><br><span class="line">    url: &quot;url&quot;,</span><br><span class="line">    type: &quot;GET&quot;,</span><br><span class="line">    dataType: &quot;jsonp&quot;,  //指定服务器返回的数据类型</span><br><span class="line">    jsonp: &quot;cb&quot;,   //指定参数名称</span><br><span class="line">    jsonpCallback: &quot;showData&quot;,  //指定回调函数名称</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">        console.log(&quot;调用success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>二、CORS是跨源资源分享（在后端设置头部支持，允许跨域）</p><ul><li>Access-Control-Allow-Origin:*</li></ul><p>三、设置代理请求（不会）</p><h1 id="vue使用Ajax"><a href="#vue使用Ajax" class="headerlink" title="vue使用Ajax"></a>vue使用Ajax</h1><p>本身不支持发送AJAX请求，需要使用vue-resource、axios等插件实现</p><h2 id="axios使用Ajax"><a href="#axios使用Ajax" class="headerlink" title="axios使用Ajax"></a>axios使用Ajax</h2><p>注意：axios不支持跨域</p><p>参考github上的官方文档，[options]是可以使用的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios([options])  </span><br><span class="line">axios.get(url[,options]);</span><br><span class="line">    传参方式：</span><br><span class="line">        1.通过url传参</span><br><span class="line">        2.通过params选项传参</span><br><span class="line">axios.post(url,data,[options]);</span><br><span class="line">    axios默认发送数据时，数据格式是Request Payload，并非我们常用的Form Data格式，</span><br><span class="line">    所以参数必须要以键值对形式传递，不能以json形式传参</span><br><span class="line">    传参方式：</span><br><span class="line">        1.自己拼接为键值对</span><br><span class="line">        2.使用transformRequest，在请求发送前将请求数据进行转换</span><br><span class="line">        3.如果使用模块化开发，可以使用qs模块进行转换</span><br><span class="line"></span><br><span class="line">axios本身并不支持发送跨域的请求，没有提供相应的API，作者也暂没计划在axios添加支持发送跨域请求，所以只能使用第三方库</span><br></pre></td></tr></table></figure></p><p>get请求示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">写法一（只能用这个，参考上面的传参方式）</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then(function (response) &#123;// 成功</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;// 失败</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">写法二</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="使用vue-resource发送跨域请求"><a href="#使用vue-resource发送跨域请求" class="headerlink" title="使用vue-resource发送跨域请求"></a>使用vue-resource发送跨域请求</h2><p>基本用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用this.$http发送请求  </span><br><span class="line">    this.$http.get(url, [options])</span><br><span class="line">    this.$http.head(url, [options])</span><br><span class="line">    this.$http.delete(url, [options])</span><br><span class="line">    this.$http.jsonp(url, [options])</span><br><span class="line">    this.$http.post(url, [body], [options])</span><br><span class="line">    this.$http.put(url, [body], [options])</span><br><span class="line">    this.$http.patch(url, [body], [options])</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.$http.jsonp(&apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&apos;,&#123;</span><br><span class="line">params:&#123;</span><br><span class="line">wd:this.keyword</span><br><span class="line">&#125;,</span><br><span class="line">jsonp:&apos;cb&apos;</span><br><span class="line">&#125;).then(resp =&gt; &#123;</span><br><span class="line">this.myData=resp.data.s;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;ajax&quot;&gt;&lt;a href=&quot;#ajax&quot; class=&quot;headerlink&quot; title=&quot;ajax&quot;&gt;&lt;/a&gt;ajax&lt;/h1&gt;&lt;h2 id=&quot;XMLHttpRequest-是-AJAX-的基础。&quot;&gt;&lt;a href=&quot;#XMLHttpRequest-是-AJAX-的基础。&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest 是 AJAX 的基础。&quot;&gt;&lt;/a&gt;XMLHttpRequest 是 AJAX 的基础。&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;XMLHttpRequest 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。&lt;br&gt;它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。&lt;br&gt;这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过它，你可以很容易的取回一个 URL 上的资源数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。&lt;br&gt;而且除了 HTTP ，它还支持 file 和 ftp 协议。&lt;br&gt;
    
    </summary>
    
      <category term="JS学习笔记 vue学习" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-vue%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ajax 网络请求 js" scheme="http://blak-kong.github.io/tags/ajax-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-js/"/>
    
  </entry>
  
  <entry>
    <title>js面向对象（原型链）</title>
    <link href="http://blak-kong.github.io/2018/05/01/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%89/"/>
    <id>http://blak-kong.github.io/2018/05/01/js面向对象（原型链）/</id>
    <published>2018-04-30T18:38:44.000Z</published>
    <updated>2019-06-16T08:31:46.401Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>[toc]</p><h1 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h1><p>原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 <strong>proto</strong> 属性指向创建它的构造函数的 prototype（原型）属性。<br>原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、<strong>proto</strong> 这五个概念入手。</p><a id="more"></a><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。<br>比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。<br>下面示例代码对「普通对象」和「函数对象」进行了区分。</p><p>普通对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = new Object();</span><br></pre></td></tr></table></figure></p><p>函数对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;&#125;;</span><br><span class="line">var f2 = function()&#123;&#125;;</span><br><span class="line">var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;);</span><br></pre></td></tr></table></figure></p><p>简单的说，凡是使用 function 关键字或 Function 构造函数创建的对象都是函数对象。<br>而且，只有函数对象才拥有 <code>prototype</code> （原型）属性。</p><h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a><code>constructor</code> 构造函数</h2><p>函数还有一种用法，就是把它作为构造函数使用。<br>像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。<br>此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。</p><p>构造原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 构造函数首字母应大写，便于区分普通函数</span><br><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class="line">&lt;script/&gt;</span><br></pre></td></tr></table></figure></p><h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><code>new</code> 操作符</h2><p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象。</li></ol><p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。</p><blockquote><p>归根结底，使用 <code>new</code> 关键字，可以在后面跟随一个<code>函数调用</code>。</p></blockquote><p>只要通过 new 操作符来调用，那它就可以作为构造函数；<br>而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。</p><h2 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h2><p>构造函数模式虽然好用，但也并非没有缺点。<br>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</p><blockquote><p>函数名是指针，使用<code>构造函数调用</code>创建新对象，解决了内存覆盖问题：<br>但所有对象都是深拷贝，并没有变方便。没有必要创建两个完成同样任务的 Function 实例</p></blockquote><h2 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype 原型"></a><code>prototype</code> 原型</h2><p>我们创建的每个函数都有一个 prototype（原型）属性。<br>使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。<br>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &quot;Stone&quot;;</span><br><span class="line">Person.prototype.age = 28;</span><br><span class="line">Person.prototype.job = &quot;Software Engineer&quot;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();   // &quot;Stone&quot;</span><br><span class="line"></span><br><span class="line">var person2 = new Person();</span><br><span class="line">person2.sayName();   // &quot;Stone&quot;</span><br><span class="line"></span><br><span class="line">console.log(person1.sayName == person2.sayName);  // true</span><br></pre></td></tr></table></figure><p>此例子有缺陷，因为共享了内存。</p><p>若是原型链中存在引用类型，那么一个值改变，所有值都会跟着改变。</p><h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p>在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针（<strong>potor</strong>）。就拿前面的例子来说，Person.prototype.constructor 指向 Person。<br>而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p><p>此时，我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。<br>如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。</p><p>这就是js的屏蔽方法。<br>当为对象实例添加一个属性时，这个属性就会屏蔽原型中保存的同名属性</p><h2 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h2><p>为了摆脱每添加一个属性和方法就要敲一遍 <code>Person.prototype</code><br>为了减少不必要的输入，也为了从视觉上更好地封装原型的功能<br>常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job: &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意：此时 <code>constructor</code> 属性不再指向 Person 了。尽管仍能使用。</p><p>解决办法是把它加回去<code>constructor : Person</code></p><p>注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。<br>默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器</span><br><span class="line">// Object.defineProperty(obj, prop, descriptor)</span><br><span class="line">// 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</span><br><span class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>obj: 要在其上定义属性的对象。<br>prop: 要定义或修改的属性的名称。<br>descriptor: 将被定义或修改的属性描述符。</p><h2 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h2><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var friend = new Person();</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = function()&#123;</span><br><span class="line">    console.log(&quot;hi&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">friend.sayHi();   // &quot;hi&quot;（没有问题！）</span><br></pre></td></tr></table></figure></p><p>其原因可以归结为实例与原型之间的松散连接关系。<br>因为实例与原型之间的连接只不过是一个指针，而非一个副本.</p><p>但如果是重写整个原型对象，那么情况就不一样了。<br>我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]的 <code>__potoy__</code> 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p><blockquote><p>请记住：实例中的指针仅指向原型，而不指向构造函数。</p></blockquote><h2 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h2><p>原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，问题很突出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name : &quot;Stone&quot;,</span><br><span class="line">    age : 28,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    friends : [&quot;ZhangSan&quot;, &quot;LiSi&quot;],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;WangWu&quot;);</span><br><span class="line"></span><br><span class="line">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person2.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person1.friends === person2.friends);  // true</span><br></pre></td></tr></table></figure><blockquote><p>引用类型单独占一块堆内存,连原型也只是指针指向数组</p></blockquote><h2 id="构造函数和原型结合"><a href="#构造函数和原型结合" class="headerlink" title="构造函数和原型结合"></a>构造函数和原型结合</h2><h4 id="构造函数用于定义实例属性，而原型用于定义方法和共享的属性。"><a href="#构造函数用于定义实例属性，而原型用于定义方法和共享的属性。" class="headerlink" title="构造函数用于定义实例属性，而原型用于定义方法和共享的属性。"></a>构造函数用于定义实例属性，而原型用于定义方法和共享的属性。</h4><p>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。<br>下面的代码重写了前面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&quot;ZhangSan&quot;, &quot;LiSi&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName : function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;WangWu&quot;);</span><br><span class="line">console.log(person1.friends);    // &quot;ZhangSan,LiSi,WangWu&quot;</span><br><span class="line">console.log(person2.friends);    // &quot;ZhangSan,LiSi&quot;</span><br><span class="line">console.log(person1.friends === person2.friends);    // false</span><br></pre></td></tr></table></figure><p>构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 <strong>proto</strong> , 指向构造函数的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure></p><p>Object.<strong>proto</strong> = Object.prototype;</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>JavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。<br>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>简单回顾一下构造函数、原型和实例的关系：</p><p>每个构造函数都有一个原型对象(调用对象)<br>原型对象都包含一个指向构造函数的指针(prototype)<br>而实例都包含一个指向原型对象的内部指针。(<strong>proto</strong>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;原型及原型链&quot;&gt;&lt;a href=&quot;#原型及原型链&quot; class=&quot;headerlink&quot; title=&quot;原型及原型链&quot;&gt;&lt;/a&gt;原型及原型链&lt;/h1&gt;&lt;p&gt;原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 &lt;strong&gt;proto&lt;/strong&gt; 属性指向创建它的构造函数的 prototype（原型）属性。&lt;br&gt;原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、&lt;strong&gt;proto&lt;/strong&gt; 这五个概念入手。&lt;/p&gt;
    
    </summary>
    
      <category term="JS学习笔记" scheme="http://blak-kong.github.io/categories/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象 原型链 js" scheme="http://blak-kong.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%E9%93%BE-js/"/>
    
  </entry>
  
</feed>
